   1              		.file	"sercomm.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.sercomm_sendmsg,"ax",%progbits
  12              		.align	2
  13              		.global	sercomm_sendmsg
  15              	sercomm_sendmsg:
  16              	.LFB43:
  17              		.file 1 "comm/sercomm.c"
   1:comm/sercomm.c **** /* Serial communications layer, based on HDLC */
   2:comm/sercomm.c **** 
   3:comm/sercomm.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:comm/sercomm.c ****  *
   5:comm/sercomm.c ****  * All Rights Reserved
   6:comm/sercomm.c ****  *
   7:comm/sercomm.c ****  * This program is free software; you can redistribute it and/or modify
   8:comm/sercomm.c ****  * it under the terms of the GNU General Public License as published by
   9:comm/sercomm.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:comm/sercomm.c ****  * (at your option) any later version.
  11:comm/sercomm.c ****  *
  12:comm/sercomm.c ****  * This program is distributed in the hope that it will be useful,
  13:comm/sercomm.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:comm/sercomm.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:comm/sercomm.c ****  * GNU General Public License for more details.
  16:comm/sercomm.c ****  *
  17:comm/sercomm.c ****  * You should have received a copy of the GNU General Public License along
  18:comm/sercomm.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:comm/sercomm.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:comm/sercomm.c ****  *
  21:comm/sercomm.c ****  */
  22:comm/sercomm.c **** 
  23:comm/sercomm.c **** #include <stdint.h>
  24:comm/sercomm.c **** #include <stdio.h>
  25:comm/sercomm.c **** #include <errno.h>
  26:comm/sercomm.c **** 
  27:comm/sercomm.c **** #include <osmocom/core/msgb.h>
  28:comm/sercomm.c **** 
  29:comm/sercomm.c **** #ifdef HOST_BUILD
  30:comm/sercomm.c **** 
  31:comm/sercomm.c **** # define SERCOMM_RX_MSG_SIZE	2048
  32:comm/sercomm.c **** # ifndef ARRAY_SIZE
  33:comm/sercomm.c **** #  define ARRAY_SIZE(x) (sizeof(x)/sizeof(x[0]))
  34:comm/sercomm.c **** # endif
  35:comm/sercomm.c **** # include <sercomm.h>
  36:comm/sercomm.c **** 
  37:comm/sercomm.c **** static inline void sercomm_lock(unsigned long __attribute__((unused)) *flags) {}
  38:comm/sercomm.c **** static inline void sercomm_unlock(unsigned long __attribute__((unused)) *flags) {}
  39:comm/sercomm.c **** 
  40:comm/sercomm.c **** #else
  41:comm/sercomm.c **** 
  42:comm/sercomm.c **** # define SERCOMM_RX_MSG_SIZE	256
  43:comm/sercomm.c **** # include <debug.h>
  44:comm/sercomm.c **** # include <osmocom/core/linuxlist.h>
  45:comm/sercomm.c **** # include <asm/system.h>
  46:comm/sercomm.c **** 
  47:comm/sercomm.c **** static inline void sercomm_lock(unsigned long *flags)
  48:comm/sercomm.c **** {
  49:comm/sercomm.c **** 	local_firq_save(*flags);
  50:comm/sercomm.c **** }
  51:comm/sercomm.c **** 
  52:comm/sercomm.c **** static inline void sercomm_unlock(unsigned long *flags)
  53:comm/sercomm.c **** {
  54:comm/sercomm.c **** 	local_irq_restore(*flags);
  55:comm/sercomm.c **** }
  56:comm/sercomm.c **** 
  57:comm/sercomm.c **** # include <comm/sercomm.h>
  58:comm/sercomm.c **** # include <uart.h>
  59:comm/sercomm.c **** 
  60:comm/sercomm.c **** #endif
  61:comm/sercomm.c **** 
  62:comm/sercomm.c **** 
  63:comm/sercomm.c **** enum rx_state {
  64:comm/sercomm.c **** 	RX_ST_WAIT_START,
  65:comm/sercomm.c **** 	RX_ST_ADDR,
  66:comm/sercomm.c **** 	RX_ST_CTRL,
  67:comm/sercomm.c **** 	RX_ST_DATA,
  68:comm/sercomm.c **** 	RX_ST_ESCAPE,
  69:comm/sercomm.c **** };
  70:comm/sercomm.c **** 
  71:comm/sercomm.c **** static struct {
  72:comm/sercomm.c **** 	int initialized;
  73:comm/sercomm.c **** 	int uart_id;
  74:comm/sercomm.c **** 
  75:comm/sercomm.c **** 	/* transmit side */
  76:comm/sercomm.c **** 	struct {
  77:comm/sercomm.c **** 		struct llist_head dlci_queues[_SC_DLCI_MAX];
  78:comm/sercomm.c **** 		struct msgb *msg;
  79:comm/sercomm.c **** 		enum rx_state state;
  80:comm/sercomm.c **** 		uint8_t *next_char;
  81:comm/sercomm.c **** 	} tx;
  82:comm/sercomm.c **** 
  83:comm/sercomm.c **** 	/* receive side */
  84:comm/sercomm.c **** 	struct {
  85:comm/sercomm.c **** 		dlci_cb_t dlci_handler[_SC_DLCI_MAX];
  86:comm/sercomm.c **** 		struct msgb *msg;
  87:comm/sercomm.c **** 		enum rx_state state;
  88:comm/sercomm.c **** 		uint8_t dlci;
  89:comm/sercomm.c **** 		uint8_t ctrl;
  90:comm/sercomm.c **** 	} rx;
  91:comm/sercomm.c **** 	
  92:comm/sercomm.c **** } sercomm;
  93:comm/sercomm.c **** 
  94:comm/sercomm.c **** #ifndef HOST_BUILD
  95:comm/sercomm.c **** void sercomm_bind_uart(int uart)
  96:comm/sercomm.c **** {
  97:comm/sercomm.c **** 	sercomm.uart_id = uart;
  98:comm/sercomm.c **** }
  99:comm/sercomm.c **** 
 100:comm/sercomm.c **** int sercomm_get_uart(void)
 101:comm/sercomm.c **** {
 102:comm/sercomm.c **** 	return sercomm.uart_id;
 103:comm/sercomm.c **** }
 104:comm/sercomm.c **** #endif
 105:comm/sercomm.c **** 
 106:comm/sercomm.c **** void sercomm_init(void)
 107:comm/sercomm.c **** {
 108:comm/sercomm.c **** 	unsigned int i;
 109:comm/sercomm.c **** 	for (i = 0; i < ARRAY_SIZE(sercomm.tx.dlci_queues); i++)
 110:comm/sercomm.c **** 		INIT_LLIST_HEAD(&sercomm.tx.dlci_queues[i]);
 111:comm/sercomm.c **** 
 112:comm/sercomm.c **** 	sercomm.rx.msg = NULL;
 113:comm/sercomm.c **** 	sercomm.initialized = 1;
 114:comm/sercomm.c **** 
 115:comm/sercomm.c **** 	/* set up the echo dlci */
 116:comm/sercomm.c **** 	sercomm_register_rx_cb(SC_DLCI_ECHO, &sercomm_sendmsg);
 117:comm/sercomm.c **** }
 118:comm/sercomm.c **** 
 119:comm/sercomm.c **** int sercomm_initialized(void)
 120:comm/sercomm.c **** {
 121:comm/sercomm.c **** 	return sercomm.initialized;
 122:comm/sercomm.c **** }
 123:comm/sercomm.c **** 
 124:comm/sercomm.c **** /* user interface for transmitting messages for a given DLCI */
 125:comm/sercomm.c **** void sercomm_sendmsg(uint8_t dlci, struct msgb *msg)
 126:comm/sercomm.c **** {
  18              		.loc 1 126 0
  19              		.cfi_startproc
  20              		@ args = 0, pretend = 0, frame = 0
  21              		@ frame_needed = 0, uses_anonymous_args = 0
  22              	.LVL0:
  23              	.LBB65:
  24              	.LBB66:
  25              	.LBB67:
  26              	.LBB68:
  27              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
  28              		.loc 2 164 0
  29 0000 402091E5 		ldr	r2, [r1, #64]
  30 0004 383091E5 		ldr	r3, [r1, #56]
  31 0008 022063E0 		rsb	r2, r3, r2
  32              	.LBE68:
  33              	.LBE67:
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 189:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 190:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint8 value to the end of the message
 191:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 192:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 8bit byte to be appended
 193:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 194:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u8(struct msgb *msgb, uint8_t word)
 195:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 196:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 1);
 197:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word & 0xFF;
 198:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 199:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 200:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint16 value to the end of the message
 201:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 202:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 16bit byte to be appended
 203:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 204:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u16(struct msgb *msgb, uint16_t word)
 205:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 206:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 2);
 207:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 8 & 0xFF;
 208:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word & 0xFF;
 209:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 210:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 211:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint32 value to the end of the message
 212:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 213:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 32bit byte to be appended
 214:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 215:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u32(struct msgb *msgb, uint32_t word)
 216:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 217:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 4);
 218:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 24 & 0xFF;
 219:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word >> 16 & 0xFF;
 220:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[2] = word >> 8 & 0xFF;
 221:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[3] = word & 0xFF;
 222:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 223:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 224:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove data from end of message
 225:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 226:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to remove from end
 227:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 228:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_get(struct msgb *msgb, unsigned int len)
 229:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 230:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->data - len;
 231:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_length(msgb) < len)
 232:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "msgb too small to get %u (len %u)\n",
 233:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   len, msgb_length(msgb));
 234:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail -= len;
 235:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 236:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 237:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 238:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from end of message
 239:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 240:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 241:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 242:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_get_u8(struct msgb *msgb)
 243:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 244:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 1);
 245:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 246:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 247:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from end of message
 248:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 249:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 250:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 251:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_get_u16(struct msgb *msgb)
 252:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 253:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 2);
 254:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 255:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 256:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from end of message
 257:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 258:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 259:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 260:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_get_u32(struct msgb *msgb)
 261:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 262:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 4);
 263:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 264:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 265:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 266:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief prepend (push) some data to start of message
 267:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 268:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to pre-pend
 269:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to newly added portion at start of \a msgb
 270:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 271:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further
 272:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * to the front (by \a len bytes), thereby enlarging the message by \a
 273:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes.
 274:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 275:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to the newly added section in the
 276:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * beginning of the message.  It can be used to fill/copy data into it.
 277:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 278:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_push(struct msgb *msgb, unsigned int len)
 279:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 280:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_headroom(msgb) < (int) len)
  34              		.loc 2 280 0
  35 000c 010052E3 		cmp	r2, #1
  36              	.LBE66:
  37              	.LBE65:
  38              		.loc 1 126 0
  39 0010 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
  40              	.LCFI0:
  41              		.cfi_def_cfa_offset 20
  42              		.loc 1 126 0
  43 0014 0140A0E1 		mov	r4, r1
  44              		.cfi_offset 14, -4
  45              		.cfi_offset 7, -8
  46              		.cfi_offset 6, -12
  47              		.cfi_offset 5, -16
  48              		.cfi_offset 4, -20
  49 0018 FF5000E2 		and	r5, r0, #255
  50              	.LBB70:
  51              	.LBB69:
  52              		.loc 2 280 0
  53              	.LVL1:
 281:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough headroom msgb_push (%u < %u)\n",
  54              		.loc 2 281 0
  55 001c 60009FD5 		ldrle	r0, .L3
  56              	.LVL2:
  57 0020 0230A0D3 		movle	r3, #2
  58 0024 FEFFFFDB 		blle	osmo_panic
  59              	.LVL3:
  60              	.L2:
 282:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_headroom(msgb), len);
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
  61              		.loc 2 283 0
  62 0028 403094E5 		ldr	r3, [r4, #64]
  63 002c 022043E2 		sub	r2, r3, #2
  64 0030 402084E5 		str	r2, [r4, #64]
 284:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
  65              		.loc 2 284 0
  66 0034 B623D4E1 		ldrh	r2, [r4, #54]
  67 0038 022082E2 		add	r2, r2, #2
  68 003c B623C4E1 		strh	r2, [r4, #54]	@ movhi
  69              	.LBE69:
  70              	.LBE70:
 127:comm/sercomm.c **** 	unsigned long flags;
 128:comm/sercomm.c **** 	uint8_t *hdr;
 129:comm/sercomm.c **** 
 130:comm/sercomm.c **** 	/* prepend address + control octet */
 131:comm/sercomm.c **** 	hdr = msgb_push(msg, 2);
 132:comm/sercomm.c **** 	hdr[0] = dlci;
 133:comm/sercomm.c **** 	hdr[1] = HDLC_C_UI;
  71              		.loc 1 133 0
  72 0040 0320A0E3 		mov	r2, #3
 132:comm/sercomm.c **** 	hdr[0] = dlci;
  73              		.loc 1 132 0
  74 0044 025043E5 		strb	r5, [r3, #-2]
  75              		.loc 1 133 0
  76 0048 012043E5 		strb	r2, [r3, #-1]
  77              	.LBB71:
  78              	.LBB72:
  49:comm/sercomm.c **** 	local_firq_save(*flags);
  79              		.loc 1 49 0
  80              	@ 49 "comm/sercomm.c" 1
  81 004c 00700FE1 		mrs	r7, cpsr		@ local_firq_save
  82 0050 C03087E3 		orr	r3, r7, #0xC0
  83 0054 03F021E1 		msr	cpsr_c, r3
  84              	@ 0 "" 2
  85              	.LBE72:
  86              	.LBE71:
 134:comm/sercomm.c **** 
 135:comm/sercomm.c **** 	/* This functiion can be called from any context: FIQ, IRQ
 136:comm/sercomm.c **** 	 * and supervisor context.  Proper locking is important! */
 137:comm/sercomm.c **** 	sercomm_lock(&flags);
 138:comm/sercomm.c **** 	msgb_enqueue(&sercomm.tx.dlci_queues[dlci], msg);
  87              		.loc 1 138 0
  88 0058 28609FE5 		ldr	r6, .L3+4
  89 005c 010085E2 		add	r0, r5, #1
  90 0060 800186E0 		add	r0, r6, r0, asl #3
  91 0064 0410A0E1 		mov	r1, r4
  92 0068 FEFFFFEB 		bl	msgb_enqueue
  93              	.LBB73:
  94              	.LBB74:
  54:comm/sercomm.c **** 	local_irq_restore(*flags);
  95              		.loc 1 54 0
  96              	@ 54 "comm/sercomm.c" 1
  97 006c 07F021E1 		msr	cpsr_c, r7		@ local_irq_restore
  98              	
  99              	@ 0 "" 2
 100              	.LBE74:
 101              	.LBE73:
 139:comm/sercomm.c **** 	sercomm_unlock(&flags);
 140:comm/sercomm.c **** 
 141:comm/sercomm.c **** #ifndef HOST_BUILD
 142:comm/sercomm.c **** 	/* tell UART that we have something to send */
 143:comm/sercomm.c **** 	uart_irq_enable(sercomm.uart_id, UART_IRQ_TX_EMPTY, 1);
 102              		.loc 1 143 0
 103 0070 0400D6E5 		ldrb	r0, [r6, #4]	@ zero_extendqisi2
 104 0074 0010A0E3 		mov	r1, #0
 105 0078 0120A0E3 		mov	r2, #1
 144:comm/sercomm.c **** #endif
 145:comm/sercomm.c **** }
 106              		.loc 1 145 0
 107 007c F040BDE8 		ldmfd	sp!, {r4, r5, r6, r7, lr}
 143:comm/sercomm.c **** 	uart_irq_enable(sercomm.uart_id, UART_IRQ_TX_EMPTY, 1);
 108              		.loc 1 143 0
 109 0080 FEFFFFEA 		b	uart_irq_enable
 110              	.L4:
 111              		.align	2
 112              	.L3:
 113 0084 00000000 		.word	.LC0
 114 0088 00000000 		.word	.LANCHOR0
 115              		.cfi_endproc
 116              	.LFE43:
 118              		.section	.text.sercomm_alloc_msgb.clone.2,"ax",%progbits
 119              		.align	2
 121              	sercomm_alloc_msgb.clone.2:
 122              	.LFB51:
 123              		.file 3 "include/comm/sercomm.h"
   1:include/comm/sercomm.h **** #ifndef _SERCOMM_H
   2:include/comm/sercomm.h **** #define _SERCOMM_H
   3:include/comm/sercomm.h **** 
   4:include/comm/sercomm.h **** #include <osmocom/core/msgb.h>
   5:include/comm/sercomm.h **** 
   6:include/comm/sercomm.h **** #define HDLC_FLAG	0x7E
   7:include/comm/sercomm.h **** #define HDLC_ESCAPE	0x7D
   8:include/comm/sercomm.h **** 
   9:include/comm/sercomm.h **** #define HDLC_C_UI	0x03
  10:include/comm/sercomm.h **** #define HDLC_C_P_BIT	(1 << 4)
  11:include/comm/sercomm.h **** #define HDLC_C_F_BIT	(1 << 4)
  12:include/comm/sercomm.h **** 
  13:include/comm/sercomm.h **** /* a low sercomm_dlci means high priority.  A high DLCI means low priority */
  14:include/comm/sercomm.h **** enum sercomm_dlci {
  15:include/comm/sercomm.h **** 	SC_DLCI_HIGHEST = 0,
  16:include/comm/sercomm.h **** 	SC_DLCI_DEBUG   = 4,
  17:include/comm/sercomm.h **** 	SC_DLCI_L1A_L23 = 5,
  18:include/comm/sercomm.h **** 	SC_DLCI_LOADER  = 9,
  19:include/comm/sercomm.h **** 	SC_DLCI_CONSOLE = 10,
  20:include/comm/sercomm.h **** 	SC_DLCI_ECHO    = 128,
  21:include/comm/sercomm.h **** 	_SC_DLCI_MAX
  22:include/comm/sercomm.h **** };
  23:include/comm/sercomm.h **** 
  24:include/comm/sercomm.h **** #ifndef HOST_BUILD
  25:include/comm/sercomm.h **** /* helper functions for target */
  26:include/comm/sercomm.h **** void sercomm_bind_uart(int uart);
  27:include/comm/sercomm.h **** int sercomm_get_uart(void);
  28:include/comm/sercomm.h **** #endif
  29:include/comm/sercomm.h **** 
  30:include/comm/sercomm.h **** void sercomm_init(void);
  31:include/comm/sercomm.h **** int sercomm_initialized(void);
  32:include/comm/sercomm.h **** 
  33:include/comm/sercomm.h **** /* User Interface: Tx */
  34:include/comm/sercomm.h **** 
  35:include/comm/sercomm.h **** /* user interface for transmitting messages for a given DLCI */
  36:include/comm/sercomm.h **** void sercomm_sendmsg(uint8_t dlci, struct msgb *msg);
  37:include/comm/sercomm.h **** /* how deep is the Tx queue for a given DLCI */
  38:include/comm/sercomm.h **** unsigned int sercomm_tx_queue_depth(uint8_t dlci);
  39:include/comm/sercomm.h **** 
  40:include/comm/sercomm.h **** /* User Interface: Rx */
  41:include/comm/sercomm.h **** 
  42:include/comm/sercomm.h **** /* receiving messages for a given DLCI */
  43:include/comm/sercomm.h **** typedef void (*dlci_cb_t)(uint8_t dlci, struct msgb *msg);
  44:include/comm/sercomm.h **** int sercomm_register_rx_cb(uint8_t dlci, dlci_cb_t cb);
  45:include/comm/sercomm.h **** 
  46:include/comm/sercomm.h **** /* Driver Interface */
  47:include/comm/sercomm.h **** 
  48:include/comm/sercomm.h **** /* fetch one octet of to-be-transmitted serial data. returns 0 if no more data */
  49:include/comm/sercomm.h **** int sercomm_drv_pull(uint8_t *ch);
  50:include/comm/sercomm.h **** /* the driver has received one byte, pass it into sercomm layer.
  51:include/comm/sercomm.h ****    returns 1 in case of success, 0 in case of unrecognized char */
  52:include/comm/sercomm.h **** int sercomm_drv_rx_char(uint8_t ch);
  53:include/comm/sercomm.h **** 
  54:include/comm/sercomm.h **** static inline struct msgb *sercomm_alloc_msgb(unsigned int len)
 124              		.loc 3 54 0
 125              		.cfi_startproc
 126              		@ args = 0, pretend = 0, frame = 0
 127              		@ frame_needed = 0, uses_anonymous_args = 0
 128              	.LVL4:
 129 0000 04E02DE5 		str	lr, [sp, #-4]!
 130              	.LCFI1:
 131              		.cfi_def_cfa_offset 4
 132              	.LBB75:
 133              	.LBB76:
 285:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data;
 286:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 287:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove (pull) a header from the front of the message buffer
 288:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 289:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of octets to be pulled
 290:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to new start of msgb
 291:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 292:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further back
 293:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * in the message, thereby shrinking the size of the message by \a len
 294:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * bytes.
 295:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 296:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_pull(struct msgb *msgb, unsigned int len)
 297:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 300:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 301:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 302:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from front of message
 303:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 304:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 305:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 306:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_pull_u8(struct msgb *msgb)
 307:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 308:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 1) - 1;
 309:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 310:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 311:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from front of message
 312:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 313:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 314:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 315:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_pull_u16(struct msgb *msgb)
 316:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 317:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 2) - 2;
 318:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 319:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 320:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from front of message
 321:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 322:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 323:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 324:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_pull_u32(struct msgb *msgb)
 325:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 326:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 4) - 4;
 327:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 328:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 329:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 330:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Increase headroom of empty msgb, reducing the tailroom
 331:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 332:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len amount of extra octets to be reserved as headroom
 333:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 334:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function reserves some memory at the beginning of the underlying
 335:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer.  The idea is to reserve space in case further headers
 336:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * have to be pushed to the \ref msgb during further processing.
 337:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 338:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * Calling this function leads to undefined reusults if it is called on
 339:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * a non-empty \ref msgb.
 340:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 341:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_reserve(struct msgb *msg, int len)
 342:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 345:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 346:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 347:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given absolute length
 348:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 349:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len new total length of buffer
 350:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 351:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 352:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_trim(struct msgb *msg, int len)
 353:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 354:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (len > msg->data_len)
 355:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		return -1;
 356:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 357:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->len = len;
 358:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail = msg->data + len;
 359:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 360:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return 0;
 361:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 362:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 363:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given layer3 length
 364:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \pram[in] msg message buffer
 365:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] l3len new layer3 length
 366:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 367:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 368:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_l3trim(struct msgb *msg, int l3len)
 369:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 370:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb_trim(msg, (msg->l3h - msg->data) + l3len);
 371:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 372:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 373:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Allocate message buffer with specified headroom
 374:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] size size in bytes, including headroom
 375:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] headroom headroom in bytes
 376:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] name human-readable name
 377:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns allocated message buffer with specified headroom
 378:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 379:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function is a convenience wrapper around \ref msgb_alloc
 380:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * followed by \ref msgb_reserve in order to create a new \ref msgb with
 381:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * user-specified amount of headroom.
 382:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 383:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline struct msgb *msgb_alloc_headroom(int size, int headroom,
 384:../../shared/libosmocore/include/osmocom/core/msgb.h **** 						const char *name)
 385:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 386:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_static_assert(size > headroom, headroom_bigger);
 387:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 388:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct msgb *msg = msgb_alloc(size, name);
 134              		.loc 2 388 0
 135 0004 410FA0E3 		mov	r0, #260
 136 0008 24109FE5 		ldr	r1, .L7
 137              		.cfi_offset 14, -4
 138 000c FEFFFFEB 		bl	msgb_alloc
 139              	.LVL5:
 389:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msg)
 140              		.loc 2 389 0
 141 0010 000050E3 		cmp	r0, #0
 142 0014 04F09D04 		ldreq	pc, [sp], #4
 143              	.LVL6:
 144              	.LBB77:
 145              	.LBB78:
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 146              		.loc 2 343 0
 147 0018 403090E5 		ldr	r3, [r0, #64]
 148 001c 043083E2 		add	r3, r3, #4
 149 0020 403080E5 		str	r3, [r0, #64]
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 150              		.loc 2 344 0
 151 0024 3C3090E5 		ldr	r3, [r0, #60]
 152 0028 043083E2 		add	r3, r3, #4
 153 002c 3C3080E5 		str	r3, [r0, #60]
 154              	.LBE78:
 155              	.LBE77:
 156              	.LBE76:
 157              	.LBE75:
  55:include/comm/sercomm.h **** {
  56:include/comm/sercomm.h **** 	return msgb_alloc_headroom(len+4, 4, "sercomm_tx");
  57:include/comm/sercomm.h **** }
 158              		.loc 3 57 0
 159 0030 04F09DE4 		ldr	pc, [sp], #4
 160              	.L8:
 161              		.align	2
 162              	.L7:
 163 0034 33000000 		.word	.LC1
 164              		.cfi_endproc
 165              	.LFE51:
 167              		.section	.text.sercomm_bind_uart,"ax",%progbits
 168              		.align	2
 169              		.global	sercomm_bind_uart
 171              	sercomm_bind_uart:
 172              	.LFB39:
  96:comm/sercomm.c **** {
 173              		.loc 1 96 0
 174              		.cfi_startproc
 175              		@ args = 0, pretend = 0, frame = 0
 176              		@ frame_needed = 0, uses_anonymous_args = 0
 177              		@ link register save eliminated.
 178              	.LVL7:
  97:comm/sercomm.c **** 	sercomm.uart_id = uart;
 179              		.loc 1 97 0
 180 0000 04309FE5 		ldr	r3, .L10
 181 0004 040083E5 		str	r0, [r3, #4]
  98:comm/sercomm.c **** }
 182              		.loc 1 98 0
 183 0008 1EFF2FE1 		bx	lr
 184              	.L11:
 185              		.align	2
 186              	.L10:
 187 000c 00000000 		.word	.LANCHOR0
 188              		.cfi_endproc
 189              	.LFE39:
 191              		.section	.text.sercomm_get_uart,"ax",%progbits
 192              		.align	2
 193              		.global	sercomm_get_uart
 195              	sercomm_get_uart:
 196              	.LFB40:
 101:comm/sercomm.c **** {
 197              		.loc 1 101 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 0
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              		@ link register save eliminated.
 103:comm/sercomm.c **** }
 202              		.loc 1 103 0
 203 0000 04309FE5 		ldr	r3, .L13
 204 0004 040093E5 		ldr	r0, [r3, #4]
 205 0008 1EFF2FE1 		bx	lr
 206              	.L14:
 207              		.align	2
 208              	.L13:
 209 000c 00000000 		.word	.LANCHOR0
 210              		.cfi_endproc
 211              	.LFE40:
 213              		.section	.text.sercomm_initialized,"ax",%progbits
 214              		.align	2
 215              		.global	sercomm_initialized
 217              	sercomm_initialized:
 218              	.LFB42:
 120:comm/sercomm.c **** {
 219              		.loc 1 120 0
 220              		.cfi_startproc
 221              		@ args = 0, pretend = 0, frame = 0
 222              		@ frame_needed = 0, uses_anonymous_args = 0
 223              		@ link register save eliminated.
 122:comm/sercomm.c **** }
 224              		.loc 1 122 0
 225 0000 04309FE5 		ldr	r3, .L16
 226 0004 000093E5 		ldr	r0, [r3, #0]
 227 0008 1EFF2FE1 		bx	lr
 228              	.L17:
 229              		.align	2
 230              	.L16:
 231 000c 00000000 		.word	.LANCHOR0
 232              		.cfi_endproc
 233              	.LFE42:
 235              		.section	.text.sercomm_tx_queue_depth,"ax",%progbits
 236              		.align	2
 237              		.global	sercomm_tx_queue_depth
 239              	sercomm_tx_queue_depth:
 240              	.LFB44:
 146:comm/sercomm.c **** 
 147:comm/sercomm.c **** /* how deep is the Tx queue for a given DLCI */
 148:comm/sercomm.c **** unsigned int sercomm_tx_queue_depth(uint8_t dlci)
 149:comm/sercomm.c **** {
 241              		.loc 1 149 0
 242              		.cfi_startproc
 243              		@ args = 0, pretend = 0, frame = 0
 244              		@ frame_needed = 0, uses_anonymous_args = 0
 245              		@ link register save eliminated.
 246              	.LVL8:
 247              		.loc 1 149 0
 248 0000 FF1000E2 		and	r1, r0, #255
 150:comm/sercomm.c **** 	struct llist_head *le;
 151:comm/sercomm.c **** 	unsigned int num = 0;
 152:comm/sercomm.c **** 
 153:comm/sercomm.c **** 	llist_for_each(le, &sercomm.tx.dlci_queues[dlci]) {
 249              		.loc 1 153 0
 250 0004 24209FE5 		ldr	r2, .L21
 251 0008 011081E2 		add	r1, r1, #1
 252 000c 813192E7 		ldr	r3, [r2, r1, asl #3]
 253              	.LVL9:
 151:comm/sercomm.c **** 	unsigned int num = 0;
 254              		.loc 1 151 0
 255 0010 0000A0E3 		mov	r0, #0
 256              	.LVL10:
 257              		.loc 1 153 0
 258 0014 812182E0 		add	r2, r2, r1, asl #3
 259              	.LVL11:
 260 0018 010000EA 		b	.L19
 261              	.LVL12:
 262              	.L20:
 263              		.loc 1 153 0 is_stmt 0 discriminator 2
 264 001c 003093E5 		ldr	r3, [r3, #0]
 265              	.LVL13:
 154:comm/sercomm.c **** 		num++;
 266              		.loc 1 154 0 is_stmt 1 discriminator 2
 267 0020 010080E2 		add	r0, r0, #1
 268              	.LVL14:
 269              	.L19:
 153:comm/sercomm.c **** 	llist_for_each(le, &sercomm.tx.dlci_queues[dlci]) {
 270              		.loc 1 153 0 discriminator 1
 271 0024 020053E1 		cmp	r3, r2
 272 0028 FBFFFF1A 		bne	.L20
 155:comm/sercomm.c **** 	}
 156:comm/sercomm.c **** 
 157:comm/sercomm.c **** 	return num;
 158:comm/sercomm.c **** }
 273              		.loc 1 158 0
 274 002c 1EFF2FE1 		bx	lr
 275              	.L22:
 276              		.align	2
 277              	.L21:
 278 0030 00000000 		.word	.LANCHOR0
 279              		.cfi_endproc
 280              	.LFE44:
 282              		.section	.text.sercomm_drv_pull,"ax",%progbits
 283              		.align	2
 284              		.global	sercomm_drv_pull
 286              	sercomm_drv_pull:
 287              	.LFB45:
 159:comm/sercomm.c **** 
 160:comm/sercomm.c **** /* fetch one octet of to-be-transmitted serial data */
 161:comm/sercomm.c **** int sercomm_drv_pull(uint8_t *ch)
 162:comm/sercomm.c **** {
 288              		.loc 1 162 0
 289              		.cfi_startproc
 290              		@ args = 0, pretend = 0, frame = 0
 291              		@ frame_needed = 0, uses_anonymous_args = 0
 292              	.LVL15:
 293 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 294              	.LCFI2:
 295              		.cfi_def_cfa_offset 24
 296              		.loc 1 162 0
 297 0004 0050A0E1 		mov	r5, r0
 298              		.cfi_offset 14, -4
 299              		.cfi_offset 8, -8
 300              		.cfi_offset 7, -12
 301              		.cfi_offset 6, -16
 302              		.cfi_offset 5, -20
 303              		.cfi_offset 4, -24
 304              	.LBB79:
 305              	.LBB80:
  49:comm/sercomm.c **** 	local_firq_save(*flags);
 306              		.loc 1 49 0
 307              	@ 49 "comm/sercomm.c" 1
 308 0008 00600FE1 		mrs	r6, cpsr		@ local_firq_save
 309 000c C03086E3 		orr	r3, r6, #0xC0
 310 0010 03F021E1 		msr	cpsr_c, r3
 311              	@ 0 "" 2
 312              	.LVL16:
 313              	.LBE80:
 314              	.LBE79:
 163:comm/sercomm.c **** 	unsigned long flags;
 164:comm/sercomm.c **** 
 165:comm/sercomm.c **** 	/* we may be called from interrupt context, but we stiff need to lock
 166:comm/sercomm.c **** 	 * because sercomm could be accessed from a FIQ context ... */
 167:comm/sercomm.c **** 
 168:comm/sercomm.c **** 	sercomm_lock(&flags);
 169:comm/sercomm.c **** 
 170:comm/sercomm.c **** 	if (!sercomm.tx.msg) {
 315              		.loc 1 170 0
 316 0014 F8409FE5 		ldr	r4, .L38
 317 0018 108494E5 		ldr	r8, [r4, #1040]
 318 001c 000058E3 		cmp	r8, #0
 319 0020 1100001A 		bne	.L24
 320              	.LVL17:
 321              	.L26:
 322              	.LBB81:
 171:comm/sercomm.c **** 		unsigned int i;
 172:comm/sercomm.c **** 		/* dequeue a new message from the queues */
 173:comm/sercomm.c **** 		for (i = 0; i < ARRAY_SIZE(sercomm.tx.dlci_queues); i++) {
 174:comm/sercomm.c **** 			sercomm.tx.msg = msgb_dequeue(&sercomm.tx.dlci_queues[i]);
 323              		.loc 1 174 0
 324 0024 018088E2 		add	r8, r8, #1
 325 0028 880184E0 		add	r0, r4, r8, asl #3
 326 002c FEFFFFEB 		bl	msgb_dequeue
 175:comm/sercomm.c **** 			if (sercomm.tx.msg)
 327              		.loc 1 175 0
 328 0030 000050E3 		cmp	r0, #0
 174:comm/sercomm.c **** 			sercomm.tx.msg = msgb_dequeue(&sercomm.tx.dlci_queues[i]);
 329              		.loc 1 174 0
 330 0034 D8709FE5 		ldr	r7, .L38
 331 0038 100484E5 		str	r0, [r4, #1040]
 332              		.loc 1 175 0
 333 003c 0200001A 		bne	.L25
 334              	.LVL18:
 173:comm/sercomm.c **** 		for (i = 0; i < ARRAY_SIZE(sercomm.tx.dlci_queues); i++) {
 335              		.loc 1 173 0
 336 0040 810058E3 		cmp	r8, #129
 337 0044 F6FFFF1A 		bne	.L26
 338 0048 2F0000EA 		b	.L37
 339              	.LVL19:
 340              	.L25:
 176:comm/sercomm.c **** 				break;
 177:comm/sercomm.c **** 		}
 178:comm/sercomm.c **** 		if (sercomm.tx.msg) {
 179:comm/sercomm.c **** 			/* start of a new message, send start flag octet */
 180:comm/sercomm.c **** 			*ch = HDLC_FLAG;
 341              		.loc 1 180 0
 342 004c 7E30A0E3 		mov	r3, #126
 343 0050 0030C5E5 		strb	r3, [r5, #0]
 181:comm/sercomm.c **** 			sercomm.tx.next_char = sercomm.tx.msg->data;
 344              		.loc 1 181 0
 345 0054 103497E5 		ldr	r3, [r7, #1040]
 346 0058 403093E5 		ldr	r3, [r3, #64]
 347 005c 183487E5 		str	r3, [r7, #1048]
 348              	.LBB82:
 349              	.LBB83:
  54:comm/sercomm.c **** 	local_irq_restore(*flags);
 350              		.loc 1 54 0
 351              	@ 54 "comm/sercomm.c" 1
 352 0060 06F021E1 		msr	cpsr_c, r6		@ local_irq_restore
 353              	
 354              	@ 0 "" 2
 355              	.LBE83:
 356              	.LBE82:
 182:comm/sercomm.c **** 			sercomm_unlock(&flags);
 183:comm/sercomm.c **** 			return 1;
 357              		.loc 1 183 0
 358 0064 0100A0E3 		mov	r0, #1
 359 0068 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 360              	.L24:
 361              	.LBE81:
 184:comm/sercomm.c **** 		} else {
 185:comm/sercomm.c **** 			/* no more data avilable */
 186:comm/sercomm.c **** 			sercomm_unlock(&flags);
 187:comm/sercomm.c **** 			return 0;
 188:comm/sercomm.c **** 		}
 189:comm/sercomm.c **** 	}
 190:comm/sercomm.c **** 
 191:comm/sercomm.c **** 	if (sercomm.tx.state == RX_ST_ESCAPE) {
 362              		.loc 1 191 0
 363 006c 143494E5 		ldr	r3, [r4, #1044]
 364 0070 040053E3 		cmp	r3, #4
 365 0074 0500001A 		bne	.L29
 192:comm/sercomm.c **** 		/* we've already transmitted the ESCAPE octet,
 193:comm/sercomm.c **** 		 * we now need to transmit the escaped data */
 194:comm/sercomm.c **** 		*ch = *sercomm.tx.next_char++;
 366              		.loc 1 194 0
 367 0078 183494E5 		ldr	r3, [r4, #1048]
 368 007c 0120D3E4 		ldrb	r2, [r3], #1	@ zero_extendqisi2
 369 0080 0020C0E5 		strb	r2, [r0, #0]
 370 0084 183484E5 		str	r3, [r4, #1048]
 195:comm/sercomm.c **** 		sercomm.tx.state = RX_ST_DATA;
 371              		.loc 1 195 0
 372 0088 0330A0E3 		mov	r3, #3
 373 008c 180000EA 		b	.L35
 374              	.L29:
 196:comm/sercomm.c **** 	} else if (sercomm.tx.next_char >= sercomm.tx.msg->tail) {
 375              		.loc 1 196 0
 376 0090 183494E5 		ldr	r3, [r4, #1048]
 377 0094 3C2098E5 		ldr	r2, [r8, #60]
 378 0098 020053E1 		cmp	r3, r2
 379 009c 0600003A 		bcc	.L31
 197:comm/sercomm.c **** 		/* last character has already been transmitted,
 198:comm/sercomm.c **** 		 * send end-of-message octet */
 199:comm/sercomm.c **** 		*ch = HDLC_FLAG;
 380              		.loc 1 199 0
 381 00a0 7E30A0E3 		mov	r3, #126
 382 00a4 0030C0E5 		strb	r3, [r0, #0]
 200:comm/sercomm.c **** 		/* we've reached the end of the message buffer */
 201:comm/sercomm.c **** 		msgb_free(sercomm.tx.msg);
 383              		.loc 1 201 0
 384 00a8 100494E5 		ldr	r0, [r4, #1040]
 385 00ac FEFFFFEB 		bl	msgb_free
 202:comm/sercomm.c **** 		sercomm.tx.msg = NULL;
 386              		.loc 1 202 0
 387 00b0 0030A0E3 		mov	r3, #0
 388 00b4 103484E5 		str	r3, [r4, #1040]
 389 00b8 0F0000EA 		b	.L36
 390              	.L31:
 203:comm/sercomm.c **** 		sercomm.tx.next_char = NULL;
 204:comm/sercomm.c **** 	/* escaping for the two control octets */
 205:comm/sercomm.c **** 	} else if (*sercomm.tx.next_char == HDLC_FLAG ||
 391              		.loc 1 205 0
 392 00bc 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 206:comm/sercomm.c **** 		   *sercomm.tx.next_char == HDLC_ESCAPE ||
 393              		.loc 1 206 0
 394 00c0 7D1042E2 		sub	r1, r2, #125
 205:comm/sercomm.c **** 	} else if (*sercomm.tx.next_char == HDLC_FLAG ||
 395              		.loc 1 205 0
 396 00c4 000052E3 		cmp	r2, #0
 397 00c8 01005113 		cmpne	r1, #1
 207:comm/sercomm.c **** 		   *sercomm.tx.next_char == 0x00) {
 208:comm/sercomm.c **** 		/* send an escape octet */
 209:comm/sercomm.c **** 		*ch = HDLC_ESCAPE;
 210:comm/sercomm.c **** 		/* invert bit 5 of the next octet to be sent */
 211:comm/sercomm.c **** 		*sercomm.tx.next_char ^= (1 << 5);
 212:comm/sercomm.c **** 		sercomm.tx.state = RX_ST_ESCAPE;
 213:comm/sercomm.c **** 	} else {
 214:comm/sercomm.c **** 		/* standard case, simply send next octet */
 215:comm/sercomm.c **** 		*ch = *sercomm.tx.next_char++;
 398              		.loc 1 215 0
 399 00cc 0020C085 		strhib	r2, [r0, #0]
 400 00d0 01308382 		addhi	r3, r3, #1
 205:comm/sercomm.c **** 	} else if (*sercomm.tx.next_char == HDLC_FLAG ||
 401              		.loc 1 205 0
 402 00d4 0800008A 		bhi	.L36
 209:comm/sercomm.c **** 		*ch = HDLC_ESCAPE;
 403              		.loc 1 209 0
 404 00d8 7D30A0E3 		mov	r3, #125
 405 00dc 0030C0E5 		strb	r3, [r0, #0]
 211:comm/sercomm.c **** 		*sercomm.tx.next_char ^= (1 << 5);
 406              		.loc 1 211 0
 407 00e0 183494E5 		ldr	r3, [r4, #1048]
 408 00e4 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 409 00e8 202022E2 		eor	r2, r2, #32
 410 00ec 0020C3E5 		strb	r2, [r3, #0]
 212:comm/sercomm.c **** 		sercomm.tx.state = RX_ST_ESCAPE;
 411              		.loc 1 212 0
 412 00f0 0430A0E3 		mov	r3, #4
 413              	.L35:
 414 00f4 143484E5 		str	r3, [r4, #1044]
 415 00f8 000000EA 		b	.L30
 416              	.L36:
 417              		.loc 1 215 0
 418 00fc 183484E5 		str	r3, [r4, #1048]
 419              	.L30:
 420              	.LBB86:
 421              	.LBB87:
  54:comm/sercomm.c **** 	local_irq_restore(*flags);
 422              		.loc 1 54 0
 423              	@ 54 "comm/sercomm.c" 1
 424 0100 06F021E1 		msr	cpsr_c, r6		@ local_irq_restore
 425              	
 426              	@ 0 "" 2
 427              	.LBE87:
 428              	.LBE86:
 216:comm/sercomm.c **** 	}
 217:comm/sercomm.c **** 
 218:comm/sercomm.c **** 	sercomm_unlock(&flags);
 219:comm/sercomm.c **** 	return 1;
 429              		.loc 1 219 0
 430 0104 0100A0E3 		mov	r0, #1
 220:comm/sercomm.c **** }
 431              		.loc 1 220 0
 432 0108 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 433              	.LVL20:
 434              	.L37:
 435              	.LBB88:
 436              	.LBB84:
 437              	.LBB85:
  54:comm/sercomm.c **** 	local_irq_restore(*flags);
 438              		.loc 1 54 0
 439              	@ 54 "comm/sercomm.c" 1
 440 010c 06F021E1 		msr	cpsr_c, r6		@ local_irq_restore
 441              	
 442              	@ 0 "" 2
 443              	.LBE85:
 444              	.LBE84:
 187:comm/sercomm.c **** 			return 0;
 445              		.loc 1 187 0
 446 0110 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 447              	.L39:
 448              		.align	2
 449              	.L38:
 450 0114 00000000 		.word	.LANCHOR0
 451              	.LBE88:
 452              		.cfi_endproc
 453              	.LFE45:
 455              		.section	.text.sercomm_register_rx_cb,"ax",%progbits
 456              		.align	2
 457              		.global	sercomm_register_rx_cb
 459              	sercomm_register_rx_cb:
 460              	.LFB46:
 221:comm/sercomm.c **** 
 222:comm/sercomm.c **** /* register a handler for a given DLCI */
 223:comm/sercomm.c **** int sercomm_register_rx_cb(uint8_t dlci, dlci_cb_t cb)
 224:comm/sercomm.c **** {
 461              		.loc 1 224 0
 462              		.cfi_startproc
 463              		@ args = 0, pretend = 0, frame = 0
 464              		@ frame_needed = 0, uses_anonymous_args = 0
 465              		@ link register save eliminated.
 466              	.LVL21:
 467              		.loc 1 224 0
 468 0000 FF0000E2 		and	r0, r0, #255
 469              	.LVL22:
 225:comm/sercomm.c **** 	if (dlci >= ARRAY_SIZE(sercomm.rx.dlci_handler))
 470              		.loc 1 225 0
 471 0004 800050E3 		cmp	r0, #128
 226:comm/sercomm.c **** 		return -EINVAL;
 472              		.loc 1 226 0
 473 0008 1500E083 		mvnhi	r0, #21
 225:comm/sercomm.c **** 	if (dlci >= ARRAY_SIZE(sercomm.rx.dlci_handler))
 474              		.loc 1 225 0
 475 000c 1EFF2F81 		bxhi	lr
 227:comm/sercomm.c **** 
 228:comm/sercomm.c **** 	if (sercomm.rx.dlci_handler[dlci])
 476              		.loc 1 228 0
 477 0010 18309FE5 		ldr	r3, .L44
 478 0014 410F80E2 		add	r0, r0, #260
 479 0018 032080E2 		add	r2, r0, #3
 480 001c 020193E7 		ldr	r0, [r3, r2, asl #2]
 481 0020 000050E3 		cmp	r0, #0
 229:comm/sercomm.c **** 		return -EBUSY;
 230:comm/sercomm.c **** 
 231:comm/sercomm.c **** 	sercomm.rx.dlci_handler[dlci] = cb;
 482              		.loc 1 231 0
 483 0024 02118307 		streq	r1, [r3, r2, asl #2]
 229:comm/sercomm.c **** 		return -EBUSY;
 484              		.loc 1 229 0
 485 0028 0F00E013 		mvnne	r0, #15
 232:comm/sercomm.c **** 	return 0;
 233:comm/sercomm.c **** }
 486              		.loc 1 233 0
 487 002c 1EFF2FE1 		bx	lr
 488              	.L45:
 489              		.align	2
 490              	.L44:
 491 0030 00000000 		.word	.LANCHOR0
 492              		.cfi_endproc
 493              	.LFE46:
 495              		.section	.text.sercomm_init,"ax",%progbits
 496              		.align	2
 497              		.global	sercomm_init
 499              	sercomm_init:
 500              	.LFB41:
 107:comm/sercomm.c **** {
 501              		.loc 1 107 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 0
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505              		@ link register save eliminated.
 506              	.LVL23:
 109:comm/sercomm.c **** 	for (i = 0; i < ARRAY_SIZE(sercomm.tx.dlci_queues); i++)
 507              		.loc 1 109 0
 508 0000 40309FE5 		ldr	r3, .L49
 509 0004 0020A0E3 		mov	r2, #0
 110:comm/sercomm.c **** 		INIT_LLIST_HEAD(&sercomm.tx.dlci_queues[i]);
 510              		.loc 1 110 0
 511 0008 03C0A0E1 		mov	ip, r3
 512              	.LVL24:
 513              	.L47:
 110:comm/sercomm.c **** 		INIT_LLIST_HEAD(&sercomm.tx.dlci_queues[i]);
 514              		.loc 1 110 0 is_stmt 0 discriminator 2
 515 000c 012082E2 		add	r2, r2, #1
 516 0010 82018CE0 		add	r0, ip, r2, asl #3
 109:comm/sercomm.c **** 	for (i = 0; i < ARRAY_SIZE(sercomm.tx.dlci_queues); i++)
 517              		.loc 1 109 0 is_stmt 1 discriminator 2
 518 0014 810052E3 		cmp	r2, #129
 110:comm/sercomm.c **** 		INIT_LLIST_HEAD(&sercomm.tx.dlci_queues[i]);
 519              		.loc 1 110 0 discriminator 2
 520 0018 080083E5 		str	r0, [r3, #8]
 521 001c 0C0083E5 		str	r0, [r3, #12]
 522              	.LVL25:
 523 0020 20109FE5 		ldr	r1, .L49
 109:comm/sercomm.c **** 	for (i = 0; i < ARRAY_SIZE(sercomm.tx.dlci_queues); i++)
 524              		.loc 1 109 0 discriminator 2
 525 0024 083083E2 		add	r3, r3, #8
 526 0028 F7FFFF1A 		bne	.L47
 112:comm/sercomm.c **** 	sercomm.rx.msg = NULL;
 527              		.loc 1 112 0
 528 002c 0030A0E3 		mov	r3, #0
 529 0030 203681E5 		str	r3, [r1, #1568]
 113:comm/sercomm.c **** 	sercomm.initialized = 1;
 530              		.loc 1 113 0
 531 0034 013083E2 		add	r3, r3, #1
 532 0038 003081E5 		str	r3, [r1, #0]
 116:comm/sercomm.c **** 	sercomm_register_rx_cb(SC_DLCI_ECHO, &sercomm_sendmsg);
 533              		.loc 1 116 0
 534 003c 08109FE5 		ldr	r1, .L49+4
 535 0040 8000A0E3 		mov	r0, #128
 117:comm/sercomm.c **** }
 536              		.loc 1 117 0
 116:comm/sercomm.c **** 	sercomm_register_rx_cb(SC_DLCI_ECHO, &sercomm_sendmsg);
 537              		.loc 1 116 0
 538 0044 FEFFFFEA 		b	sercomm_register_rx_cb
 539              	.LVL26:
 540              	.L50:
 541              		.align	2
 542              	.L49:
 543 0048 00000000 		.word	.LANCHOR0
 544 004c 00000000 		.word	sercomm_sendmsg
 545              		.cfi_endproc
 546              	.LFE41:
 548              		.section	.text.sercomm_drv_rx_char,"ax",%progbits
 549              		.align	2
 550              		.global	sercomm_drv_rx_char
 552              	sercomm_drv_rx_char:
 553              	.LFB48:
 234:comm/sercomm.c **** 
 235:comm/sercomm.c **** /* dispatch an incoming message once it is completely received */
 236:comm/sercomm.c **** static void dispatch_rx_msg(uint8_t dlci, struct msgb *msg)
 237:comm/sercomm.c **** {
 238:comm/sercomm.c **** 	if (dlci >= ARRAY_SIZE(sercomm.rx.dlci_handler) ||
 239:comm/sercomm.c **** 	    !sercomm.rx.dlci_handler[dlci]) {
 240:comm/sercomm.c **** 		msgb_free(msg);
 241:comm/sercomm.c **** 		return;
 242:comm/sercomm.c **** 	}
 243:comm/sercomm.c **** 	sercomm.rx.dlci_handler[dlci](dlci, msg);
 244:comm/sercomm.c **** }
 245:comm/sercomm.c **** 
 246:comm/sercomm.c **** /* the driver has received one byte, pass it into sercomm layer */
 247:comm/sercomm.c **** int sercomm_drv_rx_char(uint8_t ch)
 248:comm/sercomm.c **** {
 554              		.loc 1 248 0
 555              		.cfi_startproc
 556              		@ args = 0, pretend = 0, frame = 0
 557              		@ frame_needed = 0, uses_anonymous_args = 0
 558              	.LVL27:
 559 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 560              	.LCFI3:
 561              		.cfi_def_cfa_offset 20
 249:comm/sercomm.c **** 	uint8_t *ptr;
 250:comm/sercomm.c **** 
 251:comm/sercomm.c **** 	/* we are always called from interrupt context in this function,
 252:comm/sercomm.c **** 	 * which means that any data structures we use need to be for
 253:comm/sercomm.c **** 	 * our exclusive access */
 254:comm/sercomm.c **** 	if (!sercomm.rx.msg)
 562              		.loc 1 254 0
 563 0004 94419FE5 		ldr	r4, .L72
 564              		.cfi_offset 14, -4
 565              		.cfi_offset 7, -8
 566              		.cfi_offset 6, -12
 567              		.cfi_offset 5, -16
 568              		.cfi_offset 4, -20
 569 0008 203694E5 		ldr	r3, [r4, #1568]
 570 000c 000053E3 		cmp	r3, #0
 248:comm/sercomm.c **** {
 571              		.loc 1 248 0
 572 0010 FF5000E2 		and	r5, r0, #255
 573              		.loc 1 254 0
 574 0014 0100001A 		bne	.L52
 255:comm/sercomm.c **** 		sercomm.rx.msg = sercomm_alloc_msgb(SERCOMM_RX_MSG_SIZE);
 575              		.loc 1 255 0
 576 0018 FEFFFFEB 		bl	sercomm_alloc_msgb.clone.2
 577              	.LVL28:
 578 001c 200684E5 		str	r0, [r4, #1568]
 579              	.L52:
 256:comm/sercomm.c **** 
 257:comm/sercomm.c **** 	if (msgb_tailroom(sercomm.rx.msg) == 0) {
 580              		.loc 1 257 0
 581 0020 78719FE5 		ldr	r7, .L72
 582 0024 204697E5 		ldr	r4, [r7, #1568]
 583              	.LVL29:
 584              	.LBB89:
 585              	.LBB90:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 586              		.loc 2 152 0
 587 0028 B433D4E1 		ldrh	r3, [r4, #52]
 588 002c 382084E2 		add	r2, r4, #56
 589 0030 440092E8 		ldmia	r2, {r2, r6}	@ phole ldm
 590 0034 032082E0 		add	r2, r2, r3
 591              	.LBE90:
 592              	.LBE89:
 593              		.loc 1 257 0
 594 0038 060052E1 		cmp	r2, r6
 595 003c 0600001A 		bne	.L53
 258:comm/sercomm.c **** 		//cons_puts("sercomm_drv_rx_char() overflow!\n");
 259:comm/sercomm.c **** 		msgb_free(sercomm.rx.msg);
 596              		.loc 1 259 0
 597 0040 0400A0E1 		mov	r0, r4
 598 0044 FEFFFFEB 		bl	msgb_free
 599              	.LVL30:
 260:comm/sercomm.c **** 		sercomm.rx.msg = sercomm_alloc_msgb(SERCOMM_RX_MSG_SIZE);
 600              		.loc 1 260 0
 601 0048 FEFFFFEB 		bl	sercomm_alloc_msgb.clone.2
 602 004c 200687E5 		str	r0, [r7, #1568]
 261:comm/sercomm.c **** 		sercomm.rx.state = RX_ST_WAIT_START;
 603              		.loc 1 261 0
 604 0050 0000A0E3 		mov	r0, #0
 605 0054 240687E5 		str	r0, [r7, #1572]
 262:comm/sercomm.c **** 		return 0;
 606              		.loc 1 262 0
 607 0058 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 608              	.L53:
 263:comm/sercomm.c **** 	}
 264:comm/sercomm.c **** 
 265:comm/sercomm.c **** 	switch (sercomm.rx.state) {
 609              		.loc 1 265 0
 610 005c 243697E5 		ldr	r3, [r7, #1572]
 611 0060 040053E3 		cmp	r3, #4
 612 0064 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 613 0068 480000EA 		b	.L68
 614              	.L60:
 615 006c 80000000 		.word	.L55
 616 0070 98000000 		.word	.L56
 617 0074 A8000000 		.word	.L57
 618 0078 B8000000 		.word	.L58
 619 007c 4C010000 		.word	.L59
 620              	.L55:
 266:comm/sercomm.c **** 	case RX_ST_WAIT_START:
 267:comm/sercomm.c **** 		if (ch != HDLC_FLAG)
 621              		.loc 1 267 0
 622 0080 7E0055E3 		cmp	r5, #126
 623 0084 4300001A 		bne	.L69
 268:comm/sercomm.c **** 			break;
 269:comm/sercomm.c **** 		sercomm.rx.state = RX_ST_ADDR;
 624              		.loc 1 269 0
 625 0088 10319FE5 		ldr	r3, .L72
 626 008c 0100A0E3 		mov	r0, #1
 627 0090 240683E5 		str	r0, [r3, #1572]
 270:comm/sercomm.c **** 		break;
 628              		.loc 1 270 0
 629 0094 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 630              	.L56:
 271:comm/sercomm.c **** 	case RX_ST_ADDR:
 272:comm/sercomm.c **** 		sercomm.rx.dlci = ch;
 631              		.loc 1 272 0
 632 0098 00319FE5 		ldr	r3, .L72
 273:comm/sercomm.c **** 		sercomm.rx.state = RX_ST_CTRL;
 633              		.loc 1 273 0
 634 009c 0220A0E3 		mov	r2, #2
 272:comm/sercomm.c **** 		sercomm.rx.dlci = ch;
 635              		.loc 1 272 0
 636 00a0 2856C3E5 		strb	r5, [r3, #1576]
 637 00a4 380000EA 		b	.L70
 638              	.L57:
 274:comm/sercomm.c **** 		break;
 275:comm/sercomm.c **** 	case RX_ST_CTRL:
 276:comm/sercomm.c **** 		sercomm.rx.ctrl = ch;
 639              		.loc 1 276 0
 640 00a8 F0309FE5 		ldr	r3, .L72
 277:comm/sercomm.c **** 		sercomm.rx.state = RX_ST_DATA;
 641              		.loc 1 277 0
 642 00ac 0320A0E3 		mov	r2, #3
 276:comm/sercomm.c **** 		sercomm.rx.ctrl = ch;
 643              		.loc 1 276 0
 644 00b0 2956C3E5 		strb	r5, [r3, #1577]
 645 00b4 340000EA 		b	.L70
 646              	.L58:
 278:comm/sercomm.c **** 		break;
 279:comm/sercomm.c **** 	case RX_ST_DATA:
 280:comm/sercomm.c **** 		if (ch == HDLC_ESCAPE) {
 647              		.loc 1 280 0
 648 00b8 7D0055E3 		cmp	r5, #125
 281:comm/sercomm.c **** 			/* drop the escape octet, but change state */
 282:comm/sercomm.c **** 			sercomm.rx.state = RX_ST_ESCAPE;
 649              		.loc 1 282 0
 650 00bc 0420A003 		moveq	r2, #4
 280:comm/sercomm.c **** 		if (ch == HDLC_ESCAPE) {
 651              		.loc 1 280 0
 652 00c0 3000000A 		beq	.L71
 283:comm/sercomm.c **** 			break;
 284:comm/sercomm.c **** 		} else if (ch == HDLC_FLAG) {
 653              		.loc 1 284 0
 654 00c4 7E0055E3 		cmp	r5, #126
 655 00c8 1100001A 		bne	.L62
 285:comm/sercomm.c **** 			/* message is finished */
 286:comm/sercomm.c **** 			dispatch_rx_msg(sercomm.rx.dlci, sercomm.rx.msg);
 656              		.loc 1 286 0
 657 00cc CC309FE5 		ldr	r3, .L72
 658 00d0 2806D3E5 		ldrb	r0, [r3, #1576]	@ zero_extendqisi2
 659              	.LVL31:
 660              	.LBB91:
 661              	.LBB92:
 238:comm/sercomm.c **** 	if (dlci >= ARRAY_SIZE(sercomm.rx.dlci_handler) ||
 662              		.loc 1 238 0
 663 00d4 800050E3 		cmp	r0, #128
 664 00d8 0300008A 		bhi	.L63
 239:comm/sercomm.c **** 	    !sercomm.rx.dlci_handler[dlci]) {
 665              		.loc 1 239 0
 666 00dc 003183E0 		add	r3, r3, r0, asl #2
 667 00e0 1C3493E5 		ldr	r3, [r3, #1052]
 238:comm/sercomm.c **** 	if (dlci >= ARRAY_SIZE(sercomm.rx.dlci_handler) ||
 668              		.loc 1 238 0
 669 00e4 000053E3 		cmp	r3, #0
 670 00e8 0200001A 		bne	.L64
 671              	.L63:
 240:comm/sercomm.c **** 		msgb_free(msg);
 672              		.loc 1 240 0
 673 00ec 0400A0E1 		mov	r0, r4
 674              	.LVL32:
 675 00f0 FEFFFFEB 		bl	msgb_free
 676 00f4 020000EA 		b	.L65
 677              	.LVL33:
 678              	.L64:
 243:comm/sercomm.c **** 	sercomm.rx.dlci_handler[dlci](dlci, msg);
 679              		.loc 1 243 0
 680 00f8 0410A0E1 		mov	r1, r4
 681 00fc 0FE0A0E1 		mov	lr, pc
 682 0100 13FF2FE1 		bx	r3
 683              	.LVL34:
 684              	.L65:
 685              	.LBE92:
 686              	.LBE91:
 287:comm/sercomm.c **** 			/* allocate new buffer */
 288:comm/sercomm.c **** 			sercomm.rx.msg = NULL;
 687              		.loc 1 288 0
 688 0104 94309FE5 		ldr	r3, .L72
 689 0108 0020A0E3 		mov	r2, #0
 690 010c 202683E5 		str	r2, [r3, #1568]
 691 0110 1D0000EA 		b	.L70
 692              	.LVL35:
 693              	.L62:
 694              	.LBB93:
 695              	.LBB94:
 696              	.LBB95:
 697              	.LBB96:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 698              		.loc 2 152 0
 699 0114 022066E0 		rsb	r2, r6, r2
 700              	.LBE96:
 701              	.LBE95:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 702              		.loc 2 182 0
 703 0118 000052E3 		cmp	r2, #0
 704              	.LVL36:
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 705              		.loc 2 183 0
 706 011c 80009FD5 		ldrle	r0, .L72+4
 707 0120 0410A0D1 		movle	r1, r4
 708 0124 0130A0D3 		movle	r3, #1
 709 0128 FEFFFFDB 		blle	osmo_panic
 710              	.LVL37:
 711              	.L66:
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 712              		.loc 2 185 0
 713 012c 3C3094E5 		ldr	r3, [r4, #60]
 714 0130 013083E2 		add	r3, r3, #1
 715 0134 3C3084E5 		str	r3, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 716              		.loc 2 186 0
 717 0138 B633D4E1 		ldrh	r3, [r4, #54]
 718 013c 013083E2 		add	r3, r3, #1
 719 0140 B633C4E1 		strh	r3, [r4, #54]	@ movhi
 720              	.LBE94:
 721              	.LBE93:
 289:comm/sercomm.c **** 			/* start all over again */
 290:comm/sercomm.c **** 			sercomm.rx.state = RX_ST_WAIT_START;
 291:comm/sercomm.c **** 
 292:comm/sercomm.c **** 			/* do not add the control char */
 293:comm/sercomm.c **** 			break;
 294:comm/sercomm.c **** 		}
 295:comm/sercomm.c **** 		/* default case: store the octet */
 296:comm/sercomm.c **** 		ptr = msgb_put(sercomm.rx.msg, 1);
 297:comm/sercomm.c **** 		*ptr = ch;
 722              		.loc 1 297 0
 723 0144 0050C6E5 		strb	r5, [r6, #0]
 724 0148 100000EA 		b	.L68
 725              	.LVL38:
 726              	.L59:
 727              	.LBB97:
 728              	.LBB98:
 729              	.LBB99:
 730              	.LBB100:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 731              		.loc 2 152 0
 732 014c 022066E0 		rsb	r2, r6, r2
 733              	.LBE100:
 734              	.LBE99:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 735              		.loc 2 182 0
 736 0150 000052E3 		cmp	r2, #0
 737              	.LBE98:
 738              	.LBE97:
 298:comm/sercomm.c **** 		break;
 299:comm/sercomm.c **** 	case RX_ST_ESCAPE:
 300:comm/sercomm.c **** 		/* store bif-5-inverted octet in buffer */
 301:comm/sercomm.c **** 		ch ^= (1 << 5);
 739              		.loc 1 301 0
 740 0154 205025E2 		eor	r5, r5, #32
 741              	.LVL39:
 742              	.LBB102:
 743              	.LBB101:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 744              		.loc 2 182 0
 745              	.LVL40:
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 746              		.loc 2 183 0
 747 0158 44009FD5 		ldrle	r0, .L72+4
 748 015c 0410A0D1 		movle	r1, r4
 749 0160 0130A0D3 		movle	r3, #1
 750 0164 FEFFFFDB 		blle	osmo_panic
 751              	.LVL41:
 752              	.L67:
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 753              		.loc 2 185 0
 754 0168 3C3094E5 		ldr	r3, [r4, #60]
 755 016c 013083E2 		add	r3, r3, #1
 756 0170 3C3084E5 		str	r3, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 757              		.loc 2 186 0
 758 0174 B633D4E1 		ldrh	r3, [r4, #54]
 759 0178 013083E2 		add	r3, r3, #1
 760 017c B633C4E1 		strh	r3, [r4, #54]	@ movhi
 761              	.LBE101:
 762              	.LBE102:
 302:comm/sercomm.c **** 		ptr = msgb_put(sercomm.rx.msg, 1);
 303:comm/sercomm.c **** 		*ptr = ch;
 763              		.loc 1 303 0
 764 0180 0050C6E5 		strb	r5, [r6, #0]
 304:comm/sercomm.c **** 		/* transition back to normal DATA state */
 305:comm/sercomm.c **** 		sercomm.rx.state = RX_ST_DATA;
 765              		.loc 1 305 0
 766 0184 0320A0E3 		mov	r2, #3
 767              	.LVL42:
 768              	.L71:
 769 0188 10309FE5 		ldr	r3, .L72
 770              	.L70:
 771 018c 242683E5 		str	r2, [r3, #1572]
 772              	.L68:
 306:comm/sercomm.c **** 		break;
 307:comm/sercomm.c **** 	}
 308:comm/sercomm.c **** 
 309:comm/sercomm.c **** 	return 1;
 773              		.loc 1 309 0
 774 0190 0100A0E3 		mov	r0, #1
 775 0194 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 776              	.L69:
 777 0198 0100A0E3 		mov	r0, #1
 310:comm/sercomm.c **** }
 778              		.loc 1 310 0
 779 019c F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 780              	.L73:
 781              		.align	2
 782              	.L72:
 783 01a0 00000000 		.word	.LANCHOR0
 784 01a4 3E000000 		.word	.LC2
 785              		.cfi_endproc
 786              	.LFE48:
 788              		.section	.rodata.str1.1,"aMS",%progbits,1
 789              	.LC0:
 790 0000 6D736762 		.ascii	"msgb(%p): Not enough headroom msgb_push (%u < %u)\012"
 790      28257029 
 790      3A204E6F 
 790      7420656E 
 790      6F756768 
 791 0032 00       		.ascii	"\000"
 792              	.LC1:
 793 0033 73657263 		.ascii	"sercomm_tx\000"
 793      6F6D6D5F 
 793      747800
 794              	.LC2:
 795 003e 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 795      28257029 
 795      3A204E6F 
 795      7420656E 
 795      6F756768 
 796 0070 00       		.ascii	"\000"
 797              		.bss
 798              		.align	2
 799              		.set	.LANCHOR0,. + 0
 802              	sercomm:
 803 0000 00000000 		.space	1580
 803      00000000 
 803      00000000 
 803      00000000 
 803      00000000 
 804              		.text
 805              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 sercomm.c
     /tmp/ccK2rthH.s:12     .text.sercomm_sendmsg:0000000000000000 $a
     /tmp/ccK2rthH.s:15     .text.sercomm_sendmsg:0000000000000000 sercomm_sendmsg
     /tmp/ccK2rthH.s:113    .text.sercomm_sendmsg:0000000000000084 $d
     /tmp/ccK2rthH.s:119    .text.sercomm_alloc_msgb.clone.2:0000000000000000 $a
     /tmp/ccK2rthH.s:121    .text.sercomm_alloc_msgb.clone.2:0000000000000000 sercomm_alloc_msgb.clone.2
     /tmp/ccK2rthH.s:163    .text.sercomm_alloc_msgb.clone.2:0000000000000034 $d
     /tmp/ccK2rthH.s:168    .text.sercomm_bind_uart:0000000000000000 $a
     /tmp/ccK2rthH.s:171    .text.sercomm_bind_uart:0000000000000000 sercomm_bind_uart
     /tmp/ccK2rthH.s:187    .text.sercomm_bind_uart:000000000000000c $d
     /tmp/ccK2rthH.s:192    .text.sercomm_get_uart:0000000000000000 $a
     /tmp/ccK2rthH.s:195    .text.sercomm_get_uart:0000000000000000 sercomm_get_uart
     /tmp/ccK2rthH.s:209    .text.sercomm_get_uart:000000000000000c $d
     /tmp/ccK2rthH.s:214    .text.sercomm_initialized:0000000000000000 $a
     /tmp/ccK2rthH.s:217    .text.sercomm_initialized:0000000000000000 sercomm_initialized
     /tmp/ccK2rthH.s:231    .text.sercomm_initialized:000000000000000c $d
     /tmp/ccK2rthH.s:236    .text.sercomm_tx_queue_depth:0000000000000000 $a
     /tmp/ccK2rthH.s:239    .text.sercomm_tx_queue_depth:0000000000000000 sercomm_tx_queue_depth
     /tmp/ccK2rthH.s:278    .text.sercomm_tx_queue_depth:0000000000000030 $d
     /tmp/ccK2rthH.s:283    .text.sercomm_drv_pull:0000000000000000 $a
     /tmp/ccK2rthH.s:286    .text.sercomm_drv_pull:0000000000000000 sercomm_drv_pull
     /tmp/ccK2rthH.s:450    .text.sercomm_drv_pull:0000000000000114 $d
     /tmp/ccK2rthH.s:456    .text.sercomm_register_rx_cb:0000000000000000 $a
     /tmp/ccK2rthH.s:459    .text.sercomm_register_rx_cb:0000000000000000 sercomm_register_rx_cb
     /tmp/ccK2rthH.s:491    .text.sercomm_register_rx_cb:0000000000000030 $d
     /tmp/ccK2rthH.s:496    .text.sercomm_init:0000000000000000 $a
     /tmp/ccK2rthH.s:499    .text.sercomm_init:0000000000000000 sercomm_init
     /tmp/ccK2rthH.s:543    .text.sercomm_init:0000000000000048 $d
     /tmp/ccK2rthH.s:549    .text.sercomm_drv_rx_char:0000000000000000 $a
     /tmp/ccK2rthH.s:552    .text.sercomm_drv_rx_char:0000000000000000 sercomm_drv_rx_char
     /tmp/ccK2rthH.s:615    .text.sercomm_drv_rx_char:000000000000006c $d
     /tmp/ccK2rthH.s:622    .text.sercomm_drv_rx_char:0000000000000080 $a
     /tmp/ccK2rthH.s:783    .text.sercomm_drv_rx_char:00000000000001a0 $d
     /tmp/ccK2rthH.s:798    .bss:0000000000000000 $d
     /tmp/ccK2rthH.s:802    .bss:0000000000000000 sercomm
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
osmo_panic
msgb_enqueue
uart_irq_enable
msgb_alloc
msgb_dequeue
msgb_free
