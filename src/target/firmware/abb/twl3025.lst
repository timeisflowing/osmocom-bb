   1              		.file	"twl3025.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.tpu_enq_at,"ax",%progbits
  12              		.align	2
  14              	tpu_enq_at:
  15              	.LFB3:
  16              		.file 1 "include/calypso/tpu.h"
   1:include/calypso/tpu.h **** #ifndef _CALYPSO_TPU_H
   2:include/calypso/tpu.h **** #define _CALYPSO_TPU_H
   3:include/calypso/tpu.h **** 
   4:include/calypso/tpu.h **** #define BITS_PER_TDMA		1250
   5:include/calypso/tpu.h **** #define QBITS_PER_TDMA		(BITS_PER_TDMA * 4)	/* 5000 */
   6:include/calypso/tpu.h **** #define TPU_RANGE		QBITS_PER_TDMA
   7:include/calypso/tpu.h **** #define	SWITCH_TIME		(TPU_RANGE-10)
   8:include/calypso/tpu.h **** 
   9:include/calypso/tpu.h **** /* Assert or de-assert TPU reset */
  10:include/calypso/tpu.h **** void tpu_reset(int active);
  11:include/calypso/tpu.h **** /* Enable or Disable a new scenario loaded into the TPU */
  12:include/calypso/tpu.h **** void tpu_enable(int active);
  13:include/calypso/tpu.h **** /* Enable or Disable the clock of the TPU Module */
  14:include/calypso/tpu.h **** void tpu_clk_enable(int active);
  15:include/calypso/tpu.h **** /* Enable Frame Interrupt generation on next frame.  DSP will reset it */
  16:include/calypso/tpu.h **** void tpu_dsp_frameirq_enable(void);
  17:include/calypso/tpu.h **** /* Is a Frame interrupt still pending for the DSP ? */
  18:include/calypso/tpu.h **** int tpu_dsp_fameirq_pending(void);
  19:include/calypso/tpu.h **** /* Rewind the TPU, i.e. restart enqueueing instructions at the base addr */
  20:include/calypso/tpu.h **** void tpu_rewind(void);
  21:include/calypso/tpu.h **** /* Enqueue a raw TPU instruction */
  22:include/calypso/tpu.h **** void tpu_enqueue(uint16_t instr);
  23:include/calypso/tpu.h **** /* Initialize TPU and TPU driver */
  24:include/calypso/tpu.h **** void tpu_init(void);
  25:include/calypso/tpu.h **** /* (Busy)Wait until TPU is idle */
  26:include/calypso/tpu.h **** void tpu_wait_idle(void);
  27:include/calypso/tpu.h **** /* Enable FRAME interrupt generation */
  28:include/calypso/tpu.h **** void tpu_frame_irq_en(int mcu, int dsp);
  29:include/calypso/tpu.h **** /* Force the generation of a DSP interrupt */
  30:include/calypso/tpu.h **** void tpu_force_dsp_frame_irq(void);
  31:include/calypso/tpu.h **** 
  32:include/calypso/tpu.h **** /* Get the current TPU SYNCHRO register */
  33:include/calypso/tpu.h **** uint16_t tpu_get_synchro(void);
  34:include/calypso/tpu.h **** /* Get the current TPU OFFSET register */
  35:include/calypso/tpu.h **** uint16_t tpu_get_offset(void);
  36:include/calypso/tpu.h **** 
  37:include/calypso/tpu.h **** enum tpu_instr {
  38:include/calypso/tpu.h **** 	TPU_INSTR_AT		= (1 << 13),
  39:include/calypso/tpu.h **** 	TPU_INSTR_OFFSET	= (2 << 13),
  40:include/calypso/tpu.h **** 	TPU_INSTR_SYNCHRO	= (3 << 13),	/* Loading delta synchro value in TPU synchro register */
  41:include/calypso/tpu.h **** 	TPU_INSTR_WAIT		= (5 << 13),	/* Wait a certain period (in GSM qbits) */
  42:include/calypso/tpu.h **** 	TPU_INSTR_SLEEP		= (0 << 13),	/* Stop the sequencer by disabling TPU ENABLE bit in ctrl reg */
  43:include/calypso/tpu.h **** 	/* data processing */
  44:include/calypso/tpu.h **** 	TPU_INSTR_MOVE		= (4 << 13),
  45:include/calypso/tpu.h **** };
  46:include/calypso/tpu.h **** 
  47:include/calypso/tpu.h **** /* Addresses internal to the TPU, only accessible via MOVE */
  48:include/calypso/tpu.h **** enum tpu_reg_int {
  49:include/calypso/tpu.h **** 	TPUI_TSP_CTRL1	= 0x00,
  50:include/calypso/tpu.h **** 	TPUI_TSP_CTRL2	= 0x01,
  51:include/calypso/tpu.h **** 	TPUI_TX_1	= 0x04,
  52:include/calypso/tpu.h **** 	TPUI_TX_2	= 0x03,
  53:include/calypso/tpu.h **** 	TPUI_TX_3	= 0x02,
  54:include/calypso/tpu.h **** 	TPUI_TX_4	= 0x05,
  55:include/calypso/tpu.h **** 	TPUI_TSP_ACT_L	= 0x06,
  56:include/calypso/tpu.h **** 	TPUI_TSP_ACT_U	= 0x07,
  57:include/calypso/tpu.h **** 	TPUI_TSP_SET1	= 0x09,
  58:include/calypso/tpu.h **** 	TPUI_TSP_SET2	= 0x0a,
  59:include/calypso/tpu.h **** 	TPUI_TSP_SET3	= 0x0b,
  60:include/calypso/tpu.h **** 	TPUI_DSP_INT_PG	= 0x10,
  61:include/calypso/tpu.h **** 	TPUI_GAUGING_EN = 0x11,
  62:include/calypso/tpu.h **** };
  63:include/calypso/tpu.h **** 
  64:include/calypso/tpu.h **** enum tpui_ctrl2_bits {
  65:include/calypso/tpu.h **** 	TPUI_CTRL2_RD		= (1 << 0),
  66:include/calypso/tpu.h **** 	TPUI_CTRL2_WR		= (1 << 1),
  67:include/calypso/tpu.h **** };
  68:include/calypso/tpu.h **** 
  69:include/calypso/tpu.h **** static inline uint16_t tpu_mod5000(int16_t time)
  70:include/calypso/tpu.h **** {
  71:include/calypso/tpu.h **** 	if (time < 0)
  72:include/calypso/tpu.h **** 		return time + 5000;
  73:include/calypso/tpu.h **** 	if (time >= 5000)
  74:include/calypso/tpu.h **** 		return time - 5000;
  75:include/calypso/tpu.h **** 	return time;
  76:include/calypso/tpu.h **** }
  77:include/calypso/tpu.h **** 
  78:include/calypso/tpu.h **** /* Enqueue a SLEEP operation (stop sequencer by disabling TPU ENABLE bit) */
  79:include/calypso/tpu.h **** static inline void tpu_enq_sleep(void)
  80:include/calypso/tpu.h **** {
  81:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SLEEP);
  82:include/calypso/tpu.h **** }
  83:include/calypso/tpu.h **** 
  84:include/calypso/tpu.h **** /* Enqueue a MOVE operation */
  85:include/calypso/tpu.h **** static inline void tpu_enq_move(uint8_t addr, uint8_t data)
  86:include/calypso/tpu.h **** {
  87:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_MOVE | (data << 5) | (addr & 0x1f));
  88:include/calypso/tpu.h **** }
  89:include/calypso/tpu.h **** 
  90:include/calypso/tpu.h **** /* Enqueue an AT operation */
  91:include/calypso/tpu.h **** static inline void tpu_enq_at(int16_t time)
  92:include/calypso/tpu.h **** {
  17              		.loc 1 92 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              		@ link register save eliminated.
  22              	.LVL0:
  23              	.LBB8:
  24              	.LBB9:
  71:include/calypso/tpu.h **** 	if (time < 0)
  25              		.loc 1 71 0
  26 0000 000050E3 		cmp	r0, #0
  27              	.LVL1:
  72:include/calypso/tpu.h **** 		return time + 5000;
  28              		.loc 1 72 0
  29 0004 4E0D80B2 		addlt	r0, r0, #4992
  30 0008 080080B2 		addlt	r0, r0, #8
  71:include/calypso/tpu.h **** 	if (time < 0)
  31              		.loc 1 71 0
  32 000c 030000BA 		blt	.L4
  73:include/calypso/tpu.h **** 	if (time >= 5000)
  33              		.loc 1 73 0
  34 0010 18309FE5 		ldr	r3, .L5
  35 0014 030050E1 		cmp	r0, r3
  74:include/calypso/tpu.h **** 		return time - 5000;
  36              		.loc 1 74 0
  37 0018 4E0D40C2 		subgt	r0, r0, #4992
  38 001c 080040C2 		subgt	r0, r0, #8
  39              	.L4:
  75:include/calypso/tpu.h **** 	return time;
  40              		.loc 1 75 0
  41 0020 0008A0E1 		mov	r0, r0, asl #16
  42 0024 2008A0E1 		mov	r0, r0, lsr #16
  43              	.LBE9:
  44              	.LBE8:
  93:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_AT | tpu_mod5000(time));
  45              		.loc 1 93 0
  46 0028 020A80E3 		orr	r0, r0, #8192
  94:include/calypso/tpu.h **** }
  47              		.loc 1 94 0
  93:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_AT | tpu_mod5000(time));
  48              		.loc 1 93 0
  49 002c FEFFFFEA 		b	tpu_enqueue
  50              	.L6:
  51              		.align	2
  52              	.L5:
  53 0030 87130000 		.word	4999
  54              		.cfi_endproc
  55              	.LFE3:
  57              		.section	.text.tpu_enq_wait,"ax",%progbits
  58              		.align	2
  60              	tpu_enq_wait:
  61              	.LFB5:
  95:include/calypso/tpu.h **** 
  96:include/calypso/tpu.h **** /* Enqueue a SYNC operation */
  97:include/calypso/tpu.h **** static inline void tpu_enq_sync(int16_t time)
  98:include/calypso/tpu.h **** {
  99:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SYNCHRO | time);
 100:include/calypso/tpu.h **** }
 101:include/calypso/tpu.h **** 
 102:include/calypso/tpu.h **** /* Enqueue a WAIT operation */
 103:include/calypso/tpu.h **** static inline void tpu_enq_wait(int16_t time)
 104:include/calypso/tpu.h **** {
  62              		.loc 1 104 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 0
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67              	.LVL2:
 105:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_WAIT | time);
  68              		.loc 1 105 0
  69 0000 08309FE5 		ldr	r3, .L8
  70 0004 033000E0 		and	r3, r0, r3
  71 0008 0A0A83E3 		orr	r0, r3, #40960
  72              	.LVL3:
 106:include/calypso/tpu.h **** }
  73              		.loc 1 106 0
 105:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_WAIT | time);
  74              		.loc 1 105 0
  75 000c FEFFFFEA 		b	tpu_enqueue
  76              	.L9:
  77              		.align	2
  78              	.L8:
  79 0010 FF5F0000 		.word	24575
  80              		.cfi_endproc
  81              	.LFE5:
  83              		.section	.text.twl3025_wait_ibic_access,"ax",%progbits
  84              		.align	2
  86              	twl3025_wait_ibic_access:
  87              	.LFB16:
  88              		.file 2 "abb/twl3025.c"
   1:abb/twl3025.c **** /* Driver for Analog Baseband Circuit (TWL3025) */
   2:abb/twl3025.c **** 
   3:abb/twl3025.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:abb/twl3025.c ****  *
   5:abb/twl3025.c ****  * All Rights Reserved
   6:abb/twl3025.c ****  *
   7:abb/twl3025.c ****  * This program is free software; you can redistribute it and/or modify
   8:abb/twl3025.c ****  * it under the terms of the GNU General Public License as published by
   9:abb/twl3025.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:abb/twl3025.c ****  * (at your option) any later version.
  11:abb/twl3025.c ****  *
  12:abb/twl3025.c ****  * This program is distributed in the hope that it will be useful,
  13:abb/twl3025.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:abb/twl3025.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:abb/twl3025.c ****  * GNU General Public License for more details.
  16:abb/twl3025.c ****  *
  17:abb/twl3025.c ****  * You should have received a copy of the GNU General Public License along
  18:abb/twl3025.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:abb/twl3025.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:abb/twl3025.c ****  *
  21:abb/twl3025.c ****  */
  22:abb/twl3025.c **** 
  23:abb/twl3025.c **** #include <stdint.h>
  24:abb/twl3025.c **** #include <stdio.h>
  25:abb/twl3025.c **** 
  26:abb/twl3025.c **** #include <debug.h>
  27:abb/twl3025.c **** #include <delay.h>
  28:abb/twl3025.c **** #include <memory.h>
  29:abb/twl3025.c **** #include <spi.h>
  30:abb/twl3025.c **** #include <calypso/irq.h>
  31:abb/twl3025.c **** #include <calypso/tsp.h>
  32:abb/twl3025.c **** #include <calypso/tpu.h>
  33:abb/twl3025.c **** #include <abb/twl3025.h>
  34:abb/twl3025.c **** #include <asm/system.h>
  35:abb/twl3025.c **** 
  36:abb/twl3025.c **** /* TWL3025 */
  37:abb/twl3025.c **** #define REG_PAGE(n)	(n >> 7)
  38:abb/twl3025.c **** #define REG_ADDR(n)	(n & 0x3f)
  39:abb/twl3025.c **** 
  40:abb/twl3025.c **** #define TWL3025_DEV_IDX		0	/* On the SPI bus */
  41:abb/twl3025.c **** #define TWL3025_TSP_DEV_IDX	0	/* On the TSP bus */
  42:abb/twl3025.c **** 
  43:abb/twl3025.c **** /* values encountered on a GTA-02 for GSM900 (the same for GSM1800!?) */
  44:abb/twl3025.c **** const uint16_t twl3025_default_ramp[16] = {
  45:abb/twl3025.c **** 	ABB_RAMP_VAL( 0,  0),
  46:abb/twl3025.c **** 	ABB_RAMP_VAL( 0, 11),
  47:abb/twl3025.c **** 	ABB_RAMP_VAL( 0, 31),
  48:abb/twl3025.c **** 	ABB_RAMP_VAL( 0, 31),
  49:abb/twl3025.c **** 	ABB_RAMP_VAL( 0, 31),
  50:abb/twl3025.c **** 	ABB_RAMP_VAL( 0, 24),
  51:abb/twl3025.c **** 	ABB_RAMP_VAL( 0,  0),
  52:abb/twl3025.c **** 	ABB_RAMP_VAL( 0,  0),
  53:abb/twl3025.c **** 	ABB_RAMP_VAL( 9,  0),
  54:abb/twl3025.c **** 	ABB_RAMP_VAL(18,  0),
  55:abb/twl3025.c **** 	ABB_RAMP_VAL(25,  0),
  56:abb/twl3025.c **** 	ABB_RAMP_VAL(31,  0),
  57:abb/twl3025.c **** 	ABB_RAMP_VAL(30,  0),
  58:abb/twl3025.c **** 	ABB_RAMP_VAL(15,  0),
  59:abb/twl3025.c **** 	ABB_RAMP_VAL( 0,  0),
  60:abb/twl3025.c **** 	ABB_RAMP_VAL( 0,  0),
  61:abb/twl3025.c **** };
  62:abb/twl3025.c **** 
  63:abb/twl3025.c **** struct twl3025 {
  64:abb/twl3025.c **** 	uint8_t page;
  65:abb/twl3025.c **** };
  66:abb/twl3025.c **** static struct twl3025 twl3025_state;
  67:abb/twl3025.c **** 
  68:abb/twl3025.c **** /* Switch the register page of the TWL3025 */
  69:abb/twl3025.c **** static void twl3025_switch_page(uint8_t page)
  70:abb/twl3025.c **** {
  71:abb/twl3025.c **** 	if (page == 0)
  72:abb/twl3025.c **** 		twl3025_reg_write(PAGEREG, 1 << 0);
  73:abb/twl3025.c **** 	else
  74:abb/twl3025.c **** 		twl3025_reg_write(PAGEREG, 1 << 1);
  75:abb/twl3025.c **** 
  76:abb/twl3025.c **** 	twl3025_state.page = page;
  77:abb/twl3025.c **** }
  78:abb/twl3025.c **** 
  79:abb/twl3025.c **** static void handle_charger(void)
  80:abb/twl3025.c **** {
  81:abb/twl3025.c **** 	uint16_t status;
  82:abb/twl3025.c **** 	printd("handle_charger();");
  83:abb/twl3025.c **** 
  84:abb/twl3025.c **** 	status = twl3025_reg_read(VRPCSTS);
  85:abb/twl3025.c **** //	printd("\nvrpcsts: 0x%02x", status);
  86:abb/twl3025.c **** 
  87:abb/twl3025.c **** 	if (status & 0x40) {
  88:abb/twl3025.c **** 		printd(" inserted\n");
  89:abb/twl3025.c **** 	} else {
  90:abb/twl3025.c **** 		printd(" removed\n");
  91:abb/twl3025.c **** 	}
  92:abb/twl3025.c **** 
  93:abb/twl3025.c **** //	twl3025_dump_madc();
  94:abb/twl3025.c **** }
  95:abb/twl3025.c **** 
  96:abb/twl3025.c **** static void handle_adc_done(void)
  97:abb/twl3025.c **** {
  98:abb/twl3025.c **** 	printd("handle_adc_done();");
  99:abb/twl3025.c **** }
 100:abb/twl3025.c **** 
 101:abb/twl3025.c **** static void twl3025_irq(enum irq_nr nr)
 102:abb/twl3025.c **** {
 103:abb/twl3025.c **** 	uint16_t src;
 104:abb/twl3025.c **** 	printd("twl3025_irq: 0x%02x\n",nr);
 105:abb/twl3025.c **** 	switch (nr){
 106:abb/twl3025.c **** 	case IRQ_EXTERNAL: // charger in/out, pwrbtn, adc done
 107:abb/twl3025.c **** 		src = twl3025_reg_read(ITSTATREG);
 108:abb/twl3025.c **** //		printd("itstatreg 0x%02x\n", src);
 109:abb/twl3025.c **** 		if (src & 0x08)
 110:abb/twl3025.c **** 			handle_charger();
 111:abb/twl3025.c **** 		if (src & 0x20)
 112:abb/twl3025.c **** 			handle_adc_done();
 113:abb/twl3025.c **** 		break;
 114:abb/twl3025.c **** 	case IRQ_EXTERNAL_FIQ: // vcc <2.8V emergency power off
 115:abb/twl3025.c **** 		puts("\nBROWNOUT!1!");
 116:abb/twl3025.c **** 		twl3025_power_off();
 117:abb/twl3025.c **** 		break;
 118:abb/twl3025.c **** 	default:
 119:abb/twl3025.c **** 		return;
 120:abb/twl3025.c **** 	}
 121:abb/twl3025.c **** }
 122:abb/twl3025.c **** 
 123:abb/twl3025.c **** void twl3025_init(void)
 124:abb/twl3025.c **** {
 125:abb/twl3025.c **** 	spi_init();
 126:abb/twl3025.c **** 	twl3025_switch_page(0);
 127:abb/twl3025.c **** 	twl3025_clk13m(1);
 128:abb/twl3025.c **** 	twl3025_reg_write(AFCCTLADD, 0x01);	/* AFCCK(1:0) must not be zero! */
 129:abb/twl3025.c **** 	twl3025_unit_enable(TWL3025_UNIT_AFC, 1);
 130:abb/twl3025.c **** 
 131:abb/twl3025.c **** 	irq_register_handler(IRQ_EXTERNAL, &twl3025_irq);
 132:abb/twl3025.c **** 	irq_config(IRQ_EXTERNAL, 0, 0, 0);
 133:abb/twl3025.c **** 	irq_enable(IRQ_EXTERNAL);
 134:abb/twl3025.c **** 
 135:abb/twl3025.c **** 	irq_register_handler(IRQ_EXTERNAL_FIQ, &twl3025_irq);
 136:abb/twl3025.c **** 	irq_config(IRQ_EXTERNAL_FIQ, 1, 0, 0);
 137:abb/twl3025.c **** 	irq_enable(IRQ_EXTERNAL_FIQ);
 138:abb/twl3025.c **** }
 139:abb/twl3025.c **** 
 140:abb/twl3025.c **** void twl3025_reg_write(uint8_t reg, uint16_t data)
 141:abb/twl3025.c **** {
 142:abb/twl3025.c **** 	uint16_t tx;
 143:abb/twl3025.c **** 
 144:abb/twl3025.c **** 	printd("tw3025_reg_write(%u,%u)=0x%04x\n", REG_PAGE(reg),
 145:abb/twl3025.c **** 		REG_ADDR(reg), data);
 146:abb/twl3025.c **** 
 147:abb/twl3025.c **** 	if (reg != PAGEREG && REG_PAGE(reg) != twl3025_state.page)
 148:abb/twl3025.c **** 		twl3025_switch_page(REG_PAGE(reg));
 149:abb/twl3025.c **** 
 150:abb/twl3025.c **** 	tx = ((data & 0x3ff) << 6) | (REG_ADDR(reg) << 1);
 151:abb/twl3025.c **** 
 152:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, NULL);
 153:abb/twl3025.c **** }
 154:abb/twl3025.c **** 
 155:abb/twl3025.c **** void twl3025_tsp_write(uint8_t data)
 156:abb/twl3025.c **** {
 157:abb/twl3025.c **** 	tsp_write(TWL3025_TSP_DEV_IDX, 7, data);
 158:abb/twl3025.c **** }
 159:abb/twl3025.c **** 
 160:abb/twl3025.c **** uint16_t twl3025_reg_read(uint8_t reg)
 161:abb/twl3025.c **** {
 162:abb/twl3025.c **** 	uint16_t tx, rx;
 163:abb/twl3025.c **** 
 164:abb/twl3025.c **** 	if (REG_PAGE(reg) != twl3025_state.page)
 165:abb/twl3025.c **** 		twl3025_switch_page(REG_PAGE(reg));
 166:abb/twl3025.c **** 
 167:abb/twl3025.c **** 	tx = (REG_ADDR(reg) << 1) | 1;
 168:abb/twl3025.c **** 
 169:abb/twl3025.c **** 	/* A read cycle contains two SPI transfers */
 170:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, &rx);
 171:abb/twl3025.c **** 	delay_ms(1);
 172:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, &rx);
 173:abb/twl3025.c **** 
 174:abb/twl3025.c **** 	rx >>= 6;
 175:abb/twl3025.c **** 
 176:abb/twl3025.c **** 	printd("tw3025_reg_read(%u,%u)=0x%04x\n", REG_PAGE(reg),
 177:abb/twl3025.c **** 		REG_ADDR(reg), rx);
 178:abb/twl3025.c **** 
 179:abb/twl3025.c **** 	return rx;
 180:abb/twl3025.c **** }
 181:abb/twl3025.c **** 
 182:abb/twl3025.c **** static void twl3025_wait_ibic_access(void)
 183:abb/twl3025.c **** {
  89              		.loc 2 183 0
  90              		.cfi_startproc
  91              		@ args = 0, pretend = 0, frame = 0
  92              		@ frame_needed = 0, uses_anonymous_args = 0
  93              		@ link register save eliminated.
 184:abb/twl3025.c **** 	/* Wait 6 * 32kHz clock cycles for first IBIC access (187us + 10% = 210us) */
 185:abb/twl3025.c **** 	delay_ms(1);
  94              		.loc 2 185 0
  95 0000 0100A0E3 		mov	r0, #1
 186:abb/twl3025.c **** }
  96              		.loc 2 186 0
 185:abb/twl3025.c **** 	delay_ms(1);
  97              		.loc 2 185 0
  98 0004 FEFFFFEA 		b	delay_ms
  99              		.cfi_endproc
 100              	.LFE16:
 102              		.section	.text.twl3025_reg_write,"ax",%progbits
 103              		.align	2
 104              		.global	twl3025_reg_write
 106              	twl3025_reg_write:
 107              	.LFB13:
 141:abb/twl3025.c **** {
 108              		.loc 2 141 0
 109              		.cfi_startproc
 110              		@ args = 0, pretend = 0, frame = 4
 111              		@ frame_needed = 0, uses_anonymous_args = 0
 112              	.LVL4:
 113 0000 31402DE9 		stmfd	sp!, {r0, r4, r5, lr}
 114              	.LCFI0:
 115              		.cfi_def_cfa_offset 16
 141:abb/twl3025.c **** {
 116              		.loc 2 141 0
 117 0004 FF4000E2 		and	r4, r0, #255
 118              		.cfi_offset 14, -4
 119              		.cfi_offset 5, -8
 120              		.cfi_offset 4, -12
 121              		.cfi_offset 0, -16
 122 0008 0118A0E1 		mov	r1, r1, asl #16
 123              	.LVL5:
 147:abb/twl3025.c **** 	if (reg != PAGEREG && REG_PAGE(reg) != twl3025_state.page)
 124              		.loc 2 147 0
 125 000c 010054E3 		cmp	r4, #1
 141:abb/twl3025.c **** {
 126              		.loc 2 141 0
 127 0010 2158A0E1 		mov	r5, r1, lsr #16
 147:abb/twl3025.c **** 	if (reg != PAGEREG && REG_PAGE(reg) != twl3025_state.page)
 128              		.loc 2 147 0
 129 0014 0400000A 		beq	.L12
 147:abb/twl3025.c **** 	if (reg != PAGEREG && REG_PAGE(reg) != twl3025_state.page)
 130              		.loc 2 147 0 is_stmt 0 discriminator 1
 131 0018 34309FE5 		ldr	r3, .L13
 132 001c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 133 0020 A403A0E1 		mov	r0, r4, lsr #7
 134              	.LVL6:
 135 0024 000053E1 		cmp	r3, r0
 148:abb/twl3025.c **** 		twl3025_switch_page(REG_PAGE(reg));
 136              		.loc 2 148 0 is_stmt 1
 137 0028 FEFFFF1B 		blne	twl3025_switch_page
 138              	.L12:
 150:abb/twl3025.c **** 	tx = ((data & 0x3ff) << 6) | (REG_ADDR(reg) << 1);
 139              		.loc 2 150 0
 140 002c 0553A0E1 		mov	r5, r5, asl #6
 141 0030 3F4004E2 		and	r4, r4, #63
 142 0034 844085E1 		orr	r4, r5, r4, asl #1
 143 0038 04208DE2 		add	r2, sp, #4
 152:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, NULL);
 144              		.loc 2 152 0
 145 003c 0000A0E3 		mov	r0, #0
 150:abb/twl3025.c **** 	tx = ((data & 0x3ff) << 6) | (REG_ADDR(reg) << 1);
 146              		.loc 2 150 0
 147 0040 B24062E1 		strh	r4, [r2, #-2]!	@ movhi
 148              	.LVL7:
 152:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, NULL);
 149              		.loc 2 152 0
 150 0044 1010A0E3 		mov	r1, #16
 151 0048 0030A0E1 		mov	r3, r0
 152 004c FEFFFFEB 		bl	spi_xfer
 153:abb/twl3025.c **** }
 153              		.loc 2 153 0
 154 0050 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 155              	.L14:
 156              		.align	2
 157              	.L13:
 158 0054 00000000 		.word	.LANCHOR0
 159              		.cfi_endproc
 160              	.LFE13:
 162              		.section	.text.twl3025_switch_page,"ax",%progbits
 163              		.align	2
 165              	twl3025_switch_page:
 166              	.LFB8:
  70:abb/twl3025.c **** {
 167              		.loc 2 70 0
 168              		.cfi_startproc
 169              		@ args = 0, pretend = 0, frame = 0
 170              		@ frame_needed = 0, uses_anonymous_args = 0
 171              	.LVL8:
 172 0000 10402DE9 		stmfd	sp!, {r4, lr}
 173              	.LCFI1:
 174              		.cfi_def_cfa_offset 8
  71:abb/twl3025.c **** 	if (page == 0)
 175              		.loc 2 71 0
 176 0004 004050E2 		subs	r4, r0, #0
 177              		.cfi_offset 14, -4
 178              		.cfi_offset 4, -8
  72:abb/twl3025.c **** 		twl3025_reg_write(PAGEREG, 1 << 0);
 179              		.loc 2 72 0
 180 0008 01008002 		addeq	r0, r0, #1
 181              	.LVL9:
 182 000c 0010A001 		moveq	r1, r0
  74:abb/twl3025.c **** 		twl3025_reg_write(PAGEREG, 1 << 1);
 183              		.loc 2 74 0
 184 0010 0100A013 		movne	r0, #1
 185 0014 0210A013 		movne	r1, #2
 186 0018 FEFFFFEB 		bl	twl3025_reg_write
  76:abb/twl3025.c **** 	twl3025_state.page = page;
 187              		.loc 2 76 0
 188 001c 04309FE5 		ldr	r3, .L19
 189 0020 0040C3E5 		strb	r4, [r3, #0]
  77:abb/twl3025.c **** }
 190              		.loc 2 77 0
 191 0024 1080BDE8 		ldmfd	sp!, {r4, pc}
 192              	.L20:
 193              		.align	2
 194              	.L19:
 195 0028 00000000 		.word	.LANCHOR0
 196              		.cfi_endproc
 197              	.LFE8:
 199              		.section	.text.twl3025_tsp_write,"ax",%progbits
 200              		.align	2
 201              		.global	twl3025_tsp_write
 203              	twl3025_tsp_write:
 204              	.LFB14:
 156:abb/twl3025.c **** {
 205              		.loc 2 156 0
 206              		.cfi_startproc
 207              		@ args = 0, pretend = 0, frame = 0
 208              		@ frame_needed = 0, uses_anonymous_args = 0
 209              		@ link register save eliminated.
 210              	.LVL10:
 156:abb/twl3025.c **** {
 211              		.loc 2 156 0
 212 0000 FF2000E2 		and	r2, r0, #255
 157:abb/twl3025.c **** 	tsp_write(TWL3025_TSP_DEV_IDX, 7, data);
 213              		.loc 2 157 0
 214 0004 0710A0E3 		mov	r1, #7
 215 0008 0000A0E3 		mov	r0, #0
 216              	.LVL11:
 158:abb/twl3025.c **** }
 217              		.loc 2 158 0
 157:abb/twl3025.c **** 	tsp_write(TWL3025_TSP_DEV_IDX, 7, data);
 218              		.loc 2 157 0
 219 000c FEFFFFEA 		b	tsp_write
 220              		.cfi_endproc
 221              	.LFE14:
 223              		.section	.text.twl3025_reg_read,"ax",%progbits
 224              		.align	2
 225              		.global	twl3025_reg_read
 227              	twl3025_reg_read:
 228              	.LFB15:
 161:abb/twl3025.c **** {
 229              		.loc 2 161 0
 230              		.cfi_startproc
 231              		@ args = 0, pretend = 0, frame = 4
 232              		@ frame_needed = 0, uses_anonymous_args = 0
 233              	.LVL12:
 234 0000 31402DE9 		stmfd	sp!, {r0, r4, r5, lr}
 235              	.LCFI2:
 236              		.cfi_def_cfa_offset 16
 164:abb/twl3025.c **** 	if (REG_PAGE(reg) != twl3025_state.page)
 237              		.loc 2 164 0
 238 0004 64309FE5 		ldr	r3, .L24
 161:abb/twl3025.c **** {
 239              		.loc 2 161 0
 240 0008 FF4000E2 		and	r4, r0, #255
 241              		.cfi_offset 14, -4
 242              		.cfi_offset 5, -8
 243              		.cfi_offset 4, -12
 244              		.cfi_offset 0, -16
 164:abb/twl3025.c **** 	if (REG_PAGE(reg) != twl3025_state.page)
 245              		.loc 2 164 0
 246 000c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 247 0010 A403A0E1 		mov	r0, r4, lsr #7
 248              	.LVL13:
 249 0014 000053E1 		cmp	r3, r0
 165:abb/twl3025.c **** 		twl3025_switch_page(REG_PAGE(reg));
 250              		.loc 2 165 0
 251 0018 FEFFFF1B 		blne	twl3025_switch_page
 252              	.L23:
 167:abb/twl3025.c **** 	tx = (REG_ADDR(reg) << 1) | 1;
 253              		.loc 2 167 0
 254 001c 3F3004E2 		and	r3, r4, #63
 255 0020 8330A0E1 		mov	r3, r3, asl #1
 256 0024 04408DE2 		add	r4, sp, #4
 257 0028 013083E3 		orr	r3, r3, #1
 258 002c B23064E1 		strh	r3, [r4, #-2]!	@ movhi
 259              	.LVL14:
 170:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, &rx);
 260              		.loc 2 170 0
 261 0030 1010A0E3 		mov	r1, #16
 262 0034 0420A0E1 		mov	r2, r4
 263 0038 0D30A0E1 		mov	r3, sp
 264 003c 0000A0E3 		mov	r0, #0
 265 0040 FEFFFFEB 		bl	spi_xfer
 171:abb/twl3025.c **** 	delay_ms(1);
 266              		.loc 2 171 0
 267 0044 0100A0E3 		mov	r0, #1
 268 0048 FEFFFFEB 		bl	delay_ms
 172:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, &rx);
 269              		.loc 2 172 0
 270 004c 1010A0E3 		mov	r1, #16
 271 0050 0420A0E1 		mov	r2, r4
 272 0054 0D30A0E1 		mov	r3, sp
 273 0058 0000A0E3 		mov	r0, #0
 274 005c FEFFFFEB 		bl	spi_xfer
 275              	.LVL15:
 174:abb/twl3025.c **** 	rx >>= 6;
 276              		.loc 2 174 0
 277 0060 B000DDE1 		ldrh	r0, [sp, #0]
 278              	.LVL16:
 170:abb/twl3025.c **** 	spi_xfer(TWL3025_DEV_IDX, 16, &tx, &rx);
 279              		.loc 2 170 0
 280 0064 0D50A0E1 		mov	r5, sp
 180:abb/twl3025.c **** }
 281              		.loc 2 180 0
 282 0068 2003A0E1 		mov	r0, r0, lsr #6
 283              	.LVL17:
 284 006c 3880BDE8 		ldmfd	sp!, {r3, r4, r5, pc}
 285              	.L25:
 286              		.align	2
 287              	.L24:
 288 0070 00000000 		.word	.LANCHOR0
 289              		.cfi_endproc
 290              	.LFE15:
 292              		.section	.text.twl3025_power_off,"ax",%progbits
 293              		.align	2
 294              		.global	twl3025_power_off
 296              	twl3025_power_off:
 297              	.LFB17:
 187:abb/twl3025.c **** 
 188:abb/twl3025.c **** void twl3025_power_off(void)
 189:abb/twl3025.c **** {
 298              		.loc 2 189 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302 0000 04E02DE5 		str	lr, [sp, #-4]!
 303              	.LCFI3:
 304              		.cfi_def_cfa_offset 4
 305              	.LBB10:
 190:abb/twl3025.c **** 	unsigned long flags;
 191:abb/twl3025.c **** 
 192:abb/twl3025.c **** 	/* turn off all IRQs, since received frames cannot be
 193:abb/twl3025.c **** 	 * handled form here. (otherwise the message allocation
 194:abb/twl3025.c **** 	 * runs out of memory) */
 195:abb/twl3025.c **** 	local_firq_save(flags);
 306              		.loc 2 195 0
 307              	@ 195 "abb/twl3025.c" 1
 308 0004 00300FE1 		mrs	r3, cpsr		@ local_firq_save
 309 0008 C02083E3 		orr	r2, r3, #0xC0
 310 000c 02F021E1 		msr	cpsr_c, r2
 311              	@ 0 "" 2
 312              	.L27:
 313              	.LBE10:
 196:abb/twl3025.c **** 
 197:abb/twl3025.c **** 	/* poll PWON status and power off the phone when the
 198:abb/twl3025.c **** 	 * powerbutton has been released (otherwise it will
 199:abb/twl3025.c **** 	 * poweron immediately again) */
 200:abb/twl3025.c **** 	while (!(twl3025_reg_read(VRPCSTS) & 0x10)) { };
 314              		.loc 2 200 0 discriminator 1
 315 0010 1F00A0E3 		mov	r0, #31
 316              		.cfi_offset 14, -4
 317 0014 FEFFFFEB 		bl	twl3025_reg_read
 318 0018 100010E3 		tst	r0, #16
 319 001c FBFFFF0A 		beq	.L27
 201:abb/twl3025.c **** 	twl3025_reg_write(VRPCDEV, 0x01);
 320              		.loc 2 201 0
 321 0020 1E00A0E3 		mov	r0, #30
 322 0024 0110A0E3 		mov	r1, #1
 202:abb/twl3025.c **** }
 323              		.loc 2 202 0
 324 0028 04E09DE4 		ldr	lr, [sp], #4
 201:abb/twl3025.c **** 	twl3025_reg_write(VRPCDEV, 0x01);
 325              		.loc 2 201 0
 326 002c FEFFFFEA 		b	twl3025_reg_write
 327              		.cfi_endproc
 328              	.LFE17:
 330              		.section	.text.twl3025_irq,"ax",%progbits
 331              		.align	2
 333              	twl3025_irq:
 334              	.LFB11:
 102:abb/twl3025.c **** {
 335              		.loc 2 102 0
 336              		.cfi_startproc
 337              		@ args = 0, pretend = 0, frame = 0
 338              		@ frame_needed = 0, uses_anonymous_args = 0
 339              	.LVL18:
 105:abb/twl3025.c **** 	switch (nr){
 340              		.loc 2 105 0
 341 0000 0C0050E3 		cmp	r0, #12
 102:abb/twl3025.c **** {
 342              		.loc 2 102 0
 343 0004 04E02DE5 		str	lr, [sp, #-4]!
 344              	.LCFI4:
 345              		.cfi_def_cfa_offset 4
 105:abb/twl3025.c **** 	switch (nr){
 346              		.loc 2 105 0
 347 0008 0200000A 		beq	.L31
 348              		.cfi_offset 14, -4
 349 000c 110050E3 		cmp	r0, #17
 350 0010 04F09D14 		ldrne	pc, [sp], #4
 351 0014 060000EA 		b	.L33
 352              	.L31:
 107:abb/twl3025.c **** 		src = twl3025_reg_read(ITSTATREG);
 353              		.loc 2 107 0
 354 0018 1B00A0E3 		mov	r0, #27
 355              	.LVL19:
 356 001c FEFFFFEB 		bl	twl3025_reg_read
 357              	.LVL20:
 109:abb/twl3025.c **** 		if (src & 0x08)
 358              		.loc 2 109 0
 359 0020 080010E3 		tst	r0, #8
 360 0024 04F09D04 		ldreq	pc, [sp], #4
 361              	.LBB11:
 362              	.LBB12:
  84:abb/twl3025.c **** 	status = twl3025_reg_read(VRPCSTS);
 363              		.loc 2 84 0
 364 0028 1F00A0E3 		mov	r0, #31
 365              	.LVL21:
 366              	.LBE12:
 367              	.LBE11:
 121:abb/twl3025.c **** }
 368              		.loc 2 121 0
 369 002c 04E09DE4 		ldr	lr, [sp], #4
 370              	.LBB14:
 371              	.LBB13:
  84:abb/twl3025.c **** 	status = twl3025_reg_read(VRPCSTS);
 372              		.loc 2 84 0
 373 0030 FEFFFFEA 		b	twl3025_reg_read
 374              	.LVL22:
 375              	.L33:
 376              	.LBE13:
 377              	.LBE14:
 115:abb/twl3025.c **** 		puts("\nBROWNOUT!1!");
 378              		.loc 2 115 0
 379 0034 08009FE5 		ldr	r0, .L34
 380              	.LVL23:
 381 0038 FEFFFFEB 		bl	puts
 121:abb/twl3025.c **** }
 382              		.loc 2 121 0
 383 003c 04E09DE4 		ldr	lr, [sp], #4
 116:abb/twl3025.c **** 		twl3025_power_off();
 384              		.loc 2 116 0
 385 0040 FEFFFFEA 		b	twl3025_power_off
 386              	.L35:
 387              		.align	2
 388              	.L34:
 389 0044 00000000 		.word	.LC0
 390              		.cfi_endproc
 391              	.LFE11:
 393              		.section	.text.twl3025_clk13m,"ax",%progbits
 394              		.align	2
 395              		.global	twl3025_clk13m
 397              	twl3025_clk13m:
 398              	.LFB18:
 203:abb/twl3025.c **** 
 204:abb/twl3025.c **** void twl3025_clk13m(int enable)
 205:abb/twl3025.c **** {
 399              		.loc 2 205 0
 400              		.cfi_startproc
 401              		@ args = 0, pretend = 0, frame = 0
 402              		@ frame_needed = 0, uses_anonymous_args = 0
 403              	.LVL24:
 206:abb/twl3025.c **** 	if (enable) {
 404              		.loc 2 206 0
 405 0000 000050E3 		cmp	r0, #0
 205:abb/twl3025.c **** {
 406              		.loc 2 205 0
 407 0004 04E02DE5 		str	lr, [sp, #-4]!
 408              	.LCFI5:
 409              		.cfi_def_cfa_offset 4
 207:abb/twl3025.c **** 		twl3025_reg_write(TOGBR2, TOGBR2_ACTS);
 208:abb/twl3025.c **** 		twl3025_wait_ibic_access();
 209:abb/twl3025.c **** 		/* for whatever reason we need to do this twice */
 210:abb/twl3025.c **** 		twl3025_reg_write(TOGBR2, TOGBR2_ACTS);
 211:abb/twl3025.c **** 		twl3025_wait_ibic_access();
 212:abb/twl3025.c **** 	} else {
 213:abb/twl3025.c **** 		twl3025_reg_write(TOGBR2, TOGBR2_ACTR);
 410              		.loc 2 213 0
 411 0008 0500A003 		moveq	r0, #5
 412              	.LVL25:
 413 000c 0410A003 		moveq	r1, #4
 206:abb/twl3025.c **** 	if (enable) {
 414              		.loc 2 206 0
 415 0010 0500000A 		beq	.L38
 416              		.cfi_offset 14, -4
 207:abb/twl3025.c **** 		twl3025_reg_write(TOGBR2, TOGBR2_ACTS);
 417              		.loc 2 207 0
 418 0014 0500A0E3 		mov	r0, #5
 419 0018 0810A0E3 		mov	r1, #8
 420 001c FEFFFFEB 		bl	twl3025_reg_write
 208:abb/twl3025.c **** 		twl3025_wait_ibic_access();
 421              		.loc 2 208 0
 422 0020 FEFFFFEB 		bl	twl3025_wait_ibic_access
 210:abb/twl3025.c **** 		twl3025_reg_write(TOGBR2, TOGBR2_ACTS);
 423              		.loc 2 210 0
 424 0024 0500A0E3 		mov	r0, #5
 425 0028 0810A0E3 		mov	r1, #8
 426              	.L38:
 427              		.loc 2 213 0
 428 002c FEFFFFEB 		bl	twl3025_reg_write
 214:abb/twl3025.c **** 		twl3025_wait_ibic_access();
 215:abb/twl3025.c **** 	}
 216:abb/twl3025.c **** }
 429              		.loc 2 216 0
 430 0030 04E09DE4 		ldr	lr, [sp], #4
 214:abb/twl3025.c **** 		twl3025_wait_ibic_access();
 431              		.loc 2 214 0
 432 0034 FEFFFFEA 		b	twl3025_wait_ibic_access
 433              		.cfi_endproc
 434              	.LFE18:
 436              		.section	.text.twl3025_downlink,"ax",%progbits
 437              		.align	2
 438              		.global	twl3025_downlink
 440              	twl3025_downlink:
 441              	.LFB19:
 217:abb/twl3025.c **** 
 218:abb/twl3025.c **** #define	TSP_DELAY	6	/* 13* Tclk6M5 = ~ 3 GSM Qbits + 3 TPU instructions */
 219:abb/twl3025.c **** #define BDLON_TO_BDLCAL	6
 220:abb/twl3025.c **** #define BDLCAL_DURATION	66
 221:abb/twl3025.c **** #define BDLON_TO_BDLENA	7
 222:abb/twl3025.c **** #define BULON_TO_BULENA	16
 223:abb/twl3025.c **** #define BULON_TO_BULCAL	17
 224:abb/twl3025.c **** #define BULCAL_DURATION	143	/* really that long? */
 225:abb/twl3025.c **** 
 226:abb/twl3025.c **** /* bdl_ena - TSP_DELAY - BDLCAL_DURATION - TSP_DELAY - BDLON_TO_BDLCAL - TSP_DELAY */
 227:abb/twl3025.c **** #define DOWNLINK_DELAY	(3 * TSP_DELAY + BDLCAL_DURATION + BDLON_TO_BDLCAL)
 228:abb/twl3025.c **** 
 229:abb/twl3025.c **** /* Enqueue a series of TSP commands in the TPU to (de)activate the downlink path */
 230:abb/twl3025.c **** void twl3025_downlink(int on, int16_t at)
 231:abb/twl3025.c **** {
 442              		.loc 2 231 0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 0
 445              		@ frame_needed = 0, uses_anonymous_args = 0
 446              	.LVL26:
 447 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 448              	.LCFI6:
 449              		.cfi_def_cfa_offset 16
 450              		.loc 2 231 0
 451 0004 0158A0E1 		mov	r5, r1, asl #16
 452              		.cfi_offset 14, -4
 453              		.cfi_offset 6, -8
 454              		.cfi_offset 5, -12
 455              		.cfi_offset 4, -16
 232:abb/twl3025.c **** 	int16_t bdl_ena = at - TSP_DELAY - 6;
 456              		.loc 2 232 0
 457 0008 035745E2 		sub	r5, r5, #786432
 458 000c 2558A0E1 		mov	r5, r5, lsr #16
 233:abb/twl3025.c **** 
 234:abb/twl3025.c **** 	if (on) {
 459              		.loc 2 234 0
 460 0010 006050E2 		subs	r6, r0, #0
 232:abb/twl3025.c **** 	int16_t bdl_ena = at - TSP_DELAY - 6;
 461              		.loc 2 232 0
 462 0014 0540A0E1 		mov	r4, r5
 463              	.LVL27:
 464 0018 0518A0E1 		mov	r1, r5, asl #16
 465              	.LVL28:
 466              		.loc 2 234 0
 467 001c 1500000A 		beq	.L40
 235:abb/twl3025.c **** 		if (bdl_ena < 0)
 468              		.loc 2 235 0
 469 0020 4118B0E1 		movs	r1, r1, asr #16
 236:abb/twl3025.c **** 			printf("BDLENA time negative (%d)\n", bdl_ena);
 470              		.loc 2 236 0
 471 0024 68009F45 		ldrmi	r0, .L43
 472              	.LVL29:
 473 0028 FEFFFF4B 		blmi	printf
 474              	.L41:
 237:abb/twl3025.c **** 		/* calibration should be done just before BDLENA */
 238:abb/twl3025.c **** 		tpu_enq_at(bdl_ena - DOWNLINK_DELAY);
 475              		.loc 2 238 0
 476 002c 5A5045E2 		sub	r5, r5, #90
 477              	.LVL30:
 478 0030 0508A0E1 		mov	r0, r5, asl #16
 479 0034 4008A0E1 		mov	r0, r0, asr #16
 480 0038 FEFFFFEB 		bl	tpu_enq_at
 239:abb/twl3025.c **** 		/* bdl_ena - TSP_DELAY - BDLCAL_DURATION - TSP_DELAY - BDLON_TO_BDLCAL - TSP_DELAY */
 240:abb/twl3025.c **** 		twl3025_tsp_write(BDLON);
 481              		.loc 2 240 0
 482 003c 1000A0E3 		mov	r0, #16
 483 0040 FEFFFFEB 		bl	twl3025_tsp_write
 241:abb/twl3025.c **** 		/* bdl_ena - TSP_DELAY - BDLCAL_DURATION - TSP_DELAY - BDLON_TO_BDLCAL */
 242:abb/twl3025.c **** 		tpu_enq_wait(BDLON_TO_BDLCAL - TSP_DELAY);
 484              		.loc 2 242 0
 485 0044 0000A0E3 		mov	r0, #0
 486 0048 FEFFFFEB 		bl	tpu_enq_wait
 243:abb/twl3025.c **** 		/* bdl_ena - TSP_DELAY - BDLCAL_DURATION - TSP_DELAY */
 244:abb/twl3025.c **** 		twl3025_tsp_write(BDLON | BDLCAL);
 487              		.loc 2 244 0
 488 004c 1800A0E3 		mov	r0, #24
 489 0050 FEFFFFEB 		bl	twl3025_tsp_write
 245:abb/twl3025.c **** 		/* bdl_ena - TSP_DELAY - BDLCAL_DURATION */
 246:abb/twl3025.c **** 		tpu_enq_wait(BDLCAL_DURATION - TSP_DELAY);
 490              		.loc 2 246 0
 491 0054 3C00A0E3 		mov	r0, #60
 492 0058 FEFFFFEB 		bl	tpu_enq_wait
 247:abb/twl3025.c **** 		/* bdl_ena - TSP_DELAY */
 248:abb/twl3025.c **** 		twl3025_tsp_write(BDLON);
 493              		.loc 2 248 0
 494 005c 1000A0E3 		mov	r0, #16
 495 0060 FEFFFFEB 		bl	twl3025_tsp_write
 249:abb/twl3025.c **** 		//tpu_enq_wait(BDLCAL_TO_BDLENA)	this is only 3.7us == 4 qbits, i.e. less than the TSP_DELAY
 250:abb/twl3025.c **** 		tpu_enq_at(bdl_ena);
 496              		.loc 2 250 0
 497 0064 0408A0E1 		mov	r0, r4, asl #16
 498 0068 4008A0E1 		mov	r0, r0, asr #16
 499 006c FEFFFFEB 		bl	tpu_enq_at
 251:abb/twl3025.c **** 		twl3025_tsp_write(BDLON | BDLENA);
 500              		.loc 2 251 0
 501 0070 1400A0E3 		mov	r0, #20
 502 0074 040000EA 		b	.L42
 503              	.L40:
 252:abb/twl3025.c **** 	} else {
 253:abb/twl3025.c **** 		tpu_enq_at(bdl_ena);
 504              		.loc 2 253 0
 505 0078 4108A0E1 		mov	r0, r1, asr #16
 506 007c FEFFFFEB 		bl	tpu_enq_at
 254:abb/twl3025.c **** 		twl3025_tsp_write(BDLON);
 507              		.loc 2 254 0
 508 0080 1000A0E3 		mov	r0, #16
 509 0084 FEFFFFEB 		bl	twl3025_tsp_write
 255:abb/twl3025.c **** 		//tpu_enq_wait(nBDLENA_TO_nBDLON)	this is only 3.7us == 4 qbits, i.e. less than the TSP_DELAY
 256:abb/twl3025.c **** 		twl3025_tsp_write(0);
 510              		.loc 2 256 0
 511 0088 0600A0E1 		mov	r0, r6
 512              	.L42:
 257:abb/twl3025.c **** 	}
 258:abb/twl3025.c **** }
 513              		.loc 2 258 0
 514 008c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 256:abb/twl3025.c **** 		twl3025_tsp_write(0);
 515              		.loc 2 256 0
 516 0090 FEFFFFEA 		b	twl3025_tsp_write
 517              	.L44:
 518              		.align	2
 519              	.L43:
 520 0094 0D000000 		.word	.LC1
 521              		.cfi_endproc
 522              	.LFE19:
 524              		.section	.text.twl3025_uplink,"ax",%progbits
 525              		.align	2
 526              		.global	twl3025_uplink
 528              	twl3025_uplink:
 529              	.LFB20:
 259:abb/twl3025.c **** 
 260:abb/twl3025.c **** /* bdl_ena - 35 - TSP_DELAY - BULCAL_DURATION - TSP_DELAY - BULON_TO_BULCAL - TSP_DELAY */
 261:abb/twl3025.c **** #define UPLINK_DELAY (3 * TSP_DELAY + BULCAL_DURATION + BULON_TO_BULCAL + 35)
 262:abb/twl3025.c **** 
 263:abb/twl3025.c **** void twl3025_uplink(int on, int16_t at)
 264:abb/twl3025.c **** {
 530              		.loc 2 264 0
 531              		.cfi_startproc
 532              		@ args = 0, pretend = 0, frame = 0
 533              		@ frame_needed = 0, uses_anonymous_args = 0
 534              	.LVL31:
 535 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 536              	.LCFI7:
 537              		.cfi_def_cfa_offset 16
 538              		.loc 2 264 0
 539 0004 0158A0E1 		mov	r5, r1, asl #16
 540              		.cfi_offset 14, -4
 541              		.cfi_offset 6, -8
 542              		.cfi_offset 5, -12
 543              		.cfi_offset 4, -16
 265:abb/twl3025.c **** 	int16_t bul_ena = at - TSP_DELAY - 6;
 544              		.loc 2 265 0
 545 0008 035745E2 		sub	r5, r5, #786432
 546 000c 2558A0E1 		mov	r5, r5, lsr #16
 266:abb/twl3025.c **** 
 267:abb/twl3025.c **** 	if (bul_ena < 0)
 547              		.loc 2 267 0
 548 0010 0518A0E1 		mov	r1, r5, asl #16
 549              	.LVL32:
 550 0014 4118B0E1 		movs	r1, r1, asr #16
 264:abb/twl3025.c **** {
 551              		.loc 2 264 0
 552 0018 0040A0E1 		mov	r4, r0
 265:abb/twl3025.c **** 	int16_t bul_ena = at - TSP_DELAY - 6;
 553              		.loc 2 265 0
 554 001c 0560A0E1 		mov	r6, r5
 555              	.LVL33:
 556              		.loc 2 267 0
 268:abb/twl3025.c **** 		printf("BULENA time negative (%d)\n", bul_ena);
 557              		.loc 2 268 0
 558 0020 80009F45 		ldrmi	r0, .L49
 559              	.LVL34:
 560 0024 FEFFFF4B 		blmi	printf
 561              	.L46:
 269:abb/twl3025.c **** 	if (on) {
 562              		.loc 2 269 0
 563 0028 000054E3 		cmp	r4, #0
 564 002c 0668A0E1 		mov	r6, r6, asl #16
 565 0030 1300000A 		beq	.L47
 270:abb/twl3025.c **** 		/* calibration should  be done just before BULENA */
 271:abb/twl3025.c **** 		tpu_enq_at(bul_ena - UPLINK_DELAY);
 566              		.loc 2 271 0
 567 0034 D55045E2 		sub	r5, r5, #213
 568              	.LVL35:
 569 0038 0508A0E1 		mov	r0, r5, asl #16
 570 003c 4008A0E1 		mov	r0, r0, asr #16
 571 0040 FEFFFFEB 		bl	tpu_enq_at
 272:abb/twl3025.c **** 		/* bdl_ena - 35 - TSP_DELAY - BULCAL_DURATION - TSP_DELAY - BULON_TO_BULCAL - TSP_DELAY */
 273:abb/twl3025.c **** 		twl3025_tsp_write(BULON);
 572              		.loc 2 273 0
 573 0044 8000A0E3 		mov	r0, #128
 574 0048 FEFFFFEB 		bl	twl3025_tsp_write
 274:abb/twl3025.c **** 		/* bdl_ena - 35 - TSP_DELAY - BULCAL_DURATION - TSP_DELAY - BULON_TO_BULCAL */
 275:abb/twl3025.c **** 		tpu_enq_wait(BULON_TO_BULCAL - TSP_DELAY);
 575              		.loc 2 275 0
 576 004c 0B00A0E3 		mov	r0, #11
 577 0050 FEFFFFEB 		bl	tpu_enq_wait
 276:abb/twl3025.c **** 		/* bdl_ena - 35 - TSP_DELAY - BULCAL_DURATION - TSP_DELAY */
 277:abb/twl3025.c **** 		twl3025_tsp_write(BULON | BULCAL);
 578              		.loc 2 277 0
 579 0054 C000A0E3 		mov	r0, #192
 580 0058 FEFFFFEB 		bl	twl3025_tsp_write
 278:abb/twl3025.c **** 		/* bdl_ena - 35 - TSP_DELAY - BULCAL_DURATION */
 279:abb/twl3025.c **** 		tpu_enq_wait(BULCAL_DURATION - TSP_DELAY);
 581              		.loc 2 279 0
 582 005c 8900A0E3 		mov	r0, #137
 583 0060 FEFFFFEB 		bl	tpu_enq_wait
 280:abb/twl3025.c **** 		/* bdl_ena - 35 - TSP_DELAY */
 281:abb/twl3025.c **** 		twl3025_tsp_write(BULON);
 584              		.loc 2 281 0
 585 0064 8000A0E3 		mov	r0, #128
 586 0068 FEFFFFEB 		bl	twl3025_tsp_write
 282:abb/twl3025.c **** 		/* bdl_ena - 35 */
 283:abb/twl3025.c **** 		tpu_enq_wait(35);	/* minimum time required to bring the ramp up (really needed?) */
 587              		.loc 2 283 0
 588 006c 2300A0E3 		mov	r0, #35
 589 0070 FEFFFFEB 		bl	tpu_enq_wait
 284:abb/twl3025.c **** 		tpu_enq_at(bul_ena);
 590              		.loc 2 284 0
 591 0074 4608A0E1 		mov	r0, r6, asr #16
 592 0078 FEFFFFEB 		bl	tpu_enq_at
 285:abb/twl3025.c **** 		twl3025_tsp_write(BULON | BULENA);
 593              		.loc 2 285 0
 594 007c A000A0E3 		mov	r0, #160
 595 0080 060000EA 		b	.L48
 596              	.LVL36:
 597              	.L47:
 286:abb/twl3025.c **** 	} else {
 287:abb/twl3025.c **** 		tpu_enq_at(bul_ena);
 598              		.loc 2 287 0
 599 0084 4608A0E1 		mov	r0, r6, asr #16
 600 0088 FEFFFFEB 		bl	tpu_enq_at
 288:abb/twl3025.c **** 		twl3025_tsp_write(BULON);
 601              		.loc 2 288 0
 602 008c 8000A0E3 		mov	r0, #128
 603 0090 FEFFFFEB 		bl	twl3025_tsp_write
 289:abb/twl3025.c **** 		tpu_enq_wait(35);	/* minimum time required to bring the ramp down (needed!) */
 604              		.loc 2 289 0
 605 0094 2300A0E3 		mov	r0, #35
 606 0098 FEFFFFEB 		bl	tpu_enq_wait
 290:abb/twl3025.c **** 		twl3025_tsp_write(0);
 607              		.loc 2 290 0
 608 009c 0400A0E1 		mov	r0, r4
 609              	.LVL37:
 610              	.L48:
 291:abb/twl3025.c **** 	}
 292:abb/twl3025.c **** }
 611              		.loc 2 292 0
 612 00a0 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 290:abb/twl3025.c **** 		twl3025_tsp_write(0);
 613              		.loc 2 290 0
 614 00a4 FEFFFFEA 		b	twl3025_tsp_write
 615              	.L50:
 616              		.align	2
 617              	.L49:
 618 00a8 28000000 		.word	.LC2
 619              		.cfi_endproc
 620              	.LFE20:
 622              		.section	.text.twl3025_afc_set,"ax",%progbits
 623              		.align	2
 624              		.global	twl3025_afc_set
 626              	twl3025_afc_set:
 627              	.LFB21:
 293:abb/twl3025.c **** 
 294:abb/twl3025.c **** void twl3025_afc_set(int16_t val)
 295:abb/twl3025.c **** {
 628              		.loc 2 295 0
 629              		.cfi_startproc
 630              		@ args = 0, pretend = 0, frame = 0
 631              		@ frame_needed = 0, uses_anonymous_args = 0
 632              	.LVL38:
 633 0000 0008A0E1 		mov	r0, r0, asl #16
 634              	.LVL39:
 635 0004 10402DE9 		stmfd	sp!, {r4, lr}
 636              	.LCFI8:
 637              		.cfi_def_cfa_offset 8
 638              		.loc 2 295 0
 639 0008 4048A0E1 		mov	r4, r0, asr #16
 640              		.cfi_offset 14, -4
 641              		.cfi_offset 4, -8
 296:abb/twl3025.c **** 	printf("twl3025_afc_set(%d)\n", val);
 642              		.loc 2 296 0
 643 000c 0410A0E1 		mov	r1, r4
 644 0010 40009FE5 		ldr	r0, .L55
 645 0014 FEFFFFEB 		bl	printf
 297:abb/twl3025.c **** 
 298:abb/twl3025.c **** 	if (val > 4095)
 646              		.loc 2 298 0
 647 0018 3C309FE5 		ldr	r3, .L55+4
 648 001c 030054E1 		cmp	r4, r3
 299:abb/twl3025.c **** 		val = 4095;
 649              		.loc 2 299 0
 650 0020 0340A0C1 		movgt	r4, r3
 298:abb/twl3025.c **** 	if (val > 4095)
 651              		.loc 2 298 0
 652 0024 020000CA 		bgt	.L52
 300:abb/twl3025.c **** 	else if (val <= -4096)
 301:abb/twl3025.c **** 		val = -4096;
 653              		.loc 2 301 0
 654 0028 30309FE5 		ldr	r3, .L55+8
 655 002c 030054E1 		cmp	r4, r3
 656 0030 0340A0B1 		movlt	r4, r3
 657              	.L52:
 658              	.LVL40:
 302:abb/twl3025.c **** 
 303:abb/twl3025.c **** 	/* FIXME: we currently write from the USP rather than BSP */
 304:abb/twl3025.c **** 	twl3025_reg_write(AUXAFC2, val >> 10);
 659              		.loc 2 304 0
 660 0034 0413A0E1 		mov	r1, r4, asl #6
 661 0038 0800A0E3 		mov	r0, #8
 662 003c 2118A0E1 		mov	r1, r1, lsr #16
 663 0040 FEFFFFEB 		bl	twl3025_reg_write
 305:abb/twl3025.c **** 	twl3025_reg_write(AUXAFC1, val & 0x3ff);
 664              		.loc 2 305 0
 665 0044 041BA0E1 		mov	r1, r4, asl #22
 666 0048 0700A0E3 		mov	r0, #7
 667 004c 211BA0E1 		mov	r1, r1, lsr #22
 306:abb/twl3025.c **** }
 668              		.loc 2 306 0
 669 0050 1040BDE8 		ldmfd	sp!, {r4, lr}
 305:abb/twl3025.c **** 	twl3025_reg_write(AUXAFC1, val & 0x3ff);
 670              		.loc 2 305 0
 671 0054 FEFFFFEA 		b	twl3025_reg_write
 672              	.L56:
 673              		.align	2
 674              	.L55:
 675 0058 43000000 		.word	.LC3
 676 005c FF0F0000 		.word	4095
 677 0060 00F0FFFF 		.word	-4096
 678              		.cfi_endproc
 679              	.LFE21:
 681              		.section	.text.twl3025_afc_get,"ax",%progbits
 682              		.align	2
 683              		.global	twl3025_afc_get
 685              	twl3025_afc_get:
 686              	.LFB22:
 307:abb/twl3025.c **** 
 308:abb/twl3025.c **** int16_t twl3025_afc_get(void)
 309:abb/twl3025.c **** {
 687              		.loc 2 309 0
 688              		.cfi_startproc
 689              		@ args = 0, pretend = 0, frame = 0
 690              		@ frame_needed = 0, uses_anonymous_args = 0
 691 0000 10402DE9 		stmfd	sp!, {r4, lr}
 692              	.LCFI9:
 693              		.cfi_def_cfa_offset 8
 310:abb/twl3025.c **** 	int16_t val;
 311:abb/twl3025.c **** 
 312:abb/twl3025.c **** 	val = (twl3025_reg_read(AUXAFC2) & 0x7);
 694              		.loc 2 312 0
 695 0004 0800A0E3 		mov	r0, #8
 696              		.cfi_offset 14, -4
 697              		.cfi_offset 4, -8
 698 0008 FEFFFFEB 		bl	twl3025_reg_read
 699              	.LVL41:
 313:abb/twl3025.c **** 	val = val << 10;
 700              		.loc 2 313 0
 701 000c 070000E2 		and	r0, r0, #7
 702              	.LVL42:
 703 0010 0045A0E1 		mov	r4, r0, asl #10
 704              	.LVL43:
 314:abb/twl3025.c **** 	val = val | (twl3025_reg_read(AUXAFC1) & 0x3ff);
 705              		.loc 2 314 0
 706 0014 0700A0E3 		mov	r0, #7
 707 0018 FEFFFFEB 		bl	twl3025_reg_read
 708 001c 000BA0E1 		mov	r0, r0, asl #22
 709 0020 204B84E1 		orr	r4, r4, r0, lsr #22
 710              	.LVL44:
 315:abb/twl3025.c **** 
 316:abb/twl3025.c **** 	if (val > 4095)
 711              		.loc 2 316 0
 712 0024 010A54E3 		cmp	r4, #4096
 317:abb/twl3025.c **** 		val = -(8192 - val);
 713              		.loc 2 317 0
 714 0028 024A44A2 		subge	r4, r4, #8192
 715              	.LVL45:
 716 002c 0448A0A1 		movge	r4, r4, asl #16
 717 0030 2448A0A1 		movge	r4, r4, lsr #16
 718              	.LVL46:
 719 0034 0448A0E1 		mov	r4, r4, asl #16
 720              	.LVL47:
 318:abb/twl3025.c **** 	return val;
 319:abb/twl3025.c **** }
 721              		.loc 2 319 0
 722 0038 4408A0E1 		mov	r0, r4, asr #16
 723 003c 1080BDE8 		ldmfd	sp!, {r4, pc}
 724              		.cfi_endproc
 725              	.LFE22:
 727              		.section	.text.twl3025_unit_enable,"ax",%progbits
 728              		.align	2
 729              		.global	twl3025_unit_enable
 731              	twl3025_unit_enable:
 732              	.LFB23:
 320:abb/twl3025.c **** 
 321:abb/twl3025.c **** void twl3025_unit_enable(enum twl3025_unit unit, int on)
 322:abb/twl3025.c **** {
 733              		.loc 2 322 0
 734              		.cfi_startproc
 735              		@ args = 0, pretend = 0, frame = 0
 736              		@ frame_needed = 0, uses_anonymous_args = 0
 737              		@ link register save eliminated.
 738              	.LVL48:
 323:abb/twl3025.c **** 	uint16_t togbr1 = 0;
 324:abb/twl3025.c **** 
 325:abb/twl3025.c **** 	switch (unit) {
 739              		.loc 2 325 0
 740 0000 040050E3 		cmp	r0, #4
 741 0004 00F19F97 		ldrls	pc, [pc, r0, asl #2]
 742 0008 140000EA 		b	.L66
 743              	.L65:
 744 000c 20000000 		.word	.L61
 745 0010 30000000 		.word	.L62
 746 0014 40000000 		.word	.L63
 747 0018 40000000 		.word	.L63
 748 001c 50000000 		.word	.L64
 749              	.L61:
 326:abb/twl3025.c **** 	case TWL3025_UNIT_AFC:
 327:abb/twl3025.c **** 		if (on)
 328:abb/twl3025.c **** 			togbr1 = (1 << 7);
 750              		.loc 2 328 0
 751 0020 000051E3 		cmp	r1, #0
 752 0024 4010A003 		moveq	r1, #64
 753              	.LVL49:
 754 0028 8010A013 		movne	r1, #128
 755 002c 0C0000EA 		b	.L60
 756              	.LVL50:
 757              	.L62:
 329:abb/twl3025.c **** 		else
 330:abb/twl3025.c **** 			togbr1 = (1 << 6);
 331:abb/twl3025.c **** 		break;
 332:abb/twl3025.c **** 	case TWL3025_UNIT_MAD:
 333:abb/twl3025.c **** 		if (on)
 334:abb/twl3025.c **** 			togbr1 = (1 << 9);
 758              		.loc 2 334 0
 759 0030 000051E3 		cmp	r1, #0
 760 0034 011CA003 		moveq	r1, #256
 761              	.LVL51:
 762 0038 021CA013 		movne	r1, #512
 763 003c 080000EA 		b	.L60
 764              	.LVL52:
 765              	.L63:
 335:abb/twl3025.c **** 		else
 336:abb/twl3025.c **** 			togbr1 = (1 << 8);
 337:abb/twl3025.c **** 		break;
 338:abb/twl3025.c **** 	case TWL3025_UNIT_ADA:
 339:abb/twl3025.c **** 		if (on)
 340:abb/twl3025.c **** 			togbr1 = (1 << 5);
 341:abb/twl3025.c **** 		else
 342:abb/twl3025.c **** 			togbr1 = (1 << 4);
 343:abb/twl3025.c **** 	case TWL3025_UNIT_VDL:
 344:abb/twl3025.c **** 		if (on)
 345:abb/twl3025.c **** 			togbr1 = (1 << 3);
 766              		.loc 2 345 0
 767 0040 000051E3 		cmp	r1, #0
 768 0044 0410A003 		moveq	r1, #4
 769              	.LVL53:
 770 0048 0810A013 		movne	r1, #8
 771 004c 040000EA 		b	.L60
 772              	.LVL54:
 773              	.L64:
 346:abb/twl3025.c **** 		else
 347:abb/twl3025.c **** 			togbr1 = (1 << 2);
 348:abb/twl3025.c **** 		break;
 349:abb/twl3025.c **** 	case TWL3025_UNIT_VUL:
 350:abb/twl3025.c **** 		if (on)
 351:abb/twl3025.c **** 			togbr1 = (1 << 1);
 774              		.loc 2 351 0
 775 0050 000051E3 		cmp	r1, #0
 776 0054 0110A003 		moveq	r1, #1
 777              	.LVL55:
 778 0058 0210A013 		movne	r1, #2
 779 005c 000000EA 		b	.L60
 780              	.LVL56:
 781              	.L66:
 323:abb/twl3025.c **** 	uint16_t togbr1 = 0;
 782              		.loc 2 323 0
 783 0060 0010A0E3 		mov	r1, #0
 784              	.LVL57:
 785              	.L60:
 352:abb/twl3025.c **** 		else
 353:abb/twl3025.c **** 			togbr1 = (1 << 0);
 354:abb/twl3025.c **** 		break;
 355:abb/twl3025.c **** 	}
 356:abb/twl3025.c **** 	twl3025_reg_write(TOGBR1, togbr1);
 786              		.loc 2 356 0
 787 0064 0400A0E3 		mov	r0, #4
 788              	.LVL58:
 357:abb/twl3025.c **** }
 789              		.loc 2 357 0
 356:abb/twl3025.c **** 	twl3025_reg_write(TOGBR1, togbr1);
 790              		.loc 2 356 0
 791 0068 FEFFFFEA 		b	twl3025_reg_write
 792              		.cfi_endproc
 793              	.LFE23:
 795              		.section	.text.twl3025_init,"ax",%progbits
 796              		.align	2
 797              		.global	twl3025_init
 799              	twl3025_init:
 800              	.LFB12:
 124:abb/twl3025.c **** {
 801              		.loc 2 124 0
 802              		.cfi_startproc
 803              		@ args = 0, pretend = 0, frame = 0
 804              		@ frame_needed = 0, uses_anonymous_args = 0
 805 0000 10402DE9 		stmfd	sp!, {r4, lr}
 806              	.LCFI10:
 807              		.cfi_def_cfa_offset 8
 125:abb/twl3025.c **** 	spi_init();
 808              		.loc 2 125 0
 809              		.cfi_offset 14, -4
 810              		.cfi_offset 4, -8
 811 0004 FEFFFFEB 		bl	spi_init
 126:abb/twl3025.c **** 	twl3025_switch_page(0);
 812              		.loc 2 126 0
 813 0008 0000A0E3 		mov	r0, #0
 814 000c FEFFFFEB 		bl	twl3025_switch_page
 127:abb/twl3025.c **** 	twl3025_clk13m(1);
 815              		.loc 2 127 0
 816 0010 0100A0E3 		mov	r0, #1
 817 0014 FEFFFFEB 		bl	twl3025_clk13m
 131:abb/twl3025.c **** 	irq_register_handler(IRQ_EXTERNAL, &twl3025_irq);
 818              		.loc 2 131 0
 819 0018 68409FE5 		ldr	r4, .L72
 128:abb/twl3025.c **** 	twl3025_reg_write(AFCCTLADD, 0x01);	/* AFCCK(1:0) must not be zero! */
 820              		.loc 2 128 0
 821 001c 9500A0E3 		mov	r0, #149
 822 0020 0110A0E3 		mov	r1, #1
 823 0024 FEFFFFEB 		bl	twl3025_reg_write
 129:abb/twl3025.c **** 	twl3025_unit_enable(TWL3025_UNIT_AFC, 1);
 824              		.loc 2 129 0
 825 0028 0000A0E3 		mov	r0, #0
 826 002c 0110A0E3 		mov	r1, #1
 827 0030 FEFFFFEB 		bl	twl3025_unit_enable
 131:abb/twl3025.c **** 	irq_register_handler(IRQ_EXTERNAL, &twl3025_irq);
 828              		.loc 2 131 0
 829 0034 0410A0E1 		mov	r1, r4
 830 0038 0C00A0E3 		mov	r0, #12
 831 003c FEFFFFEB 		bl	irq_register_handler
 132:abb/twl3025.c **** 	irq_config(IRQ_EXTERNAL, 0, 0, 0);
 832              		.loc 2 132 0
 833 0040 0010A0E3 		mov	r1, #0
 834 0044 0120A0E1 		mov	r2, r1
 835 0048 0130A0E1 		mov	r3, r1
 836 004c 0C00A0E3 		mov	r0, #12
 837 0050 FEFFFFEB 		bl	irq_config
 133:abb/twl3025.c **** 	irq_enable(IRQ_EXTERNAL);
 838              		.loc 2 133 0
 839 0054 0C00A0E3 		mov	r0, #12
 840 0058 FEFFFFEB 		bl	irq_enable
 135:abb/twl3025.c **** 	irq_register_handler(IRQ_EXTERNAL_FIQ, &twl3025_irq);
 841              		.loc 2 135 0
 842 005c 0410A0E1 		mov	r1, r4
 843 0060 1100A0E3 		mov	r0, #17
 844 0064 FEFFFFEB 		bl	irq_register_handler
 136:abb/twl3025.c **** 	irq_config(IRQ_EXTERNAL_FIQ, 1, 0, 0);
 845              		.loc 2 136 0
 846 0068 0020A0E3 		mov	r2, #0
 847 006c 1100A0E3 		mov	r0, #17
 848 0070 0110A0E3 		mov	r1, #1
 849 0074 0230A0E1 		mov	r3, r2
 850 0078 FEFFFFEB 		bl	irq_config
 137:abb/twl3025.c **** 	irq_enable(IRQ_EXTERNAL_FIQ);
 851              		.loc 2 137 0
 852 007c 1100A0E3 		mov	r0, #17
 138:abb/twl3025.c **** }
 853              		.loc 2 138 0
 854 0080 1040BDE8 		ldmfd	sp!, {r4, lr}
 137:abb/twl3025.c **** 	irq_enable(IRQ_EXTERNAL_FIQ);
 855              		.loc 2 137 0
 856 0084 FEFFFFEA 		b	irq_enable
 857              	.L73:
 858              		.align	2
 859              	.L72:
 860 0088 00000000 		.word	twl3025_irq
 861              		.cfi_endproc
 862              	.LFE12:
 864              		.section	.text.twl3025_afcout_get,"ax",%progbits
 865              		.align	2
 866              		.global	twl3025_afcout_get
 868              	twl3025_afcout_get:
 869              	.LFB24:
 358:abb/twl3025.c **** 
 359:abb/twl3025.c **** uint8_t twl3025_afcout_get(void)
 360:abb/twl3025.c **** {
 870              		.loc 2 360 0
 871              		.cfi_startproc
 872              		@ args = 0, pretend = 0, frame = 0
 873              		@ frame_needed = 0, uses_anonymous_args = 0
 874 0000 04E02DE5 		str	lr, [sp, #-4]!
 875              	.LCFI11:
 876              		.cfi_def_cfa_offset 4
 361:abb/twl3025.c **** 	return twl3025_reg_read(AFCOUT) & 0xff;
 877              		.loc 2 361 0
 878 0004 9600A0E3 		mov	r0, #150
 879              		.cfi_offset 14, -4
 880 0008 FEFFFFEB 		bl	twl3025_reg_read
 881 000c FF0000E2 		and	r0, r0, #255
 362:abb/twl3025.c **** }
 882              		.loc 2 362 0
 883 0010 04F09DE4 		ldr	pc, [sp], #4
 884              		.cfi_endproc
 885              	.LFE24:
 887              		.section	.text.twl3025_afcout_set,"ax",%progbits
 888              		.align	2
 889              		.global	twl3025_afcout_set
 891              	twl3025_afcout_set:
 892              	.LFB25:
 363:abb/twl3025.c **** 
 364:abb/twl3025.c **** void twl3025_afcout_set(uint8_t val)
 365:abb/twl3025.c **** {
 893              		.loc 2 365 0
 894              		.cfi_startproc
 895              		@ args = 0, pretend = 0, frame = 0
 896              		@ frame_needed = 0, uses_anonymous_args = 0
 897              	.LVL59:
 898 0000 10402DE9 		stmfd	sp!, {r4, lr}
 899              	.LCFI12:
 900              		.cfi_def_cfa_offset 8
 366:abb/twl3025.c **** 	twl3025_reg_write(AFCCTLADD, 0x05);
 901              		.loc 2 366 0
 902 0004 0510A0E3 		mov	r1, #5
 365:abb/twl3025.c **** {
 903              		.loc 2 365 0
 904 0008 FF4000E2 		and	r4, r0, #255
 905              		.cfi_offset 14, -4
 906              		.cfi_offset 4, -8
 907              		.loc 2 366 0
 908 000c 9500A0E3 		mov	r0, #149
 909              	.LVL60:
 910 0010 FEFFFFEB 		bl	twl3025_reg_write
 367:abb/twl3025.c **** 	twl3025_reg_write(AFCOUT, val);
 911              		.loc 2 367 0
 912 0014 9600A0E3 		mov	r0, #150
 913 0018 0410A0E1 		mov	r1, r4
 368:abb/twl3025.c **** }
 914              		.loc 2 368 0
 915 001c 1040BDE8 		ldmfd	sp!, {r4, lr}
 367:abb/twl3025.c **** 	twl3025_reg_write(AFCOUT, val);
 916              		.loc 2 367 0
 917 0020 FEFFFFEA 		b	twl3025_reg_write
 918              		.cfi_endproc
 919              	.LFE25:
 921              		.global	twl3025_default_ramp
 922              		.section	.rodata
 923              		.align	2
 926              	twl3025_default_ramp:
 927 0000 0000     		.short	0
 928 0002 6001     		.short	352
 929 0004 E003     		.short	992
 930 0006 E003     		.short	992
 931 0008 E003     		.short	992
 932 000a 0003     		.short	768
 933 000c 0000     		.short	0
 934 000e 0000     		.short	0
 935 0010 0900     		.short	9
 936 0012 1200     		.short	18
 937 0014 1900     		.short	25
 938 0016 1F00     		.short	31
 939 0018 1E00     		.short	30
 940 001a 0F00     		.short	15
 941 001c 0000     		.short	0
 942 001e 0000     		.short	0
 943              		.section	.rodata.str1.1,"aMS",%progbits,1
 944              	.LC0:
 945 0000 0A42524F 		.ascii	"\012BROWNOUT!1!\000"
 945      574E4F55 
 945      54213121 
 945      00
 946              	.LC1:
 947 000d 42444C45 		.ascii	"BDLENA time negative (%d)\012\000"
 947      4E412074 
 947      696D6520 
 947      6E656761 
 947      74697665 
 948              	.LC2:
 949 0028 42554C45 		.ascii	"BULENA time negative (%d)\012\000"
 949      4E412074 
 949      696D6520 
 949      6E656761 
 949      74697665 
 950              	.LC3:
 951 0043 74776C33 		.ascii	"twl3025_afc_set(%d)\012\000"
 951      3032355F 
 951      6166635F 
 951      73657428 
 951      2564290A 
 952              		.bss
 953              		.align	2
 954              		.set	.LANCHOR0,. + 0
 957              	twl3025_state:
 958 0000 00000000 		.space	4
 959              		.text
 960              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 twl3025.c
     /tmp/cc3JA8Xo.s:12     .text.tpu_enq_at:0000000000000000 $a
     /tmp/cc3JA8Xo.s:14     .text.tpu_enq_at:0000000000000000 tpu_enq_at
     /tmp/cc3JA8Xo.s:53     .text.tpu_enq_at:0000000000000030 $d
     /tmp/cc3JA8Xo.s:58     .text.tpu_enq_wait:0000000000000000 $a
     /tmp/cc3JA8Xo.s:60     .text.tpu_enq_wait:0000000000000000 tpu_enq_wait
     /tmp/cc3JA8Xo.s:79     .text.tpu_enq_wait:0000000000000010 $d
     /tmp/cc3JA8Xo.s:84     .text.twl3025_wait_ibic_access:0000000000000000 $a
     /tmp/cc3JA8Xo.s:86     .text.twl3025_wait_ibic_access:0000000000000000 twl3025_wait_ibic_access
     /tmp/cc3JA8Xo.s:103    .text.twl3025_reg_write:0000000000000000 $a
     /tmp/cc3JA8Xo.s:106    .text.twl3025_reg_write:0000000000000000 twl3025_reg_write
     /tmp/cc3JA8Xo.s:165    .text.twl3025_switch_page:0000000000000000 twl3025_switch_page
     /tmp/cc3JA8Xo.s:158    .text.twl3025_reg_write:0000000000000054 $d
     /tmp/cc3JA8Xo.s:163    .text.twl3025_switch_page:0000000000000000 $a
     /tmp/cc3JA8Xo.s:195    .text.twl3025_switch_page:0000000000000028 $d
     /tmp/cc3JA8Xo.s:200    .text.twl3025_tsp_write:0000000000000000 $a
     /tmp/cc3JA8Xo.s:203    .text.twl3025_tsp_write:0000000000000000 twl3025_tsp_write
     /tmp/cc3JA8Xo.s:224    .text.twl3025_reg_read:0000000000000000 $a
     /tmp/cc3JA8Xo.s:227    .text.twl3025_reg_read:0000000000000000 twl3025_reg_read
     /tmp/cc3JA8Xo.s:288    .text.twl3025_reg_read:0000000000000070 $d
     /tmp/cc3JA8Xo.s:293    .text.twl3025_power_off:0000000000000000 $a
     /tmp/cc3JA8Xo.s:296    .text.twl3025_power_off:0000000000000000 twl3025_power_off
     /tmp/cc3JA8Xo.s:331    .text.twl3025_irq:0000000000000000 $a
     /tmp/cc3JA8Xo.s:333    .text.twl3025_irq:0000000000000000 twl3025_irq
     /tmp/cc3JA8Xo.s:389    .text.twl3025_irq:0000000000000044 $d
     /tmp/cc3JA8Xo.s:394    .text.twl3025_clk13m:0000000000000000 $a
     /tmp/cc3JA8Xo.s:397    .text.twl3025_clk13m:0000000000000000 twl3025_clk13m
     /tmp/cc3JA8Xo.s:437    .text.twl3025_downlink:0000000000000000 $a
     /tmp/cc3JA8Xo.s:440    .text.twl3025_downlink:0000000000000000 twl3025_downlink
     /tmp/cc3JA8Xo.s:520    .text.twl3025_downlink:0000000000000094 $d
     /tmp/cc3JA8Xo.s:525    .text.twl3025_uplink:0000000000000000 $a
     /tmp/cc3JA8Xo.s:528    .text.twl3025_uplink:0000000000000000 twl3025_uplink
     /tmp/cc3JA8Xo.s:618    .text.twl3025_uplink:00000000000000a8 $d
     /tmp/cc3JA8Xo.s:623    .text.twl3025_afc_set:0000000000000000 $a
     /tmp/cc3JA8Xo.s:626    .text.twl3025_afc_set:0000000000000000 twl3025_afc_set
     /tmp/cc3JA8Xo.s:675    .text.twl3025_afc_set:0000000000000058 $d
     /tmp/cc3JA8Xo.s:682    .text.twl3025_afc_get:0000000000000000 $a
     /tmp/cc3JA8Xo.s:685    .text.twl3025_afc_get:0000000000000000 twl3025_afc_get
     /tmp/cc3JA8Xo.s:728    .text.twl3025_unit_enable:0000000000000000 $a
     /tmp/cc3JA8Xo.s:731    .text.twl3025_unit_enable:0000000000000000 twl3025_unit_enable
     /tmp/cc3JA8Xo.s:744    .text.twl3025_unit_enable:000000000000000c $d
     /tmp/cc3JA8Xo.s:751    .text.twl3025_unit_enable:0000000000000020 $a
     /tmp/cc3JA8Xo.s:796    .text.twl3025_init:0000000000000000 $a
     /tmp/cc3JA8Xo.s:799    .text.twl3025_init:0000000000000000 twl3025_init
     /tmp/cc3JA8Xo.s:860    .text.twl3025_init:0000000000000088 $d
     /tmp/cc3JA8Xo.s:865    .text.twl3025_afcout_get:0000000000000000 $a
     /tmp/cc3JA8Xo.s:868    .text.twl3025_afcout_get:0000000000000000 twl3025_afcout_get
     /tmp/cc3JA8Xo.s:888    .text.twl3025_afcout_set:0000000000000000 $a
     /tmp/cc3JA8Xo.s:891    .text.twl3025_afcout_set:0000000000000000 twl3025_afcout_set
     /tmp/cc3JA8Xo.s:926    .rodata:0000000000000000 twl3025_default_ramp
     /tmp/cc3JA8Xo.s:923    .rodata:0000000000000000 $d
     /tmp/cc3JA8Xo.s:953    .bss:0000000000000000 $d
     /tmp/cc3JA8Xo.s:957    .bss:0000000000000000 twl3025_state
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
tpu_enqueue
delay_ms
spi_xfer
tsp_write
puts
printf
spi_init
irq_register_handler
irq_config
irq_enable
