   1              		.file	"sim.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.sim_irq_handler,"ax",%progbits
  12              		.align	2
  13              		.global	sim_irq_handler
  15              	sim_irq_handler:
  16              	.LFB39:
  17              		.file 1 "calypso/sim.c"
   1:calypso/sim.c **** /* Driver for Simcard Controller inside TI Calypso/Iota */
   2:calypso/sim.c **** 
   3:calypso/sim.c **** /* (C) 2010 by Philipp Fabian Benedikt Maier <philipp-maier@runningserver.com>
   4:calypso/sim.c ****  * (C) 2011 by Andreas Eversberg <jolly@eversberg.eu>
   5:calypso/sim.c ****  *
   6:calypso/sim.c ****  * All Rights Reserved
   7:calypso/sim.c ****  *
   8:calypso/sim.c ****  * This program is free software; you can redistribute it and/or modify
   9:calypso/sim.c ****  * it under the terms of the GNU General Public License as published by
  10:calypso/sim.c ****  * the Free Software Foundation; either version 2 of the License, or
  11:calypso/sim.c ****  * (at your option) any later version.
  12:calypso/sim.c ****  *
  13:calypso/sim.c ****  * This program is distributed in the hope that it will be useful,
  14:calypso/sim.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:calypso/sim.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:calypso/sim.c ****  * GNU General Public License for more details.
  17:calypso/sim.c ****  *
  18:calypso/sim.c ****  * You should have received a copy of the GNU General Public License along
  19:calypso/sim.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  20:calypso/sim.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  21:calypso/sim.c ****  *
  22:calypso/sim.c ****  */
  23:calypso/sim.c **** 
  24:calypso/sim.c **** /* Uncomment to debug sim */
  25:calypso/sim.c **** /* #define DEBUG */
  26:calypso/sim.c **** 
  27:calypso/sim.c **** #include <stdint.h>
  28:calypso/sim.c **** #include <stdio.h>
  29:calypso/sim.c **** 
  30:calypso/sim.c **** #include <debug.h>
  31:calypso/sim.c **** #include <memory.h>
  32:calypso/sim.c **** #include <string.h>
  33:calypso/sim.c **** #include <delay.h>
  34:calypso/sim.c **** #include <osmocom/core/msgb.h>
  35:calypso/sim.c **** #include <layer1/l23_api.h>
  36:calypso/sim.c **** #include <abb/twl3025.h>
  37:calypso/sim.c **** #include <calypso/sim.h>
  38:calypso/sim.c **** #include <calypso/irq.h>
  39:calypso/sim.c **** 
  40:calypso/sim.c **** #include <l1ctl_proto.h>
  41:calypso/sim.c **** 
  42:calypso/sim.c **** #define SIM_CLASS		0xA0
  43:calypso/sim.c **** 	/* Class that contains the following instructions */
  44:calypso/sim.c **** #define SIM_GET_RESPONSE	0xC0
  45:calypso/sim.c **** 	/* Get the response of a command from the card */
  46:calypso/sim.c **** #define SIM_READ_BINARY		0xB0	/* Read file in binary mode */
  47:calypso/sim.c **** #define SIM_READ_RECORD		0xB2	/* Read record in binary mode */
  48:calypso/sim.c **** 
  49:calypso/sim.c **** enum {
  50:calypso/sim.c **** 	SIM_STATE_IDLE,
  51:calypso/sim.c **** 	SIM_STATE_TX_HEADER,
  52:calypso/sim.c **** 	SIM_STATE_RX_STATUS,
  53:calypso/sim.c **** 	SIM_STATE_RX_ACK,
  54:calypso/sim.c **** 	SIM_STATE_RX_ACK_DATA,
  55:calypso/sim.c **** 	SIM_STATE_TX_DATA,
  56:calypso/sim.c **** };
  57:calypso/sim.c **** 
  58:calypso/sim.c **** #define L3_MSG_HEAD 4
  59:calypso/sim.c **** 
  60:calypso/sim.c **** static uint8_t sim_data[256]; /* buffer for SIM command */
  61:calypso/sim.c **** static volatile uint16_t sim_len = 0; /* lenght of data in sim_data[] */
  62:calypso/sim.c **** static volatile uint8_t sim_state = SIM_STATE_IDLE;
  63:calypso/sim.c **** 	/* current state of SIM process */
  64:calypso/sim.c **** static volatile uint8_t sim_ignore_waiting_char = 0;
  65:calypso/sim.c **** 	/* signal ignoring of NULL procedure byte */
  66:calypso/sim.c **** static volatile int sim_rx_character_count = 0;
  67:calypso/sim.c **** 	/* How many bytes have been received by calypso_sim_receive() */
  68:calypso/sim.c **** static volatile int sim_rx_max_character_count = 0;
  69:calypso/sim.c **** 	/* How many bytes have been received by calypso_sim_receive() */
  70:calypso/sim.c **** static volatile int sim_tx_character_count = 0;
  71:calypso/sim.c **** 	/* How many bytes have been transmitted by calypso_sim_transmit() */
  72:calypso/sim.c **** static volatile int sim_tx_character_length = 0;
  73:calypso/sim.c **** 	/* How many bytes have to be transmitted by calypso_sim_transmit() */
  74:calypso/sim.c **** static uint8_t *rx_buffer = 0;
  75:calypso/sim.c **** 	/* RX-Buffer that is issued by calypso_sim_receive() */
  76:calypso/sim.c **** static uint8_t *tx_buffer = 0;
  77:calypso/sim.c **** 	/* TX-Buffer that is issued by calypso_sim_transmit() */
  78:calypso/sim.c **** static volatile int rxDoneFlag = 0;
  79:calypso/sim.c **** 	/* Used for rx synchronization instead of a semaphore in calypso_sim_receive() */
  80:calypso/sim.c **** static volatile int txDoneFlag = 0;
  81:calypso/sim.c **** 	/* Used for rx synchronization instead of a semaphore in calypso_sim_transmit() */
  82:calypso/sim.c **** 
  83:calypso/sim.c **** /* Display Register dump */
  84:calypso/sim.c **** void calypso_sim_regdump(void)
  85:calypso/sim.c **** {
  86:calypso/sim.c **** #ifdef DEBUG
  87:calypso/sim.c **** 	unsigned int regVal;
  88:calypso/sim.c **** 
  89:calypso/sim.c **** #define SIM_DEBUG_OUTPUTDELAY 200
  90:calypso/sim.c **** 
  91:calypso/sim.c **** 	puts("\n\n\n");
  92:calypso/sim.c **** 	puts("====================== CALYPSO SIM REGISTER DUMP =====================\n");
  93:calypso/sim.c **** 	puts("Reg_sim_cmd register (R/W) - FFFE:0000\n");
  94:calypso/sim.c **** 
  95:calypso/sim.c **** 	regVal = readw(REG_SIM_CMD);
  96:calypso/sim.c **** 	printf("  |-REG_SIM_CMD = %04x\n", readw(REG_SIM_CMD));
  97:calypso/sim.c **** 
  98:calypso/sim.c **** 	if(regVal & REG_SIM_CMD_CMDCARDRST)
  99:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDCARDRST = 1 ==> SIM card reset sequence enabled.\n");
 100:calypso/sim.c **** 	else
 101:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDCARDRST = 0 ==> SIM card reset sequence disabled.\n");
 102:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 103:calypso/sim.c **** 
 104:calypso/sim.c **** 	if(regVal & REG_SIM_CMD_CMDIFRST)
 105:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDIFRST = 1\n");
 106:calypso/sim.c **** 	else
 107:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDIFRST = 0\n");
 108:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 109:calypso/sim.c **** 
 110:calypso/sim.c **** 	if(regVal & REG_SIM_CMD_CMDSTOP)
 111:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDSTOP = 1\n");
 112:calypso/sim.c **** 	else
 113:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDSTOP = 0\n");
 114:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 115:calypso/sim.c **** 
 116:calypso/sim.c **** 	if(regVal & REG_SIM_CMD_CMDSTART)
 117:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDSTART = 1 ==> SIM card start procedure active.\n");
 118:calypso/sim.c **** 	else
 119:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_CMDSTART = 0\n");
 120:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 121:calypso/sim.c **** 
 122:calypso/sim.c **** 	if(regVal & REG_SIM_CMD_CMDSTART)
 123:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_MODULE_CLK_EN = 1 ==> Clock of the module enabled.\n");
 124:calypso/sim.c **** 	else
 125:calypso/sim.c **** 		puts("  |  |-REG_SIM_CMD_MODULE_CLK_EN = 0 ==> Clock of the module disabled.\n");
 126:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 127:calypso/sim.c **** 
 128:calypso/sim.c **** 	regVal = readw(REG_SIM_STAT);
 129:calypso/sim.c **** 	printf("  |-REG_SIM_STAT = %04x\n", regVal);
 130:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 131:calypso/sim.c **** 
 132:calypso/sim.c **** 	if(regVal & REG_SIM_STAT_STATNOCARD)
 133:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATNOCARD = 1 ==> No card!\n");
 134:calypso/sim.c **** 	else
 135:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATNOCARD = 0 ==> Card detected!\n");
 136:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 137:calypso/sim.c **** 
 138:calypso/sim.c **** 	if(regVal & REG_SIM_STAT_STATTXPAR)
 139:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATTXPAR = 1 ==> Parity ok!\n");
 140:calypso/sim.c **** 	else
 141:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATTXPAR = 0 ==> Parity error!\n");
 142:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 143:calypso/sim.c **** 
 144:calypso/sim.c **** 	if(regVal & REG_SIM_STAT_STATFIFOFULL)
 145:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATFIFOFULL = 1 ==> Fifo full!\n");
 146:calypso/sim.c **** 	else
 147:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATFIFOFULL = 0\n");
 148:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 149:calypso/sim.c **** 
 150:calypso/sim.c **** 	if(regVal & REG_SIM_STAT_STATFIFOEMPTY)
 151:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATFIFOEMPTY = 1 ==> Fifo empty!\n");
 152:calypso/sim.c **** 	else
 153:calypso/sim.c **** 		puts("  |  |-REG_SIM_STAT_STATFIFOEMPTY = 0\n");
 154:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 155:calypso/sim.c **** 
 156:calypso/sim.c **** 	regVal = readw(REG_SIM_CONF1);
 157:calypso/sim.c **** 	printf("  |-REG_SIM_CONF1 = %04x\n", regVal);
 158:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 159:calypso/sim.c **** 
 160:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFCHKPAR)
 161:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFCHKPAR = 1 ==> Parity check on reception enabled.\n");
 162:calypso/sim.c **** 	else
 163:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFCHKPAR = 0 ==> Parity check on reception disabled.\n");
 164:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 165:calypso/sim.c **** 
 166:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFCODCONV)
 167:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFCODCONV = 1 ==> Coding convention is inverse.\n");
 168:calypso/sim.c **** 	else
 169:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFCODCONV = 0 ==> Coding convention is direct (normal).\n");
 170:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 171:calypso/sim.c **** 
 172:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFTXRX)
 173:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFTXRX = 1 ==> SIO line direction is in transmit mode.\n");
 174:calypso/sim.c **** 	else
 175:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFTXRX = 0 ==> SIO line direction is in receive mode.\n");
 176:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 177:calypso/sim.c **** 
 178:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFSCLKEN)
 179:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSCLKEN = 1 ==> SIM clock in normal mode.\n");
 180:calypso/sim.c **** 	else
 181:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSCLKEN = 0 ==> SIM clock in standby mode.\n");
 182:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 183:calypso/sim.c **** 
 184:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_reserved)
 185:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_reserved = 1 ==> ETU period is 4*1/Fsclk.\n");
 186:calypso/sim.c **** 	else
 187:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_reserved = 0 ==> ETU period is CONFETUPERIOD.\n");
 188:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 189:calypso/sim.c **** 
 190:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFSCLKDIV)
 191:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSCLKDIV = 1 ==> SIM clock frequency is 13/8 Mhz.\n");
 192:calypso/sim.c **** 	else
 193:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSCLKDIV = 0 ==> SIM clock frequency is 13/4 Mhz.\n");
 194:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 195:calypso/sim.c **** 
 196:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFSCLKLEV)
 197:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSCLKLEV = 1 ==> SIM clock idle level is high.\n");
 198:calypso/sim.c **** 	else
 199:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSCLKLEV = 0 ==> SIM clock idle level is low.\n");
 200:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 201:calypso/sim.c **** 
 202:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFETUPERIOD)
 203:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFETUPERIOD = 1 ==> ETU period is 512/8*1/Fsclk.\n");
 204:calypso/sim.c **** 	else
 205:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFETUPERIOD = 0 ==> ETU period is 372/8*1/Fsclk.\n");
 206:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 207:calypso/sim.c **** 
 208:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFBYPASS)
 209:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFBYPASS = 1 ==> Hardware timers and start and stop sequences are by
 210:calypso/sim.c **** 	else
 211:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFBYPASS = 0 ==> Hardware timers and start and stop sequences are no
 212:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 213:calypso/sim.c **** 
 214:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFSVCCLEV)
 215:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSVCCLEV = 1 ==> SVCC Level is high (Only valid when CONFBYPASS = 1
 216:calypso/sim.c **** 	else
 217:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSVCCLEV = 0 ==> SVCC Level is low (Only valid when CONFBYPASS = 1)
 218:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 219:calypso/sim.c **** 
 220:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFSRSTLEV)
 221:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSRSTLEV = 1 ==> SRST Level is high (Only valid when CONFBYPASS = 1
 222:calypso/sim.c **** 	else
 223:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSRSTLEV = 0 ==> SRST Level is low (Only valid when CONFBYPASS = 1)
 224:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 225:calypso/sim.c **** 
 226:calypso/sim.c ****  	printf("  |  |-REG_SIM_CONF1_CONFTRIG = 0x%x (FIFO trigger level)\n",(regVal >> REG_SIM_CONF1_CON
 227:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 228:calypso/sim.c **** 
 229:calypso/sim.c **** 	if(regVal & REG_SIM_CONF1_CONFSIOLOW)
 230:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSIOLOW = 1 ==> I/O is forced to low.\n");
 231:calypso/sim.c **** 	else
 232:calypso/sim.c **** 		puts("  |  |-REG_SIM_CONF1_CONFSIOLOW = 0\n");
 233:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 234:calypso/sim.c **** 
 235:calypso/sim.c **** 	regVal = readw(REG_SIM_CONF2);
 236:calypso/sim.c **** 	printf("  |-REG_SIM_CONF2 = %04x\n", regVal);
 237:calypso/sim.c ****  	printf("  |  |-REG_SIM_CONF2_CONFTFSIM = 0x%x (time delay for filtering of SIM_CD)\n",(regVal >> 
 238:calypso/sim.c ****  	printf("  |  |-REG_SIM_CONF2_CONFTDSIM = 0x%x (time delay for contact activation/deactivation)\n"
 239:calypso/sim.c ****  	printf("  |  |-REG_SIM_CONF2_CONFWAITI = 0x%x (CONFWAITI overflow wait time between two received 
 240:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 241:calypso/sim.c **** 
 242:calypso/sim.c **** 	regVal = readw(REG_SIM_IT);
 243:calypso/sim.c **** 	printf("  |-REG_SIM_IT = %04x\n", regVal);
 244:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 245:calypso/sim.c **** 
 246:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_NATR)
 247:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_NATR = 1 ==> No answer to reset!\n");
 248:calypso/sim.c **** 	else
 249:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_NATR = 0 ==> On read access to REG_SIM_IT.\n");
 250:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 251:calypso/sim.c **** 
 252:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_WT)
 253:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_WT = 1 ==> Character underflow!\n");
 254:calypso/sim.c **** 	else
 255:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_WT = 0 ==> On read access to REG_SIM_IT.\n");
 256:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 257:calypso/sim.c **** 
 258:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_OV)
 259:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_OV = 1 ==> Receive overflow!\n");
 260:calypso/sim.c **** 	else
 261:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_OV = 0 ==> On read access to REG_SIM_IT.\n");
 262:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 263:calypso/sim.c **** 
 264:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_TX)
 265:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_TX = 1 ==> Waiting for character to transmit...\n");
 266:calypso/sim.c **** 	else
 267:calypso/sim.c **** 	{
 268:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_TX = 0 ==> On write access to REG_SIM_DTX or on switching\n");
 269:calypso/sim.c **** 		puts("  |  |                           from transmit to receive mode (CONFTXRX bit)\n");
 270:calypso/sim.c **** 	}
 271:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 272:calypso/sim.c **** 
 273:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_RX)
 274:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_RX = 1 ==> Waiting characters to be read...\n");
 275:calypso/sim.c **** 	else
 276:calypso/sim.c **** 		puts("  |  |-REG_SIM_IT_SIM_RX = 0 ==> On read access to REG_SIM_DRX.\n");
 277:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 278:calypso/sim.c **** 
 279:calypso/sim.c **** 	regVal = readw(REG_SIM_DRX);
 280:calypso/sim.c **** 	printf("  |-REG_SIM_DRX = %04x\n", regVal);
 281:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 282:calypso/sim.c **** 
 283:calypso/sim.c ****  	printf("  |  |-REG_SIM_DRX_SIM_DRX = 0x%x (next data byte in FIFO available for reading)\n",(regV
 284:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 285:calypso/sim.c **** 
 286:calypso/sim.c **** 	if(regVal & REG_SIM_DRX_STATRXPAR)
 287:calypso/sim.c **** 		puts("  |  |-REG_SIM_DRX_STATRXPAR = 1 ==> Parity Ok.\n");
 288:calypso/sim.c **** 	else
 289:calypso/sim.c **** 		puts("  |  |-REG_SIM_DRX_STATRXPAR = 0 ==> Parity error!\n");
 290:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 291:calypso/sim.c **** 
 292:calypso/sim.c **** 	regVal = readw(REG_SIM_DTX);
 293:calypso/sim.c **** 	printf("  |-REG_SIM_DTX = %02x (next data byte to be transmitted)\n", regVal);
 294:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 295:calypso/sim.c **** 
 296:calypso/sim.c **** 	regVal = readw(REG_SIM_MASKIT);
 297:calypso/sim.c **** 	printf("  |-REG_SIM_MASKIT = %04x\n", regVal);
 298:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 299:calypso/sim.c **** 
 300:calypso/sim.c **** 	if(regVal & REG_SIM_MASKIT_MASK_SIM_NATR)
 301:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_NATR = 1 ==> No-answer-to-reset interrupt is masked.\n");
 302:calypso/sim.c **** 	else
 303:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_NATR = 0 ==> No-answer-to-reset interrupt is unmasked.\n");
 304:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 305:calypso/sim.c **** 
 306:calypso/sim.c **** 	if(regVal & REG_SIM_MASKIT_MASK_SIM_WT)
 307:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_WT = 1 ==> Character wait-time overflow interrupt is masked.
 308:calypso/sim.c **** 	else
 309:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_WT = 0 ==> Character wait-time overflow interrupt is unmaske
 310:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 311:calypso/sim.c **** 
 312:calypso/sim.c **** 	if(regVal & REG_SIM_MASKIT_MASK_SIM_OV)
 313:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_OV = 1 ==> Receive overflow interrupt is masked.\n");
 314:calypso/sim.c **** 	else
 315:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_OV = 0 ==> Receive overflow interrupt is unmasked.\n");
 316:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 317:calypso/sim.c **** 
 318:calypso/sim.c **** 	if(regVal & REG_SIM_MASKIT_MASK_SIM_TX)
 319:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_TX = 1 ==> Waiting characters to be transmit interrupt is ma
 320:calypso/sim.c **** 	else
 321:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_TX = 0 ==> Waiting characters to be transmit interrupt is un
 322:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 323:calypso/sim.c **** 
 324:calypso/sim.c **** 	if(regVal & REG_SIM_MASKIT_MASK_SIM_RX)
 325:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_RX = 1 ==> Waiting characters to be read interrupt is masked
 326:calypso/sim.c **** 	else
 327:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_RX = 0 ==> Waiting characters to be read interrupt is unmask
 328:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 329:calypso/sim.c **** 
 330:calypso/sim.c **** 	if(regVal & REG_SIM_MASKIT_MASK_SIM_CD)
 331:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_CD = 1 ==> SIM card insertion/extraction interrupt is masked
 332:calypso/sim.c **** 	else
 333:calypso/sim.c **** 		puts("  |  |-REG_SIM_MASKIT_MASK_SIM_CD = 0 ==> SIM card insertion/extraction interrupt is unmask
 334:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 335:calypso/sim.c **** 
 336:calypso/sim.c **** 	regVal = REG_SIM_IT_CD;
 337:calypso/sim.c **** 	printf("  |-REG_SIM_IT_CD = %04x\n", regVal);
 338:calypso/sim.c **** 	if(regVal & REG_SIM_IT_CD_IT_CD)
 339:calypso/sim.c **** 		puts("     |-REG_SIM_IT_CD_IT_CD = 1 ==> SIM card insertion/extraction interrupt is masked.\n");
 340:calypso/sim.c **** 	else
 341:calypso/sim.c **** 		puts("     |-REG_SIM_IT_CD_IT_CD = 0 ==> SIM card insertion/extraction interrupt is unmasked.\n")
 342:calypso/sim.c **** 	delay_ms(SIM_DEBUG_OUTPUTDELAY);
 343:calypso/sim.c **** #endif
 344:calypso/sim.c **** 	return;
 345:calypso/sim.c **** }
 346:calypso/sim.c **** 
 347:calypso/sim.c **** /* Receive raw data through the sim interface */
 348:calypso/sim.c **** int calypso_sim_receive(uint8_t *data, uint8_t len)
 349:calypso/sim.c **** {
 350:calypso/sim.c **** 	printd("Triggering SIM reception\n");
 351:calypso/sim.c **** 
 352:calypso/sim.c **** 	/* Prepare buffers and flags */
 353:calypso/sim.c **** 	rx_buffer = data;
 354:calypso/sim.c **** 	sim_rx_character_count = 0;
 355:calypso/sim.c **** 	rxDoneFlag = 0;
 356:calypso/sim.c **** 	sim_rx_max_character_count = len;
 357:calypso/sim.c **** 
 358:calypso/sim.c **** 	/* Switch I/O direction to input */
 359:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) & ~REG_SIM_CONF1_CONFTXRX, REG_SIM_CONF1);
 360:calypso/sim.c **** 
 361:calypso/sim.c **** 	/* Unmask the interrupts that are needed to perform this action */
 362:calypso/sim.c **** 	writew(~(REG_SIM_MASKIT_MASK_SIM_RX | REG_SIM_MASKIT_MASK_SIM_WT),
 363:calypso/sim.c **** 		REG_SIM_MASKIT);
 364:calypso/sim.c **** 
 365:calypso/sim.c **** 	return 0;
 366:calypso/sim.c **** }
 367:calypso/sim.c **** 
 368:calypso/sim.c **** /* Transmit raw data through the sim interface */
 369:calypso/sim.c **** int calypso_sim_transmit(uint8_t *data, int length)
 370:calypso/sim.c **** {
 371:calypso/sim.c **** 	printd("Triggering SIM transmission\n");
 372:calypso/sim.c **** 
 373:calypso/sim.c **** 	/* Prepare buffers and flags */
 374:calypso/sim.c **** 	tx_buffer = data;
 375:calypso/sim.c **** 	sim_tx_character_count = 0;
 376:calypso/sim.c **** 	txDoneFlag = 0;
 377:calypso/sim.c **** 	sim_tx_character_length = length;
 378:calypso/sim.c **** 
 379:calypso/sim.c **** 	/* Switch I/O direction to output */
 380:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) | REG_SIM_CONF1_CONFTXRX, REG_SIM_CONF1);
 381:calypso/sim.c **** 
 382:calypso/sim.c **** 	/* Unmask the interrupts that are needed to perform this action */
 383:calypso/sim.c **** 	writew(~(REG_SIM_MASKIT_MASK_SIM_TX), REG_SIM_MASKIT);
 384:calypso/sim.c **** 
 385:calypso/sim.c **** 	/* Transmit the first byte manually to start the interrupt cascade */
 386:calypso/sim.c **** 	writew(*tx_buffer,REG_SIM_DTX);
 387:calypso/sim.c **** 	tx_buffer++;
 388:calypso/sim.c **** 	sim_tx_character_count++;
 389:calypso/sim.c **** 
 390:calypso/sim.c **** 	return 0;
 391:calypso/sim.c **** }
 392:calypso/sim.c **** 
 393:calypso/sim.c **** 
 394:calypso/sim.c **** /* IRQ-Handler for simcard interface */
 395:calypso/sim.c **** void sim_irq_handler(enum irq_nr irq)
 396:calypso/sim.c **** {
  18              		.loc 1 396 0
  19              		.cfi_startproc
  20              		@ args = 0, pretend = 0, frame = 0
  21              		@ frame_needed = 0, uses_anonymous_args = 0
  22              		@ link register save eliminated.
  23              	.LVL0:
 397:calypso/sim.c **** 	int regVal = readw(REG_SIM_IT);
  24              		.loc 1 397 0
  25 0000 DC309FE5 		ldr	r3, .L7
  26 0004 B72F53E1 		ldrh	r2, [r3, #-247]
  27              	.LVL1:
 398:calypso/sim.c **** 
 399:calypso/sim.c **** 
 400:calypso/sim.c **** 	/* Display interrupt information */
 401:calypso/sim.c **** 	printd("SIM-ISR: ");
 402:calypso/sim.c **** 
 403:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_NATR) {
 404:calypso/sim.c **** 		printd(" No answer to reset!\n");
 405:calypso/sim.c **** 	}
 406:calypso/sim.c **** 
 407:calypso/sim.c **** 	/* Used by: calypso_sim_receive() to determine when the transmission
 408:calypso/sim.c **** 	 * is over
 409:calypso/sim.c **** 	 */
 410:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_WT) {
  28              		.loc 1 410 0
  29 0008 020012E3 		tst	r2, #2
 411:calypso/sim.c **** 		printd(" Character underflow!\n");
 412:calypso/sim.c **** 		rxDoneFlag = 1;
  30              		.loc 1 412 0
  31 000c D4309F15 		ldrne	r3, .L7+4
  32 0010 0110A013 		movne	r1, #1
  33 0014 00108315 		strne	r1, [r3, #0]
 413:calypso/sim.c **** 
 414:calypso/sim.c **** 	}
 415:calypso/sim.c **** 
 416:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_OV) {
 417:calypso/sim.c **** 		printd(" Receive overflow!\n");
 418:calypso/sim.c **** 	}
 419:calypso/sim.c **** 
 420:calypso/sim.c **** 	/* Used by: calypso_sim_transmit() to transmit the data */
 421:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_TX) {
  34              		.loc 1 421 0
  35 0018 080012E3 		tst	r2, #8
  36 001c 1500000A 		beq	.L3
 422:calypso/sim.c **** 		printd(" Waiting for transmit...\n");
 423:calypso/sim.c **** 		if(sim_tx_character_count >= sim_tx_character_length) {
  37              		.loc 1 423 0
  38 0020 C0309FE5 		ldr	r3, .L7+4
  39 0024 040093E5 		ldr	r0, [r3, #4]
  40              	.LVL2:
  41 0028 081093E5 		ldr	r1, [r3, #8]
  42 002c 010050E1 		cmp	r0, r1
 424:calypso/sim.c **** 			txDoneFlag = 1;
  43              		.loc 1 424 0
  44 0030 0110A0A3 		movge	r1, #1
  45 0034 0C1083A5 		strge	r1, [r3, #12]
 423:calypso/sim.c **** 		if(sim_tx_character_count >= sim_tx_character_length) {
  46              		.loc 1 423 0
  47 0038 0E0000AA 		bge	.L3
 425:calypso/sim.c **** 		} else {
 426:calypso/sim.c **** 			writew(*tx_buffer,REG_SIM_DTX);
  48              		.loc 1 426 0
  49 003c 100093E5 		ldr	r0, [r3, #16]
  50 0040 9C109FE5 		ldr	r1, .L7
  51 0044 01C0D0E4 		ldrb	ip, [r0], #1	@ zero_extendqisi2
  52 0048 B3CF41E1 		strh	ip, [r1, #-243]	@ movhi
 427:calypso/sim.c **** 			tx_buffer++;
  53              		.loc 1 427 0
  54 004c 100083E5 		str	r0, [r3, #16]
 428:calypso/sim.c **** 			sim_tx_character_count++;
  55              		.loc 1 428 0
  56 0050 040093E5 		ldr	r0, [r3, #4]
  57 0054 010080E2 		add	r0, r0, #1
  58 0058 040083E5 		str	r0, [r3, #4]
 429:calypso/sim.c **** 
 430:calypso/sim.c **** 			/* its essential to immediately switch to RX after TX
 431:calypso/sim.c **** 			 * is done
 432:calypso/sim.c **** 			 */
 433:calypso/sim.c **** 			if(sim_tx_character_count >= sim_tx_character_length) {
  59              		.loc 1 433 0
  60 005c 040093E5 		ldr	r0, [r3, #4]
  61 0060 083093E5 		ldr	r3, [r3, #8]
  62 0064 030050E1 		cmp	r0, r3
 434:calypso/sim.c **** 				/* TODO: set a proper delay here, 4 is to
 435:calypso/sim.c **** 				   long if not debugging and no delay is too
 436:calypso/sim.c **** 				   short */
 437:calypso/sim.c **** //				delay_ms(1);
 438:calypso/sim.c **** 				/* Switch I/O direction to input */
 439:calypso/sim.c **** 				writew(readw(REG_SIM_CONF1) &
  63              		.loc 1 439 0
  64 0068 BB0F51A1 		ldrgeh	r0, [r1, #-251]
  65 006c 78309FA5 		ldrge	r3, .L7+8
  66 0070 033000A0 		andge	r3, r0, r3
  67 0074 BB3F41A1 		strgeh	r3, [r1, #-251]	@ movhi
  68              	.L3:
 440:calypso/sim.c **** 					~REG_SIM_CONF1_CONFTXRX, REG_SIM_CONF1);
 441:calypso/sim.c **** 			}
 442:calypso/sim.c **** 		}
 443:calypso/sim.c **** 	}
 444:calypso/sim.c **** 
 445:calypso/sim.c **** 	/* Used by: calypso_sim_receive() to receive the incoming data */
 446:calypso/sim.c **** 	if(regVal & REG_SIM_IT_SIM_RX) {
  69              		.loc 1 446 0
  70 0078 100012E3 		tst	r2, #16
  71 007c 1EFF2F01 		bxeq	lr
  72              	.LBB38:
 447:calypso/sim.c **** 		uint8_t ch = (uint8_t) (readw(REG_SIM_DRX) & 0xFF);
  73              		.loc 1 447 0
  74 0080 5C309FE5 		ldr	r3, .L7
  75 0084 B51F53E1 		ldrh	r1, [r3, #-245]
  76 0088 FF1001E2 		and	r1, r1, #255
  77              	.LVL3:
 448:calypso/sim.c **** 
 449:calypso/sim.c **** 		/* ignore NULL procedure byte */
 450:calypso/sim.c **** 		if(ch == 0x60 && sim_ignore_waiting_char) {
  78              		.loc 1 450 0
  79 008c 600051E3 		cmp	r1, #96
  80 0090 0300001A 		bne	.L6
  81              		.loc 1 450 0 is_stmt 0 discriminator 1
  82 0094 4C309FE5 		ldr	r3, .L7+4
  83 0098 1430D3E5 		ldrb	r3, [r3, #20]	@ zero_extendqisi2
  84 009c 000053E3 		cmp	r3, #0
  85 00a0 1EFF2F11 		bxne	lr
  86              	.L6:
 451:calypso/sim.c **** 			printd(" 0x60 received...\n");
 452:calypso/sim.c **** 			return;
 453:calypso/sim.c **** 		}
 454:calypso/sim.c **** 
 455:calypso/sim.c **** 		printd(" Waiting for read (%02X)...\n", ch);
 456:calypso/sim.c **** 
 457:calypso/sim.c **** 		/* Increment character count - this is what
 458:calypso/sim.c **** 		 * calypso_sim_receive() hands back
 459:calypso/sim.c **** 		 */
 460:calypso/sim.c **** 		sim_rx_character_count++;
  87              		.loc 1 460 0 is_stmt 1
  88 00a4 3C309FE5 		ldr	r3, .L7+4
  89 00a8 182093E5 		ldr	r2, [r3, #24]
  90              	.LVL4:
  91 00ac 012082E2 		add	r2, r2, #1
  92 00b0 182083E5 		str	r2, [r3, #24]
 461:calypso/sim.c **** 
 462:calypso/sim.c **** 		/* Read byte from rx-fifo and write it to the issued buffer */
 463:calypso/sim.c **** 		*rx_buffer = ch;
  93              		.loc 1 463 0
  94 00b4 1C2093E5 		ldr	r2, [r3, #28]
  95 00b8 0110C2E4 		strb	r1, [r2], #1
 464:calypso/sim.c **** 		rx_buffer++;
  96              		.loc 1 464 0
  97 00bc 1C2083E5 		str	r2, [r3, #28]
 465:calypso/sim.c **** 
 466:calypso/sim.c **** 		/* to maximise SIM access speed, stop waiting after
 467:calypso/sim.c **** 		   all the expected characters have been received. */
 468:calypso/sim.c **** 		if (sim_rx_max_character_count
  98              		.loc 1 468 0
  99 00c0 202093E5 		ldr	r2, [r3, #32]
 100 00c4 000052E3 		cmp	r2, #0
 101 00c8 1EFF2F01 		bxeq	lr
 469:calypso/sim.c **** 		 && sim_rx_character_count >= sim_rx_max_character_count) {
 102              		.loc 1 469 0
 103 00cc 181093E5 		ldr	r1, [r3, #24]
 104              	.LVL5:
 105 00d0 202093E5 		ldr	r2, [r3, #32]
 106 00d4 020051E1 		cmp	r1, r2
 470:calypso/sim.c **** 			printd(" Max characters received!\n");
 471:calypso/sim.c **** 			rxDoneFlag = 1;
 107              		.loc 1 471 0
 108 00d8 0120A0A3 		movge	r2, #1
 109 00dc 002083A5 		strge	r2, [r3, #0]
 110 00e0 1EFF2FE1 		bx	lr
 111              	.L8:
 112              		.align	2
 113              	.L7:
 114 00e4 FF00FEFF 		.word	-130817
 115 00e8 00000000 		.word	.LANCHOR0
 116 00ec FBFF0000 		.word	65531
 117              	.LBE38:
 118              		.cfi_endproc
 119              	.LFE39:
 121              		.section	.text.calypso_sim_regdump,"ax",%progbits
 122              		.align	2
 123              		.global	calypso_sim_regdump
 125              	calypso_sim_regdump:
 126              	.LFB36:
  85:calypso/sim.c **** {
 127              		.loc 1 85 0
 128              		.cfi_startproc
 129              		@ args = 0, pretend = 0, frame = 0
 130              		@ frame_needed = 0, uses_anonymous_args = 0
 131              		@ link register save eliminated.
 345:calypso/sim.c **** }
 132              		.loc 1 345 0
 133 0000 1EFF2FE1 		bx	lr
 134              		.cfi_endproc
 135              	.LFE36:
 137              		.section	.text.calypso_sim_receive,"ax",%progbits
 138              		.align	2
 139              		.global	calypso_sim_receive
 141              	calypso_sim_receive:
 142              	.LFB37:
 349:calypso/sim.c **** {
 143              		.loc 1 349 0
 144              		.cfi_startproc
 145              		@ args = 0, pretend = 0, frame = 0
 146              		@ frame_needed = 0, uses_anonymous_args = 0
 147              		@ link register save eliminated.
 148              	.LVL6:
 353:calypso/sim.c **** 	rx_buffer = data;
 149              		.loc 1 353 0
 150 0000 34309FE5 		ldr	r3, .L11
 349:calypso/sim.c **** {
 151              		.loc 1 349 0
 152 0004 FF1001E2 		and	r1, r1, #255
 153              	.LVL7:
 353:calypso/sim.c **** 	rx_buffer = data;
 154              		.loc 1 353 0
 155 0008 1C0083E5 		str	r0, [r3, #28]
 354:calypso/sim.c **** 	sim_rx_character_count = 0;
 156              		.loc 1 354 0
 157 000c 0000A0E3 		mov	r0, #0
 158              	.LVL8:
 159 0010 180083E5 		str	r0, [r3, #24]
 355:calypso/sim.c **** 	rxDoneFlag = 0;
 160              		.loc 1 355 0
 161 0014 000083E5 		str	r0, [r3, #0]
 356:calypso/sim.c **** 	sim_rx_max_character_count = len;
 162              		.loc 1 356 0
 163 0018 201083E5 		str	r1, [r3, #32]
 359:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) & ~REG_SIM_CONF1_CONFTXRX, REG_SIM_CONF1);
 164              		.loc 1 359 0
 165 001c 1C309FE5 		ldr	r3, .L11+4
 166 0020 1C209FE5 		ldr	r2, .L11+8
 167 0024 BB1F53E1 		ldrh	r1, [r3, #-251]
 168 0028 022001E0 		and	r2, r1, r2
 169 002c BB2F43E1 		strh	r2, [r3, #-251]	@ movhi
 362:calypso/sim.c **** 	writew(~(REG_SIM_MASKIT_MASK_SIM_RX | REG_SIM_MASKIT_MASK_SIM_WT),
 170              		.loc 1 362 0
 171 0030 1220E0E3 		mvn	r2, #18	@ movhi
 172 0034 B12F43E1 		strh	r2, [r3, #-241]	@ movhi
 366:calypso/sim.c **** }
 173              		.loc 1 366 0
 174 0038 1EFF2FE1 		bx	lr
 175              	.L12:
 176              		.align	2
 177              	.L11:
 178 003c 00000000 		.word	.LANCHOR0
 179 0040 FF00FEFF 		.word	-130817
 180 0044 FBFF0000 		.word	65531
 181              		.cfi_endproc
 182              	.LFE37:
 184              		.section	.text.calypso_sim_transmit,"ax",%progbits
 185              		.align	2
 186              		.global	calypso_sim_transmit
 188              	calypso_sim_transmit:
 189              	.LFB38:
 370:calypso/sim.c **** {
 190              		.loc 1 370 0
 191              		.cfi_startproc
 192              		@ args = 0, pretend = 0, frame = 0
 193              		@ frame_needed = 0, uses_anonymous_args = 0
 194              		@ link register save eliminated.
 195              	.LVL9:
 375:calypso/sim.c **** 	sim_tx_character_count = 0;
 196              		.loc 1 375 0
 197 0000 44309FE5 		ldr	r3, .L14
 198 0004 00C0A0E3 		mov	ip, #0
 199 0008 04C083E5 		str	ip, [r3, #4]
 380:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) | REG_SIM_CONF1_CONFTXRX, REG_SIM_CONF1);
 200              		.loc 1 380 0
 201 000c 3C209FE5 		ldr	r2, .L14+4
 376:calypso/sim.c **** 	txDoneFlag = 0;
 202              		.loc 1 376 0
 203 0010 0CC083E5 		str	ip, [r3, #12]
 377:calypso/sim.c **** 	sim_tx_character_length = length;
 204              		.loc 1 377 0
 205 0014 081083E5 		str	r1, [r3, #8]
 380:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) | REG_SIM_CONF1_CONFTXRX, REG_SIM_CONF1);
 206              		.loc 1 380 0
 207 0018 BB1F52E1 		ldrh	r1, [r2, #-251]
 208              	.LVL10:
 209 001c 041081E3 		orr	r1, r1, #4
 210 0020 BB1F42E1 		strh	r1, [r2, #-251]	@ movhi
 383:calypso/sim.c **** 	writew(~(REG_SIM_MASKIT_MASK_SIM_TX), REG_SIM_MASKIT);
 211              		.loc 1 383 0
 212 0024 0810E0E3 		mvn	r1, #8	@ movhi
 213 0028 B11F42E1 		strh	r1, [r2, #-241]	@ movhi
 386:calypso/sim.c **** 	writew(*tx_buffer,REG_SIM_DTX);
 214              		.loc 1 386 0
 215 002c 0110D0E4 		ldrb	r1, [r0], #1	@ zero_extendqisi2
 216              	.LVL11:
 217 0030 B31F42E1 		strh	r1, [r2, #-243]	@ movhi
 388:calypso/sim.c **** 	sim_tx_character_count++;
 218              		.loc 1 388 0
 219 0034 042093E5 		ldr	r2, [r3, #4]
 220 0038 012082E2 		add	r2, r2, #1
 387:calypso/sim.c **** 	tx_buffer++;
 221              		.loc 1 387 0
 222 003c 100083E5 		str	r0, [r3, #16]
 388:calypso/sim.c **** 	sim_tx_character_count++;
 223              		.loc 1 388 0
 224 0040 042083E5 		str	r2, [r3, #4]
 391:calypso/sim.c **** }
 225              		.loc 1 391 0
 226 0044 0C00A0E1 		mov	r0, ip
 227              	.LVL12:
 228 0048 1EFF2FE1 		bx	lr
 229              	.L15:
 230              		.align	2
 231              	.L14:
 232 004c 00000000 		.word	.LANCHOR0
 233 0050 FF00FEFF 		.word	-130817
 234              		.cfi_endproc
 235              	.LFE38:
 237              		.section	.text.sim_apdu,"ax",%progbits
 238              		.align	2
 239              		.global	sim_apdu
 241              	sim_apdu:
 242              	.LFB40:
 472:calypso/sim.c **** 		}
 473:calypso/sim.c **** 	}
 474:calypso/sim.c **** }
 475:calypso/sim.c **** 
 476:calypso/sim.c **** /* simm command from layer 23 */
 477:calypso/sim.c **** void sim_apdu(uint16_t len, uint8_t *data)
 478:calypso/sim.c **** {
 243              		.loc 1 478 0
 244              		.cfi_startproc
 245              		@ args = 0, pretend = 0, frame = 0
 246              		@ frame_needed = 0, uses_anonymous_args = 0
 247              	.LVL13:
 248 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 249              	.LCFI0:
 250              		.cfi_def_cfa_offset 12
 479:calypso/sim.c **** 	if (sim_state != SIM_STATE_IDLE) {
 251              		.loc 1 479 0
 252 0004 34409FE5 		ldr	r4, .L18
 253              		.cfi_offset 14, -4
 254              		.cfi_offset 5, -8
 255              		.cfi_offset 4, -12
 256 0008 2430D4E5 		ldrb	r3, [r4, #36]	@ zero_extendqisi2
 478:calypso/sim.c **** {
 257              		.loc 1 478 0
 258 000c 0008A0E1 		mov	r0, r0, asl #16
 259              	.LVL14:
 260              		.loc 1 479 0
 261 0010 000053E3 		cmp	r3, #0
 478:calypso/sim.c **** {
 262              		.loc 1 478 0
 263 0014 2058A0E1 		mov	r5, r0, lsr #16
 264              		.loc 1 479 0
 265 0018 0200000A 		beq	.L17
 480:calypso/sim.c **** 		puts("Sim reader currently busy...\n");
 266              		.loc 1 480 0
 267 001c 20009FE5 		ldr	r0, .L18+4
 481:calypso/sim.c **** 		return;
 482:calypso/sim.c **** 	}
 483:calypso/sim.c **** 	memcpy(sim_data, data, len);
 484:calypso/sim.c **** 	sim_len = len;
 485:calypso/sim.c **** }
 268              		.loc 1 485 0
 269 0020 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 480:calypso/sim.c **** 		puts("Sim reader currently busy...\n");
 270              		.loc 1 480 0
 271 0024 FEFFFFEA 		b	puts
 272              	.LVL15:
 273              	.L17:
 483:calypso/sim.c **** 	memcpy(sim_data, data, len);
 274              		.loc 1 483 0
 275 0028 280084E2 		add	r0, r4, #40
 276 002c 0520A0E1 		mov	r2, r5
 277 0030 FEFFFFEB 		bl	memcpy
 278              	.LVL16:
 484:calypso/sim.c **** 	sim_len = len;
 279              		.loc 1 484 0
 280 0034 4A3FA0E3 		mov	r3, #296
 281 0038 B35084E1 		strh	r5, [r4, r3]	@ movhi
 282              		.loc 1 485 0
 283 003c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 284              	.L19:
 285              		.align	2
 286              	.L18:
 287 0040 00000000 		.word	.LANCHOR0
 288 0044 00000000 		.word	.LC0
 289              		.cfi_endproc
 290              	.LFE40:
 292              		.section	.text.sim_handler,"ax",%progbits
 293              		.align	2
 294              		.global	sim_handler
 296              	sim_handler:
 297              	.LFB41:
 486:calypso/sim.c **** 
 487:calypso/sim.c **** /* handling sim events */
 488:calypso/sim.c **** void sim_handler(void)
 489:calypso/sim.c **** {
 298              		.loc 1 489 0
 299              		.cfi_startproc
 300              		@ args = 0, pretend = 0, frame = 0
 301              		@ frame_needed = 0, uses_anonymous_args = 0
 302 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 303              	.LCFI1:
 304              		.cfi_def_cfa_offset 16
 490:calypso/sim.c **** 	static struct msgb *msg;
 491:calypso/sim.c **** 	struct l1ctl_hdr *l1h;
 492:calypso/sim.c **** 	static uint8_t mode;
 493:calypso/sim.c **** 	static uint8_t *response;
 494:calypso/sim.c **** 	static uint16_t length;
 495:calypso/sim.c **** 
 496:calypso/sim.c **** 	switch (sim_state) {
 305              		.loc 1 496 0
 306 0004 64349FE5 		ldr	r3, .L53
 307 0008 2430D3E5 		ldrb	r3, [r3, #36]	@ zero_extendqisi2
 308 000c 050053E3 		cmp	r3, #5
 309 0010 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 310 0014 140100EA 		b	.L20
 311              		.cfi_offset 14, -4
 312              		.cfi_offset 6, -8
 313              		.cfi_offset 5, -12
 314              		.cfi_offset 4, -16
 315              	.L28:
 316 0018 30000000 		.word	.L22
 317 001c 70010000 		.word	.L23
 318 0020 DC010000 		.word	.L24
 319 0024 3C020000 		.word	.L25
 320 0028 FC020000 		.word	.L26
 321 002c A8020000 		.word	.L27
 322              	.L22:
 497:calypso/sim.c **** 	case SIM_STATE_IDLE:
 498:calypso/sim.c **** 		if (!sim_len)
 323              		.loc 1 498 0
 324 0030 38349FE5 		ldr	r3, .L53
 325 0034 4A2FA0E3 		mov	r2, #296
 326 0038 B21093E1 		ldrh	r1, [r3, r2]
 327 003c 000051E3 		cmp	r1, #0
 328 0040 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 499:calypso/sim.c **** 			break; /* wait for SIM command */
 500:calypso/sim.c **** 		/* check if instructions expects a response */
 501:calypso/sim.c **** 		if (/* GET RESPONSE needs SIM_APDU_GET */
 502:calypso/sim.c **** 		    (sim_len == 5 && sim_data[0] == SIM_CLASS &&
 329              		.loc 1 502 0
 330 0044 B22093E1 		ldrh	r2, [r3, r2]
 501:calypso/sim.c **** 		if (/* GET RESPONSE needs SIM_APDU_GET */
 331              		.loc 1 501 0
 332 0048 050052E3 		cmp	r2, #5
 333 004c 0B00001A 		bne	.L29
 334              		.loc 1 502 0
 335 0050 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 336 0054 A00052E3 		cmp	r2, #160
 337 0058 0800001A 		bne	.L29
 338              		.loc 1 502 0 is_stmt 0 discriminator 1
 339 005c 2920D3E5 		ldrb	r2, [r3, #41]	@ zero_extendqisi2
 340 0060 C00052E3 		cmp	r2, #192
 341 0064 0500001A 		bne	.L29
 503:calypso/sim.c **** 		     sim_data[1] == SIM_GET_RESPONSE && sim_data[2] == 0x00 &&
 342              		.loc 1 503 0 is_stmt 1
 343 0068 2A20D3E5 		ldrb	r2, [r3, #42]	@ zero_extendqisi2
 344 006c 000052E3 		cmp	r2, #0
 345 0070 0200001A 		bne	.L29
 346              		.loc 1 503 0 is_stmt 0 discriminator 1
 347 0074 2B30D3E5 		ldrb	r3, [r3, #43]	@ zero_extendqisi2
 348 0078 000053E3 		cmp	r3, #0
 349 007c 0B00000A 		beq	.L30
 350              	.L29:
 504:calypso/sim.c **** 		     sim_data[3] == 0x00) ||
 505:calypso/sim.c **** 		    /* READ BINARY/RECORD needs SIM_APDU_GET */
 506:calypso/sim.c **** 		     (sim_len >= 5 && sim_data[0] == SIM_CLASS &&
 351              		.loc 1 506 0 is_stmt 1
 352 0080 E8339FE5 		ldr	r3, .L53
 353 0084 4A2FA0E3 		mov	r2, #296
 354 0088 B22093E1 		ldrh	r2, [r3, r2]
 504:calypso/sim.c **** 		     sim_data[3] == 0x00) ||
 355              		.loc 1 504 0
 356 008c 040052E3 		cmp	r2, #4
 357 0090 0800009A 		bls	.L31
 358              		.loc 1 506 0
 359 0094 2820D3E5 		ldrb	r2, [r3, #40]	@ zero_extendqisi2
 360 0098 A00052E3 		cmp	r2, #160
 361 009c 0500001A 		bne	.L31
 507:calypso/sim.c **** 		      (sim_data[1] == SIM_READ_BINARY ||
 362              		.loc 1 507 0 discriminator 1
 363 00a0 2930D3E5 		ldrb	r3, [r3, #41]	@ zero_extendqisi2
 506:calypso/sim.c **** 		     (sim_len >= 5 && sim_data[0] == SIM_CLASS &&
 364              		.loc 1 506 0 discriminator 1
 365 00a4 B00053E3 		cmp	r3, #176
 366 00a8 B2005313 		cmpne	r3, #178
 367 00ac 0100001A 		bne	.L31
 368              	.L30:
 508:calypso/sim.c **** 		       sim_data[1] == SIM_READ_RECORD)))
 509:calypso/sim.c **** 			mode = SIM_APDU_GET;
 369              		.loc 1 509 0
 370 00b0 0120A0E3 		mov	r2, #1
 371 00b4 000000EA 		b	.L47
 372              	.L31:
 510:calypso/sim.c **** 		else
 511:calypso/sim.c **** 			mode = SIM_APDU_PUT;
 373              		.loc 1 511 0
 374 00b8 0020A0E3 		mov	r2, #0
 375              	.L47:
 376 00bc AC339FE5 		ldr	r3, .L53
 377 00c0 2A21C3E5 		strb	r2, [r3, #298]
 512:calypso/sim.c **** 
 513:calypso/sim.c **** 		length = sim_data[4];
 378              		.loc 1 513 0
 379 00c4 A4339FE5 		ldr	r3, .L53
 380 00c8 2C10D3E5 		ldrb	r1, [r3, #44]	@ zero_extendqisi2
 381 00cc 4B2FA0E3 		mov	r2, #300
 382 00d0 B21083E1 		strh	r1, [r3, r2]	@ movhi
 383              	.LVL17:
 384              	.LBB39:
 385              	.LBB40:
 386              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 189:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 190:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint8 value to the end of the message
 191:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 192:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 8bit byte to be appended
 193:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 194:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u8(struct msgb *msgb, uint8_t word)
 195:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 196:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 1);
 197:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word & 0xFF;
 198:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 199:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 200:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint16 value to the end of the message
 201:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 202:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 16bit byte to be appended
 203:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 204:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u16(struct msgb *msgb, uint16_t word)
 205:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 206:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 2);
 207:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 8 & 0xFF;
 208:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word & 0xFF;
 209:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 210:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 211:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append a uint32 value to the end of the message
 212:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 213:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] word unsigned 32bit byte to be appended
 214:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 215:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_put_u32(struct msgb *msgb, uint32_t word)
 216:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 217:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_put(msgb, 4);
 218:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[0] = word >> 24 & 0xFF;
 219:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[1] = word >> 16 & 0xFF;
 220:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[2] = word >> 8 & 0xFF;
 221:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	space[3] = word & 0xFF;
 222:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 223:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 224:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove data from end of message
 225:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 226:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to remove from end
 227:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 228:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_get(struct msgb *msgb, unsigned int len)
 229:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 230:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->data - len;
 231:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_length(msgb) < len)
 232:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "msgb too small to get %u (len %u)\n",
 233:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   len, msgb_length(msgb));
 234:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail -= len;
 235:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 236:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 237:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 238:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from end of message
 239:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 240:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 241:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 242:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_get_u8(struct msgb *msgb)
 243:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 244:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 1);
 245:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 246:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 247:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from end of message
 248:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 249:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 250:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 251:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_get_u16(struct msgb *msgb)
 252:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 253:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 2);
 254:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 255:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 256:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from end of message
 257:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 258:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 259:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 260:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_get_u32(struct msgb *msgb)
 261:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 262:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_get(msgb, 4);
 263:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 264:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 265:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 266:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief prepend (push) some data to start of message
 267:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 268:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to pre-pend
 269:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to newly added portion at start of \a msgb
 270:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 271:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further
 272:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * to the front (by \a len bytes), thereby enlarging the message by \a
 273:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes.
 274:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 275:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to the newly added section in the
 276:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * beginning of the message.  It can be used to fill/copy data into it.
 277:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 278:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_push(struct msgb *msgb, unsigned int len)
 279:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 280:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_headroom(msgb) < (int) len)
 281:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough headroom msgb_push (%u < %u)\n",
 282:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_headroom(msgb), len);
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 284:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 285:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data;
 286:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 287:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove (pull) a header from the front of the message buffer
 288:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 289:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of octets to be pulled
 290:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to new start of msgb
 291:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 292:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function moves the \a data pointer of the \ref msgb further back
 293:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * in the message, thereby shrinking the size of the message by \a len
 294:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * bytes.
 295:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 296:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_pull(struct msgb *msgb, unsigned int len)
 297:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 300:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 301:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 302:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint8 from front of message
 303:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 304:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 8bit value taken from end of msgb
 305:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 306:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint8_t msgb_pull_u8(struct msgb *msgb)
 307:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 308:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 1) - 1;
 309:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0];
 310:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 311:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint16 from front of message
 312:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 313:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 16bit value taken from end of msgb
 314:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 315:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint16_t msgb_pull_u16(struct msgb *msgb)
 316:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 317:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 2) - 2;
 318:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 8 | space[1];
 319:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 320:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief remove uint32 from front of message
 321:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 322:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 32bit value taken from end of msgb
 323:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 324:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline uint32_t msgb_pull_u32(struct msgb *msgb)
 325:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 326:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint8_t *space = msgb_pull(msgb, 4) - 4;
 327:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return space[0] << 24 | space[1] << 16 | space[2] << 8 | space[3];
 328:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 329:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 330:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Increase headroom of empty msgb, reducing the tailroom
 331:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 332:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len amount of extra octets to be reserved as headroom
 333:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 334:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function reserves some memory at the beginning of the underlying
 335:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer.  The idea is to reserve space in case further headers
 336:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * have to be pushed to the \ref msgb during further processing.
 337:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 338:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * Calling this function leads to undefined reusults if it is called on
 339:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * a non-empty \ref msgb.
 340:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 341:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline void msgb_reserve(struct msgb *msg, int len)
 342:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 345:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 346:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 347:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given absolute length
 348:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msg message buffer
 349:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len new total length of buffer
 350:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 351:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 352:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_trim(struct msgb *msg, int len)
 353:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 354:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (len > msg->data_len)
 355:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		return -1;
 356:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 357:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->len = len;
 358:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail = msg->data + len;
 359:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 360:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return 0;
 361:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 362:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 363:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Trim the msgb to a given layer3 length
 364:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \pram[in] msg message buffer
 365:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] l3len new layer3 length
 366:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns 0 in case of success, negative in case of error
 367:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 368:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_l3trim(struct msgb *msg, int l3len)
 369:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 370:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb_trim(msg, (msg->l3h - msg->data) + l3len);
 371:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 372:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 373:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Allocate message buffer with specified headroom
 374:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] size size in bytes, including headroom
 375:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] headroom headroom in bytes
 376:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] name human-readable name
 377:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns allocated message buffer with specified headroom
 378:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 379:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function is a convenience wrapper around \ref msgb_alloc
 380:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * followed by \ref msgb_reserve in order to create a new \ref msgb with
 381:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * user-specified amount of headroom.
 382:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 383:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline struct msgb *msgb_alloc_headroom(int size, int headroom,
 384:../../shared/libosmocore/include/osmocom/core/msgb.h **** 						const char *name)
 385:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 386:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_static_assert(size > headroom, headroom_bigger);
 387:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 388:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct msgb *msg = msgb_alloc(size, name);
 387              		.loc 2 388 0
 388 00d4 010CA0E3 		mov	r0, #256
 389 00d8 94139FE5 		ldr	r1, .L53+4
 390 00dc FEFFFFEB 		bl	msgb_alloc
 391              	.LVL18:
 389:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msg)
 392              		.loc 2 389 0
 393 00e0 004050E2 		subs	r4, r0, #0
 394 00e4 0500000A 		beq	.L33
 395              	.LVL19:
 396              	.LBB41:
 397              	.LBB42:
 343:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->data += len;
 398              		.loc 2 343 0
 399 00e8 403094E5 		ldr	r3, [r4, #64]
 400 00ec 083083E2 		add	r3, r3, #8
 401 00f0 403084E5 		str	r3, [r4, #64]
 344:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msg->tail += len;
 402              		.loc 2 344 0
 403 00f4 3C3094E5 		ldr	r3, [r4, #60]
 404 00f8 083083E2 		add	r3, r3, #8
 405 00fc 3C3084E5 		str	r3, [r4, #60]
 406              	.LVL20:
 407              	.L33:
 408              	.LBE42:
 409              	.LBE41:
 410              	.LBE40:
 411              	.LBE39:
 514:calypso/sim.c **** 
 515:calypso/sim.c **** 		/* allocate space for expected response */
 516:calypso/sim.c **** 		msg = msgb_alloc_headroom(256, L3_MSG_HEAD
 412              		.loc 1 516 0
 413 0100 68339FE5 		ldr	r3, .L53
 517:calypso/sim.c **** 					+ sizeof(struct l1ctl_hdr), "l1ctl1");
 518:calypso/sim.c **** 		response = msgb_put(msg, length + 2 + 1);
 414              		.loc 1 518 0
 415 0104 4B2FA0E3 		mov	r2, #300
 416 0108 B25093E1 		ldrh	r5, [r3, r2]
 516:calypso/sim.c **** 		msg = msgb_alloc_headroom(256, L3_MSG_HEAD
 417              		.loc 1 516 0
 418 010c 304183E5 		str	r4, [r3, #304]
 419              	.LBB43:
 420              	.LBB45:
 421              	.LBB47:
 422              	.LBB49:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 423              		.loc 2 152 0
 424 0110 382094E5 		ldr	r2, [r4, #56]
 425 0114 B433D4E1 		ldrh	r3, [r4, #52]
 426              	.LBE49:
 427              	.LBE47:
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 428              		.loc 2 181 0
 429 0118 3C6094E5 		ldr	r6, [r4, #60]
 430              	.LBB46:
 431              	.LBB48:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 432              		.loc 2 152 0
 433 011c 032082E0 		add	r2, r2, r3
 434              	.LBE48:
 435              	.LBE46:
 436              	.LBE45:
 437              	.LBE43:
 438              		.loc 1 518 0
 439 0120 035085E2 		add	r5, r5, #3
 440              	.LVL21:
 441              	.LBB54:
 442              	.LBB52:
 443              	.LBB51:
 444              	.LBB50:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 445              		.loc 2 152 0
 446 0124 022066E0 		rsb	r2, r6, r2
 447              	.LBE50:
 448              	.LBE51:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 449              		.loc 2 182 0
 450 0128 050052E1 		cmp	r2, r5
 451              	.LVL22:
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 452              		.loc 2 183 0
 453 012c 44039FB5 		ldrlt	r0, .L53+8
 454              	.LVL23:
 455 0130 0410A0B1 		movlt	r1, r4
 456 0134 0530A0B1 		movlt	r3, r5
 457 0138 FEFFFFBB 		bllt	osmo_panic
 458              	.LVL24:
 459              	.L34:
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 460              		.loc 2 185 0
 461 013c 3C3094E5 		ldr	r3, [r4, #60]
 462 0140 053083E0 		add	r3, r3, r5
 463 0144 3C3084E5 		str	r3, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 464              		.loc 2 186 0
 465 0148 B633D4E1 		ldrh	r3, [r4, #54]
 466              	.LBE52:
 467              	.LBE54:
 468              		.loc 1 518 0
 469 014c 1C039FE5 		ldr	r0, .L53
 470              	.LBB55:
 471              	.LBB44:
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 472              		.loc 2 186 0
 473 0150 035085E0 		add	r5, r5, r3
 474              	.LVL25:
 475              	.LBE44:
 476              	.LBE55:
 519:calypso/sim.c **** 
 520:calypso/sim.c **** 		sim_state = SIM_STATE_TX_HEADER;
 477              		.loc 1 520 0
 478 0154 0130A0E3 		mov	r3, #1
 518:calypso/sim.c **** 		response = msgb_put(msg, length + 2 + 1);
 479              		.loc 1 518 0
 480 0158 346180E5 		str	r6, [r0, #308]
 481              		.loc 1 520 0
 482 015c 2430C0E5 		strb	r3, [r0, #36]
 483              	.LBB56:
 484              	.LBB53:
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 485              		.loc 2 186 0
 486 0160 B653C4E1 		strh	r5, [r4, #54]	@ movhi
 487              	.LBE53:
 488              	.LBE56:
 521:calypso/sim.c **** 
 522:calypso/sim.c **** 		/* send APDU header */
 523:calypso/sim.c **** 		calypso_sim_transmit(sim_data, 5);
 489              		.loc 1 523 0
 490 0164 280080E2 		add	r0, r0, #40
 491 0168 0510A0E3 		mov	r1, #5
 492 016c 4B0000EA 		b	.L50
 493              	.LVL26:
 494              	.L23:
 524:calypso/sim.c **** 		break;
 525:calypso/sim.c **** 	case SIM_STATE_TX_HEADER:
 526:calypso/sim.c **** 		if (!txDoneFlag)
 495              		.loc 1 526 0
 496 0170 F8329FE5 		ldr	r3, .L53
 497 0174 0C2093E5 		ldr	r2, [r3, #12]
 498 0178 000052E3 		cmp	r2, #0
 499 017c 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 527:calypso/sim.c **** 			break; /* wait until header is transmitted */
 528:calypso/sim.c **** 		/* Disable all interrupt driven functions */
 529:calypso/sim.c **** 		writew(0xFF, REG_SIM_MASKIT);
 500              		.loc 1 529 0
 501 0180 F4229FE5 		ldr	r2, .L53+12
 502 0184 FF10A0E3 		mov	r1, #255	@ movhi
 503 0188 B11F42E1 		strh	r1, [r2, #-241]	@ movhi
 530:calypso/sim.c **** 		/* Case 1: No input, No Output */
 531:calypso/sim.c **** 		if (length == 0) {
 504              		.loc 1 531 0
 505 018c 4B2FA0E3 		mov	r2, #300
 506 0190 B21093E1 		ldrh	r1, [r3, r2]
 507 0194 000051E3 		cmp	r1, #0
 532:calypso/sim.c **** 			sim_state = SIM_STATE_RX_STATUS;
 533:calypso/sim.c **** 			calypso_sim_receive(response + 1, 2);
 508              		.loc 1 533 0
 509 0198 34019305 		ldreq	r0, [r3, #308]
 532:calypso/sim.c **** 			sim_state = SIM_STATE_RX_STATUS;
 510              		.loc 1 532 0
 511 019c 02108102 		addeq	r1, r1, #2
 512 01a0 2410C305 		streqb	r1, [r3, #36]
 513              		.loc 1 533 0
 514 01a4 01008002 		addeq	r0, r0, #1
 515 01a8 5100000A 		beq	.L51
 516              	.L35:
 534:calypso/sim.c **** 			break;
 535:calypso/sim.c **** 		}
 536:calypso/sim.c **** 		/* Case 2: No input / Output of known length */
 537:calypso/sim.c **** 		if (mode == SIM_APDU_PUT) {
 517              		.loc 1 537 0
 518 01ac 2A21D3E5 		ldrb	r2, [r3, #298]	@ zero_extendqisi2
 519 01b0 000052E3 		cmp	r2, #0
 538:calypso/sim.c **** 			sim_state = SIM_STATE_RX_ACK;
 520              		.loc 1 538 0
 521 01b4 03208202 		addeq	r2, r2, #3
 539:calypso/sim.c **** 			calypso_sim_receive(response, 1);
 540:calypso/sim.c **** 			break;
 541:calypso/sim.c **** 		/* Case 4: Input / No output */
 542:calypso/sim.c **** 		} else {
 543:calypso/sim.c **** 			sim_state = SIM_STATE_RX_ACK_DATA;
 522              		.loc 1 543 0
 523 01b8 0420A013 		movne	r2, #4
 544:calypso/sim.c **** 			calypso_sim_receive(response, length + 1 + 2);
 524              		.loc 1 544 0
 525 01bc 03108112 		addne	r1, r1, #3
 538:calypso/sim.c **** 			sim_state = SIM_STATE_RX_ACK;
 526              		.loc 1 538 0
 527 01c0 2420C305 		streqb	r2, [r3, #36]
 539:calypso/sim.c **** 			calypso_sim_receive(response, 1);
 528              		.loc 1 539 0
 529 01c4 34019305 		ldreq	r0, [r3, #308]
 530 01c8 0110A003 		moveq	r1, #1
 543:calypso/sim.c **** 			sim_state = SIM_STATE_RX_ACK_DATA;
 531              		.loc 1 543 0
 532 01cc 2420C315 		strneb	r2, [r3, #36]
 533              		.loc 1 544 0
 534 01d0 34019315 		ldrne	r0, [r3, #308]
 535 01d4 FF100112 		andne	r1, r1, #255
 536 01d8 450000EA 		b	.L51
 537              	.L24:
 545:calypso/sim.c **** 		}
 546:calypso/sim.c **** 		break;
 547:calypso/sim.c **** 	case SIM_STATE_RX_STATUS:
 548:calypso/sim.c **** 		if (!rxDoneFlag)
 538              		.loc 1 548 0
 539 01dc 8C329FE5 		ldr	r3, .L53
 540 01e0 002093E5 		ldr	r2, [r3, #0]
 541 01e4 000052E3 		cmp	r2, #0
 542 01e8 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 549:calypso/sim.c **** 			break; /* wait until data is received */
 550:calypso/sim.c **** 		/* Disable all interrupt driven functions */
 551:calypso/sim.c **** 		writew(0xFF, REG_SIM_MASKIT);
 543              		.loc 1 551 0
 544 01ec 88229FE5 		ldr	r2, .L53+12
 545 01f0 FF10A0E3 		mov	r1, #255	@ movhi
 546 01f4 B11F42E1 		strh	r1, [r2, #-241]	@ movhi
 552:calypso/sim.c **** 		/* disable special ignore case */
 553:calypso/sim.c **** 		sim_ignore_waiting_char = 0;
 547              		.loc 1 553 0
 548 01f8 0020A0E3 		mov	r2, #0
 549 01fc 1420C3E5 		strb	r2, [r3, #20]
 554:calypso/sim.c **** 		/* wrong number of bytes received */
 555:calypso/sim.c **** 		if (sim_rx_character_count != 2) {
 550              		.loc 1 555 0
 551 0200 182093E5 		ldr	r2, [r3, #24]
 552 0204 020052E3 		cmp	r2, #2
 556:calypso/sim.c **** 			puts("SIM: Failed to read status\n");
 553              		.loc 1 556 0
 554 0208 70029F15 		ldrne	r0, .L53+16
 555:calypso/sim.c **** 		if (sim_rx_character_count != 2) {
 555              		.loc 1 555 0
 556 020c 5B00001A 		bne	.L48
 557:calypso/sim.c **** 			goto error;
 558:calypso/sim.c **** 		}
 559:calypso/sim.c **** 		msgb_pull(msg, length + 1); /* pull up to status info */
 557              		.loc 1 559 0
 558 0210 302193E5 		ldr	r2, [r3, #304]
 559 0214 4B1FA0E3 		mov	r1, #300
 560 0218 B13093E1 		ldrh	r3, [r3, r1]
 561              	.LBB57:
 562              	.LBB58:
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 563              		.loc 2 298 0
 564 021c B613D2E1 		ldrh	r1, [r2, #54]
 565              	.LBE58:
 566              	.LBE57:
 567              		.loc 1 559 0
 568 0220 013083E2 		add	r3, r3, #1
 569              	.LVL27:
 570              	.LBB60:
 571              	.LBB59:
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 572              		.loc 2 298 0
 573 0224 011063E0 		rsb	r1, r3, r1
 574 0228 B613C2E1 		strh	r1, [r2, #54]	@ movhi
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 575              		.loc 2 299 0
 576 022c 401092E5 		ldr	r1, [r2, #64]
 577 0230 033081E0 		add	r3, r1, r3
 578              	.LVL28:
 579 0234 403082E5 		str	r3, [r2, #64]
 580 0238 670000EA 		b	.L39
 581              	.LVL29:
 582              	.L25:
 583              	.LBE59:
 584              	.LBE60:
 560:calypso/sim.c **** 		goto queue;
 561:calypso/sim.c **** 	case SIM_STATE_RX_ACK:
 562:calypso/sim.c **** 		if (!rxDoneFlag)
 585              		.loc 1 562 0
 586 023c 2C429FE5 		ldr	r4, .L53
 587 0240 003094E5 		ldr	r3, [r4, #0]
 588 0244 000053E3 		cmp	r3, #0
 589 0248 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 563:calypso/sim.c **** 			break; /* wait until data is received */
 564:calypso/sim.c **** 		/* Disable all interrupt driven functions */
 565:calypso/sim.c **** 		writew(0xFF, REG_SIM_MASKIT);
 590              		.loc 1 565 0
 591 024c 28329FE5 		ldr	r3, .L53+12
 592 0250 FF20A0E3 		mov	r2, #255	@ movhi
 593 0254 B12F43E1 		strh	r2, [r3, #-241]	@ movhi
 566:calypso/sim.c **** 		/* error received */
 567:calypso/sim.c **** 		if (sim_rx_character_count == 2) {
 594              		.loc 1 567 0
 595 0258 183094E5 		ldr	r3, [r4, #24]
 596 025c 020053E3 		cmp	r3, #2
 597 0260 2F00000A 		beq	.L52
 598              	.L40:
 568:calypso/sim.c **** 			puts("SIM: command failed\n");
 569:calypso/sim.c **** 			msgb_pull(msg, msg->len - 2);
 570:calypso/sim.c **** 			msg->data[0] = response[0];
 571:calypso/sim.c **** 			msg->data[1] = response[1];
 572:calypso/sim.c **** 			goto queue;
 573:calypso/sim.c **** 		}
 574:calypso/sim.c **** 		/* wrong number of bytes received */
 575:calypso/sim.c **** 		if (sim_rx_character_count != 1) {
 599              		.loc 1 575 0
 600 0264 183094E5 		ldr	r3, [r4, #24]
 601 0268 010053E3 		cmp	r3, #1
 576:calypso/sim.c **** 			puts("SIM: ACK read failed\n");
 602              		.loc 1 576 0
 603 026c 10029F15 		ldrne	r0, .L53+20
 575:calypso/sim.c **** 		if (sim_rx_character_count != 1) {
 604              		.loc 1 575 0
 605 0270 4200001A 		bne	.L48
 577:calypso/sim.c **** 			goto error;
 578:calypso/sim.c **** 		}
 579:calypso/sim.c **** 		if (response[0] != sim_data[1]) {
 606              		.loc 1 579 0
 607 0274 343194E5 		ldr	r3, [r4, #308]
 608 0278 0020D3E5 		ldrb	r2, [r3, #0]	@ zero_extendqisi2
 609 027c 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 610 0280 030052E1 		cmp	r2, r3
 580:calypso/sim.c **** 			puts("SIM: ACK does not match request\n");
 611              		.loc 1 580 0
 612 0284 FC019F15 		ldrne	r0, .L53+24
 579:calypso/sim.c **** 		if (response[0] != sim_data[1]) {
 613              		.loc 1 579 0
 614 0288 3C00001A 		bne	.L48
 581:calypso/sim.c **** 			goto error;
 582:calypso/sim.c **** 		}
 583:calypso/sim.c **** 		sim_state = SIM_STATE_TX_DATA;
 615              		.loc 1 583 0
 616 028c 0530A0E3 		mov	r3, #5
 617 0290 2430C4E5 		strb	r3, [r4, #36]
 584:calypso/sim.c **** 		calypso_sim_transmit(sim_data + 5, length);
 618              		.loc 1 584 0
 619 0294 4B3FA0E3 		mov	r3, #300
 620 0298 B31094E1 		ldrh	r1, [r4, r3]
 621 029c 2D0084E2 		add	r0, r4, #45
 622              	.L50:
 585:calypso/sim.c **** 		break;
 586:calypso/sim.c **** 	case SIM_STATE_TX_DATA:
 587:calypso/sim.c **** 		if (!txDoneFlag)
 588:calypso/sim.c **** 			break; /* wait until data is transmitted */
 589:calypso/sim.c **** 		/* Disable all interrupt driven functions */
 590:calypso/sim.c **** 		writew(0xFF, REG_SIM_MASKIT);
 591:calypso/sim.c **** 		/* Ignore waiting char for RUN GSM ALGORITHM */
 592:calypso/sim.c **** 		/* TODO: implement proper handling of the "Procedure Bytes"
 593:calypso/sim.c **** 		   than this is no longer needed */
 594:calypso/sim.c **** 		if(sim_data[1] == 0x88)
 595:calypso/sim.c **** 			sim_ignore_waiting_char = 1;
 596:calypso/sim.c **** 		sim_state = SIM_STATE_RX_STATUS;
 597:calypso/sim.c **** 		calypso_sim_receive(response + length + 1, 2);
 598:calypso/sim.c **** 		break;
 599:calypso/sim.c **** 	case SIM_STATE_RX_ACK_DATA:
 600:calypso/sim.c **** 		if (!rxDoneFlag)
 601:calypso/sim.c **** 			break; /* wait until data is received */
 602:calypso/sim.c **** 		/* Disable all interrupt driven functions */
 603:calypso/sim.c **** 		writew(0xFF, REG_SIM_MASKIT);
 604:calypso/sim.c **** 		/* error received */
 605:calypso/sim.c **** 		if (sim_rx_character_count == 2) {
 606:calypso/sim.c **** 			puts("SIM: command failed\n");
 607:calypso/sim.c **** 			msgb_pull(msg, msg->len - 2);
 608:calypso/sim.c **** 			msg->data[0] = response[0];
 609:calypso/sim.c **** 			msg->data[1] = response[1];
 610:calypso/sim.c **** 			goto queue;
 611:calypso/sim.c **** 		}
 612:calypso/sim.c **** 		/* wrong number of bytes received */
 613:calypso/sim.c **** 		if (sim_rx_character_count != length + 1 + 2) {
 614:calypso/sim.c **** 			puts("SIM: Failed to read data\n");
 615:calypso/sim.c **** 			goto error;
 616:calypso/sim.c **** 		}
 617:calypso/sim.c **** 		msgb_pull(msg, 1); /* pull ACK byte */
 618:calypso/sim.c **** 		goto queue;
 619:calypso/sim.c **** 	}
 620:calypso/sim.c **** 
 621:calypso/sim.c **** 	return;
 622:calypso/sim.c **** 
 623:calypso/sim.c **** error:
 624:calypso/sim.c **** 	msgb_pull(msg, msg->len - 2);
 625:calypso/sim.c **** 	msg->data[0] = 0;
 626:calypso/sim.c **** 	msg->data[1] = 0;
 627:calypso/sim.c **** queue:
 628:calypso/sim.c **** 	printf("SIM Response (%d): %s\n", msg->len,
 629:calypso/sim.c **** 		osmo_hexdump(msg->data, msg->len));
 630:calypso/sim.c **** 	l1h = (struct l1ctl_hdr *) msgb_push(msg, sizeof(*l1h));
 631:calypso/sim.c **** 	l1h->msg_type = L1CTL_SIM_CONF;
 632:calypso/sim.c **** 	l1h->flags = 0;
 633:calypso/sim.c **** 	msg->l1h = (uint8_t *)l1h;
 634:calypso/sim.c **** 	l1_queue_for_l2(msg);
 635:calypso/sim.c **** 	/* go IDLE */
 636:calypso/sim.c **** 	sim_state = SIM_STATE_IDLE;
 637:calypso/sim.c **** 	sim_len = 0;
 638:calypso/sim.c **** 
 639:calypso/sim.c **** 	return;
 640:calypso/sim.c **** }
 623              		.loc 1 640 0
 624 02a0 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 584:calypso/sim.c **** 		calypso_sim_transmit(sim_data + 5, length);
 625              		.loc 1 584 0
 626 02a4 FEFFFFEA 		b	calypso_sim_transmit
 627              	.L27:
 587:calypso/sim.c **** 		if (!txDoneFlag)
 628              		.loc 1 587 0
 629 02a8 C0319FE5 		ldr	r3, .L53
 630 02ac 0C2093E5 		ldr	r2, [r3, #12]
 631 02b0 000052E3 		cmp	r2, #0
 632 02b4 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 590:calypso/sim.c **** 		writew(0xFF, REG_SIM_MASKIT);
 633              		.loc 1 590 0
 634 02b8 BC219FE5 		ldr	r2, .L53+12
 635 02bc FF10A0E3 		mov	r1, #255	@ movhi
 636 02c0 B11F42E1 		strh	r1, [r2, #-241]	@ movhi
 594:calypso/sim.c **** 		if(sim_data[1] == 0x88)
 637              		.loc 1 594 0
 638 02c4 2920D3E5 		ldrb	r2, [r3, #41]	@ zero_extendqisi2
 639 02c8 880052E3 		cmp	r2, #136
 595:calypso/sim.c **** 			sim_ignore_waiting_char = 1;
 640              		.loc 1 595 0
 641 02cc 0120A003 		moveq	r2, #1
 642 02d0 1420C305 		streqb	r2, [r3, #20]
 596:calypso/sim.c **** 		sim_state = SIM_STATE_RX_STATUS;
 643              		.loc 1 596 0
 644 02d4 94319FE5 		ldr	r3, .L53
 597:calypso/sim.c **** 		calypso_sim_receive(response + length + 1, 2);
 645              		.loc 1 597 0
 646 02d8 4B2FA0E3 		mov	r2, #300
 647 02dc B22093E1 		ldrh	r2, [r3, r2]
 596:calypso/sim.c **** 		sim_state = SIM_STATE_RX_STATUS;
 648              		.loc 1 596 0
 649 02e0 0210A0E3 		mov	r1, #2
 597:calypso/sim.c **** 		calypso_sim_receive(response + length + 1, 2);
 650              		.loc 1 597 0
 651 02e4 340193E5 		ldr	r0, [r3, #308]
 652 02e8 012082E2 		add	r2, r2, #1
 596:calypso/sim.c **** 		sim_state = SIM_STATE_RX_STATUS;
 653              		.loc 1 596 0
 654 02ec 2410C3E5 		strb	r1, [r3, #36]
 597:calypso/sim.c **** 		calypso_sim_receive(response + length + 1, 2);
 655              		.loc 1 597 0
 656 02f0 020080E0 		add	r0, r0, r2
 657              	.L51:
 658              		.loc 1 640 0
 659 02f4 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 597:calypso/sim.c **** 		calypso_sim_receive(response + length + 1, 2);
 660              		.loc 1 597 0
 661 02f8 FEFFFFEA 		b	calypso_sim_receive
 662              	.L26:
 600:calypso/sim.c **** 		if (!rxDoneFlag)
 663              		.loc 1 600 0
 664 02fc 6C419FE5 		ldr	r4, .L53
 665 0300 003094E5 		ldr	r3, [r4, #0]
 666 0304 000053E3 		cmp	r3, #0
 667 0308 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 603:calypso/sim.c **** 		writew(0xFF, REG_SIM_MASKIT);
 668              		.loc 1 603 0
 669 030c 68319FE5 		ldr	r3, .L53+12
 670 0310 FF20A0E3 		mov	r2, #255	@ movhi
 671 0314 B12F43E1 		strh	r2, [r3, #-241]	@ movhi
 605:calypso/sim.c **** 		if (sim_rx_character_count == 2) {
 672              		.loc 1 605 0
 673 0318 183094E5 		ldr	r3, [r4, #24]
 674 031c 020053E3 		cmp	r3, #2
 675 0320 0F00001A 		bne	.L44
 676              	.L52:
 606:calypso/sim.c **** 			puts("SIM: command failed\n");
 677              		.loc 1 606 0
 678 0324 60019FE5 		ldr	r0, .L53+28
 679 0328 FEFFFFEB 		bl	puts
 607:calypso/sim.c **** 			msgb_pull(msg, msg->len - 2);
 680              		.loc 1 607 0
 681 032c 303194E5 		ldr	r3, [r4, #304]
 682              	.LVL30:
 683 0330 B613D3E1 		ldrh	r1, [r3, #54]
 684              	.LVL31:
 685              	.LBB61:
 686              	.LBB62:
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 687              		.loc 2 299 0
 688 0334 400093E5 		ldr	r0, [r3, #64]
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 689              		.loc 2 298 0
 690 0338 021041E2 		sub	r1, r1, #2
 691              	.LVL32:
 692 033c 0220A0E3 		mov	r2, #2	@ movhi
 693 0340 B623C3E1 		strh	r2, [r3, #54]	@ movhi
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 694              		.loc 2 299 0
 695 0344 012080E0 		add	r2, r0, r1
 696 0348 402083E5 		str	r2, [r3, #64]
 697              	.LBE62:
 698              	.LBE61:
 608:calypso/sim.c **** 			msg->data[0] = response[0];
 699              		.loc 1 608 0
 700 034c 342194E5 		ldr	r2, [r4, #308]
 701 0350 00C0D2E5 		ldrb	ip, [r2, #0]	@ zero_extendqisi2
 702 0354 01C0C0E7 		strb	ip, [r0, r1]
 609:calypso/sim.c **** 			msg->data[1] = response[1];
 703              		.loc 1 609 0
 704 0358 403093E5 		ldr	r3, [r3, #64]
 705 035c 0120D2E5 		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 706 0360 1C0000EA 		b	.L49
 707              	.LVL33:
 708              	.L44:
 613:calypso/sim.c **** 		if (sim_rx_character_count != length + 1 + 2) {
 709              		.loc 1 613 0
 710 0364 4B3FA0E3 		mov	r3, #300
 711 0368 B33094E1 		ldrh	r3, [r4, r3]
 712 036c 182094E5 		ldr	r2, [r4, #24]
 713 0370 033083E2 		add	r3, r3, #3
 714 0374 030052E1 		cmp	r2, r3
 715 0378 0E00000A 		beq	.L45
 614:calypso/sim.c **** 			puts("SIM: Failed to read data\n");
 716              		.loc 1 614 0
 717 037c 0C019FE5 		ldr	r0, .L53+32
 718              	.L48:
 719              	.L38:
 720 0380 FEFFFFEB 		bl	puts
 624:calypso/sim.c **** 	msgb_pull(msg, msg->len - 2);
 721              		.loc 1 624 0
 722 0384 E4309FE5 		ldr	r3, .L53
 723 0388 303193E5 		ldr	r3, [r3, #304]
 724              	.LVL34:
 725 038c B613D3E1 		ldrh	r1, [r3, #54]
 726              	.LVL35:
 727              	.LBB63:
 728              	.LBB64:
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 729              		.loc 2 299 0
 730 0390 400093E5 		ldr	r0, [r3, #64]
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 731              		.loc 2 298 0
 732 0394 021041E2 		sub	r1, r1, #2
 733              	.LVL36:
 734 0398 0220A0E3 		mov	r2, #2	@ movhi
 735 039c B623C3E1 		strh	r2, [r3, #54]	@ movhi
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 736              		.loc 2 299 0
 737 03a0 012080E0 		add	r2, r0, r1
 738 03a4 402083E5 		str	r2, [r3, #64]
 739              	.LBE64:
 740              	.LBE63:
 625:calypso/sim.c **** 	msg->data[0] = 0;
 741              		.loc 1 625 0
 742 03a8 0020A0E3 		mov	r2, #0
 743 03ac 0120C0E7 		strb	r2, [r0, r1]
 626:calypso/sim.c **** 	msg->data[1] = 0;
 744              		.loc 1 626 0
 745 03b0 403093E5 		ldr	r3, [r3, #64]
 746 03b4 070000EA 		b	.L49
 747              	.LVL37:
 748              	.L45:
 617:calypso/sim.c **** 		msgb_pull(msg, 1); /* pull ACK byte */
 749              		.loc 1 617 0
 750 03b8 303194E5 		ldr	r3, [r4, #304]
 751              	.LVL38:
 752              	.LBB65:
 753              	.LBB66:
 298:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len -= len;
 754              		.loc 2 298 0
 755 03bc B623D3E1 		ldrh	r2, [r3, #54]
 756 03c0 012042E2 		sub	r2, r2, #1
 757 03c4 B623C3E1 		strh	r2, [r3, #54]	@ movhi
 299:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->data += len;
 758              		.loc 2 299 0
 759 03c8 402093E5 		ldr	r2, [r3, #64]
 760 03cc 012082E2 		add	r2, r2, #1
 761 03d0 402083E5 		str	r2, [r3, #64]
 762 03d4 000000EA 		b	.L39
 763              	.LVL39:
 764              	.L49:
 765              	.LBE66:
 766              	.LBE65:
 626:calypso/sim.c **** 	msg->data[1] = 0;
 767              		.loc 1 626 0
 768 03d8 0120C3E5 		strb	r2, [r3, #1]
 769              	.L39:
 629:calypso/sim.c **** 		osmo_hexdump(msg->data, msg->len));
 770              		.loc 1 629 0
 771 03dc 8C409FE5 		ldr	r4, .L53
 772 03e0 303194E5 		ldr	r3, [r4, #304]
 628:calypso/sim.c **** 	printf("SIM Response (%d): %s\n", msg->len,
 773              		.loc 1 628 0
 774 03e4 B653D3E1 		ldrh	r5, [r3, #54]
 775 03e8 400093E5 		ldr	r0, [r3, #64]
 776 03ec 0510A0E1 		mov	r1, r5
 777 03f0 FEFFFFEB 		bl	osmo_hexdump
 778 03f4 0510A0E1 		mov	r1, r5
 779 03f8 0020A0E1 		mov	r2, r0
 780 03fc 90009FE5 		ldr	r0, .L53+36
 781 0400 FEFFFFEB 		bl	printf
 630:calypso/sim.c **** 	l1h = (struct l1ctl_hdr *) msgb_push(msg, sizeof(*l1h));
 782              		.loc 1 630 0
 783 0404 304194E5 		ldr	r4, [r4, #304]
 784              	.LVL40:
 785              	.LBB67:
 786              	.LBB68:
 787              	.LBB69:
 788              	.LBB70:
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 789              		.loc 2 164 0
 790 0408 402094E5 		ldr	r2, [r4, #64]
 791 040c 383094E5 		ldr	r3, [r4, #56]
 792 0410 022063E0 		rsb	r2, r3, r2
 793              	.LBE70:
 794              	.LBE69:
 280:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_headroom(msgb) < (int) len)
 795              		.loc 2 280 0
 796 0414 030052E3 		cmp	r2, #3
 797              	.LVL41:
 281:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough headroom msgb_push (%u < %u)\n",
 798              		.loc 2 281 0
 799 0418 78009FD5 		ldrle	r0, .L53+40
 800 041c 0410A0D1 		movle	r1, r4
 801 0420 0430A0D3 		movle	r3, #4
 802 0424 FEFFFFDB 		blle	osmo_panic
 803              	.LVL42:
 804              	.L46:
 284:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 805              		.loc 2 284 0
 806 0428 B613D4E1 		ldrh	r1, [r4, #54]
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 807              		.loc 2 283 0
 808 042c 403094E5 		ldr	r3, [r4, #64]
 284:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 809              		.loc 2 284 0
 810 0430 041081E2 		add	r1, r1, #4
 811 0434 B613C4E1 		strh	r1, [r4, #54]	@ movhi
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 812              		.loc 2 283 0
 813 0438 042043E2 		sub	r2, r3, #4
 814              	.LVL43:
 815              	.LBE68:
 816              	.LBE67:
 632:calypso/sim.c **** 	l1h->flags = 0;
 817              		.loc 1 632 0
 818 043c 0050A0E3 		mov	r5, #0
 631:calypso/sim.c **** 	l1h->msg_type = L1CTL_SIM_CONF;
 819              		.loc 1 631 0
 820 0440 1710A0E3 		mov	r1, #23
 821              	.LBB72:
 822              	.LBB71:
 283:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->data -= len;
 823              		.loc 2 283 0
 824 0444 402084E5 		str	r2, [r4, #64]
 825              	.LBE71:
 826              	.LBE72:
 631:calypso/sim.c **** 	l1h->msg_type = L1CTL_SIM_CONF;
 827              		.loc 1 631 0
 828 0448 041043E5 		strb	r1, [r3, #-4]
 632:calypso/sim.c **** 	l1h->flags = 0;
 829              		.loc 1 632 0
 830 044c 035043E5 		strb	r5, [r3, #-3]
 633:calypso/sim.c **** 	msg->l1h = (uint8_t *)l1h;
 831              		.loc 1 633 0
 832 0450 18409FE5 		ldr	r4, .L53
 833              	.LVL44:
 834 0454 300194E5 		ldr	r0, [r4, #304]
 835 0458 102080E5 		str	r2, [r0, #16]
 634:calypso/sim.c **** 	l1_queue_for_l2(msg);
 836              		.loc 1 634 0
 837 045c FEFFFFEB 		bl	l1_queue_for_l2
 838              	.LVL45:
 637:calypso/sim.c **** 	sim_len = 0;
 839              		.loc 1 637 0
 840 0460 4A3FA0E3 		mov	r3, #296
 636:calypso/sim.c **** 	sim_state = SIM_STATE_IDLE;
 841              		.loc 1 636 0
 842 0464 2450C4E5 		strb	r5, [r4, #36]
 637:calypso/sim.c **** 	sim_len = 0;
 843              		.loc 1 637 0
 844 0468 B35084E1 		strh	r5, [r4, r3]	@ movhi
 845              	.LVL46:
 846              	.L20:
 847 046c 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 848              	.L54:
 849              		.align	2
 850              	.L53:
 851 0470 00000000 		.word	.LANCHOR0
 852 0474 1E000000 		.word	.LC1
 853 0478 25000000 		.word	.LC2
 854 047c FF00FEFF 		.word	-130817
 855 0480 58000000 		.word	.LC3
 856 0484 89000000 		.word	.LC5
 857 0488 9F000000 		.word	.LC6
 858 048c 74000000 		.word	.LC4
 859 0490 C0000000 		.word	.LC7
 860 0494 DA000000 		.word	.LC8
 861 0498 F1000000 		.word	.LC9
 862              		.cfi_endproc
 863              	.LFE41:
 865              		.section	.text.calypso_sim_init,"ax",%progbits
 866              		.align	2
 867              		.global	calypso_sim_init
 869              	calypso_sim_init:
 870              	.LFB42:
 641:calypso/sim.c **** 
 642:calypso/sim.c **** /* Initialize simcard interface */
 643:calypso/sim.c **** void calypso_sim_init(void)
 644:calypso/sim.c **** {
 871              		.loc 1 644 0
 872              		.cfi_startproc
 873              		@ args = 0, pretend = 0, frame = 0
 874              		@ frame_needed = 0, uses_anonymous_args = 0
 875 0000 04E02DE5 		str	lr, [sp, #-4]!
 876              	.LCFI2:
 877              		.cfi_def_cfa_offset 4
 645:calypso/sim.c **** 	/* Register IRQ handler and turn interrupts on */
 646:calypso/sim.c **** 	printd("SIM: Registering interrupt handler for simcard-interface\n");
 647:calypso/sim.c **** 
 648:calypso/sim.c **** 	irq_register_handler(IRQ_SIMCARD, &sim_irq_handler);
 878              		.loc 1 648 0
 879 0004 0600A0E3 		mov	r0, #6
 880 0008 20109FE5 		ldr	r1, .L56
 881              		.cfi_offset 14, -4
 882 000c FEFFFFEB 		bl	irq_register_handler
 649:calypso/sim.c **** 
 650:calypso/sim.c **** #if 1
 651:calypso/sim.c **** 	irq_config(IRQ_SIMCARD, 0, 0, 0xff);
 883              		.loc 1 651 0
 884 0010 0010A0E3 		mov	r1, #0
 885 0014 0600A0E3 		mov	r0, #6
 886 0018 0120A0E1 		mov	r2, r1
 887 001c 0030E0E3 		mvn	r3, #0
 888 0020 FEFFFFEB 		bl	irq_config
 652:calypso/sim.c **** #else
 653:calypso/sim.c **** 	irq_config(IRQ_SIMCARD, 0, 0, 1);
 654:calypso/sim.c **** #endif
 655:calypso/sim.c **** 
 656:calypso/sim.c **** 	irq_enable(IRQ_SIMCARD);
 889              		.loc 1 656 0
 890 0024 0600A0E3 		mov	r0, #6
 657:calypso/sim.c **** }
 891              		.loc 1 657 0
 892 0028 04E09DE4 		ldr	lr, [sp], #4
 656:calypso/sim.c **** 	irq_enable(IRQ_SIMCARD);
 893              		.loc 1 656 0
 894 002c FEFFFFEA 		b	irq_enable
 895              	.L57:
 896              		.align	2
 897              	.L56:
 898 0030 00000000 		.word	sim_irq_handler
 899              		.cfi_endproc
 900              	.LFE42:
 902              		.section	.text.calypso_sim_powerup,"ax",%progbits
 903              		.align	2
 904              		.global	calypso_sim_powerup
 906              	calypso_sim_powerup:
 907              	.LFB43:
 658:calypso/sim.c **** 
 659:calypso/sim.c **** /* Apply power to the simcard (use nullpointer to ignore atr) */
 660:calypso/sim.c **** int calypso_sim_powerup(uint8_t *atr)
 661:calypso/sim.c **** {
 908              		.loc 1 661 0
 909              		.cfi_startproc
 910              		@ args = 0, pretend = 0, frame = 0
 911              		@ frame_needed = 0, uses_anonymous_args = 0
 912              	.LVL47:
 913 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 914              	.LCFI3:
 915              		.cfi_def_cfa_offset 12
 662:calypso/sim.c **** 	/* Enable level shifters and voltage regulator */
 663:calypso/sim.c **** #if 1  // 2.9V
 664:calypso/sim.c **** 	twl3025_reg_write(VRPCSIM, VRPCSIM_SIMLEN | VRPCSIM_RSIMEN
 916              		.loc 1 664 0
 917 0004 0B10A0E3 		mov	r1, #11
 661:calypso/sim.c **** {
 918              		.loc 1 661 0
 919 0008 0040A0E1 		mov	r4, r0
 920              		.cfi_offset 14, -4
 921              		.cfi_offset 5, -8
 922              		.cfi_offset 4, -12
 923              		.loc 1 664 0
 924 000c 9700A0E3 		mov	r0, #151
 925              	.LVL48:
 926 0010 FEFFFFEB 		bl	twl3025_reg_write
 665:calypso/sim.c **** 					| VRPCSIM_SIMSEL);
 666:calypso/sim.c **** #else // 1.8V
 667:calypso/sim.c **** 	twl3025_reg_write(VRPCSIM, VRPCSIM_SIMLEN | VRPCSIM_RSIMEN);
 668:calypso/sim.c **** #endif
 669:calypso/sim.c **** 	printd(" * Power enabled!\n");
 670:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 671:calypso/sim.c **** 
 672:calypso/sim.c **** 	/* Enable clock */
 673:calypso/sim.c **** 	writew(REG_SIM_CMD_MODULE_CLK_EN | REG_SIM_CMD_CMDSTART, REG_SIM_CMD);
 927              		.loc 1 673 0
 928 0014 4C509FE5 		ldr	r5, .L62
 670:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 929              		.loc 1 670 0
 930 0018 6400A0E3 		mov	r0, #100
 931 001c FEFFFFEB 		bl	delay_ms
 932              		.loc 1 673 0
 933 0020 1830A0E3 		mov	r3, #24	@ movhi
 934 0024 BF3F45E1 		strh	r3, [r5, #-255]	@ movhi
 674:calypso/sim.c **** 	printd(" * Clock enabled!\n");
 675:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 935              		.loc 1 675 0
 936 0028 6400A0E3 		mov	r0, #100
 937 002c FEFFFFEB 		bl	delay_ms
 676:calypso/sim.c **** 
 677:calypso/sim.c **** 	/* Release reset */
 678:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) | REG_SIM_CONF1_CONFBYPASS
 938              		.loc 1 678 0
 939 0030 BB3F55E1 		ldrh	r3, [r5, #-251]
 679:calypso/sim.c **** 				| REG_SIM_CONF1_CONFSRSTLEV
 680:calypso/sim.c **** 				| REG_SIM_CONF1_CONFSVCCLEV, REG_SIM_CONF1);
 681:calypso/sim.c **** 	printd(" * Reset released!\n");
 682:calypso/sim.c **** 
 683:calypso/sim.c **** 	/* Catch ATR */
 684:calypso/sim.c **** 	if(atr != 0) {
 940              		.loc 1 684 0
 941 0034 000054E3 		cmp	r4, #0
 678:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) | REG_SIM_CONF1_CONFBYPASS
 942              		.loc 1 678 0
 943 0038 073C83E3 		orr	r3, r3, #1792
 944 003c BB3F45E1 		strh	r3, [r5, #-251]	@ movhi
 945              		.loc 1 684 0
 946 0040 0600000A 		beq	.L59
 685:calypso/sim.c **** 		calypso_sim_receive(atr, 0);
 947              		.loc 1 685 0
 948 0044 0400A0E1 		mov	r0, r4
 949 0048 0010A0E3 		mov	r1, #0
 950 004c FEFFFFEB 		bl	calypso_sim_receive
 686:calypso/sim.c **** 		while (!rxDoneFlag)
 951              		.loc 1 686 0
 952 0050 14309FE5 		ldr	r3, .L62+4
 953              	.L60:
 954              		.loc 1 686 0 is_stmt 0 discriminator 1
 955 0054 002093E5 		ldr	r2, [r3, #0]
 956 0058 000052E3 		cmp	r2, #0
 957 005c FCFFFF0A 		beq	.L60
 958              	.L59:
 687:calypso/sim.c **** 			;
 688:calypso/sim.c **** 	}
 689:calypso/sim.c **** 
 690:calypso/sim.c **** 	return 0;
 691:calypso/sim.c **** }
 959              		.loc 1 691 0 is_stmt 1
 960 0060 0000A0E3 		mov	r0, #0
 961 0064 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 962              	.L63:
 963              		.align	2
 964              	.L62:
 965 0068 FF00FEFF 		.word	-130817
 966 006c 00000000 		.word	.LANCHOR0
 967              		.cfi_endproc
 968              	.LFE43:
 970              		.section	.text.calypso_sim_powerdown,"ax",%progbits
 971              		.align	2
 972              		.global	calypso_sim_powerdown
 974              	calypso_sim_powerdown:
 975              	.LFB44:
 692:calypso/sim.c **** 
 693:calypso/sim.c **** 
 694:calypso/sim.c **** /* Powerdown simcard */
 695:calypso/sim.c **** void calypso_sim_powerdown(void)
 696:calypso/sim.c **** {
 976              		.loc 1 696 0
 977              		.cfi_startproc
 978              		@ args = 0, pretend = 0, frame = 0
 979              		@ frame_needed = 0, uses_anonymous_args = 0
 980 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 981              	.LCFI4:
 982              		.cfi_def_cfa_offset 12
 697:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) & ~REG_SIM_CONF1_CONFBYPASS, REG_SIM_CONF1);
 983              		.loc 1 697 0
 984 0004 4C409FE5 		ldr	r4, .L65
 985              		.cfi_offset 14, -4
 986              		.cfi_offset 5, -8
 987              		.cfi_offset 4, -12
 988 0008 4C309FE5 		ldr	r3, .L65+4
 989 000c BB2F54E1 		ldrh	r2, [r4, #-251]
 990 0010 033002E0 		and	r3, r2, r3
 991 0014 BB3F44E1 		strh	r3, [r4, #-251]	@ movhi
 698:calypso/sim.c **** 	printd(" * Reset pulled down!\n");
 699:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 992              		.loc 1 699 0
 993 0018 6400A0E3 		mov	r0, #100
 994 001c FEFFFFEB 		bl	delay_ms
 700:calypso/sim.c **** 
 701:calypso/sim.c **** 	writew(REG_SIM_CMD_MODULE_CLK_EN | REG_SIM_CMD_CMDSTOP, REG_SIM_CMD);
 995              		.loc 1 701 0
 996 0020 1430A0E3 		mov	r3, #20	@ movhi
 997 0024 BF3F44E1 		strh	r3, [r4, #-255]	@ movhi
 702:calypso/sim.c **** 	printd(" * Clock disabled!\n");
 703:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 704:calypso/sim.c **** 
 705:calypso/sim.c **** 	writew(0, REG_SIM_CMD);
 998              		.loc 1 705 0
 999 0028 0050A0E3 		mov	r5, #0
 703:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 1000              		.loc 1 703 0
 1001 002c 6400A0E3 		mov	r0, #100
 1002 0030 FEFFFFEB 		bl	delay_ms
 1003              		.loc 1 705 0
 1004 0034 BF5F44E1 		strh	r5, [r4, #-255]	@ movhi
 706:calypso/sim.c **** 	printd(" * Module disabled!\n");
 707:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 1005              		.loc 1 707 0
 1006 0038 6400A0E3 		mov	r0, #100
 1007 003c FEFFFFEB 		bl	delay_ms
 708:calypso/sim.c **** 
 709:calypso/sim.c **** 	/* Disable level shifters and voltage regulator */
 710:calypso/sim.c **** 	twl3025_reg_write(VRPCSIM, 0);
 1008              		.loc 1 710 0
 1009 0040 9700A0E3 		mov	r0, #151
 1010 0044 0510A0E1 		mov	r1, r5
 1011 0048 FEFFFFEB 		bl	twl3025_reg_write
 711:calypso/sim.c **** 	printd(" * Power disabled!\n");
 712:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 1012              		.loc 1 712 0
 1013 004c 6400A0E3 		mov	r0, #100
 713:calypso/sim.c **** 
 714:calypso/sim.c **** 	return;
 715:calypso/sim.c **** }
 1014              		.loc 1 715 0
 1015 0050 3040BDE8 		ldmfd	sp!, {r4, r5, lr}
 712:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 1016              		.loc 1 712 0
 1017 0054 FEFFFFEA 		b	delay_ms
 1018              	.L66:
 1019              		.align	2
 1020              	.L65:
 1021 0058 FF00FEFF 		.word	-130817
 1022 005c FFFE0000 		.word	65279
 1023              		.cfi_endproc
 1024              	.LFE44:
 1026              		.section	.text.calypso_sim_reset,"ax",%progbits
 1027              		.align	2
 1028              		.global	calypso_sim_reset
 1030              	calypso_sim_reset:
 1031              	.LFB45:
 716:calypso/sim.c **** 
 717:calypso/sim.c **** /* reset the simcard (see note 1) */
 718:calypso/sim.c **** int calypso_sim_reset(uint8_t *atr)
 719:calypso/sim.c **** {
 1032              		.loc 1 719 0
 1033              		.cfi_startproc
 1034              		@ args = 0, pretend = 0, frame = 0
 1035              		@ frame_needed = 0, uses_anonymous_args = 0
 1036              	.LVL49:
 1037 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 1038              	.LCFI5:
 1039              		.cfi_def_cfa_offset 12
 720:calypso/sim.c **** 
 721:calypso/sim.c **** 	/* Pull reset down */
 722:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) & ~REG_SIM_CONF1_CONFSRSTLEV,
 1040              		.loc 1 722 0
 1041 0004 50409FE5 		ldr	r4, .L71
 1042              		.cfi_offset 14, -4
 1043              		.cfi_offset 5, -8
 1044              		.cfi_offset 4, -12
 1045 0008 50309FE5 		ldr	r3, .L71+4
 1046 000c BB2F54E1 		ldrh	r2, [r4, #-251]
 1047 0010 033002E0 		and	r3, r2, r3
 719:calypso/sim.c **** {
 1048              		.loc 1 719 0
 1049 0014 0050A0E1 		mov	r5, r0
 1050              		.loc 1 722 0
 1051 0018 BB3F44E1 		strh	r3, [r4, #-251]	@ movhi
 723:calypso/sim.c **** 		REG_SIM_CONF1);
 724:calypso/sim.c **** 	printd(" * Reset pulled down!\n");
 725:calypso/sim.c **** 
 726:calypso/sim.c **** 	delay_ms(SIM_OPERATION_DELAY);
 1052              		.loc 1 726 0
 1053 001c 6400A0E3 		mov	r0, #100
 1054              	.LVL50:
 1055 0020 FEFFFFEB 		bl	delay_ms
 727:calypso/sim.c **** 
 728:calypso/sim.c **** 	/* Pull reset down */
 729:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) | REG_SIM_CONF1_CONFSRSTLEV, REG_SIM_CONF1);
 1056              		.loc 1 729 0
 1057 0024 BB3F54E1 		ldrh	r3, [r4, #-251]
 730:calypso/sim.c **** 	printd(" * Reset released!\n");
 731:calypso/sim.c **** 
 732:calypso/sim.c **** 	/* Catch ATR */
 733:calypso/sim.c **** 	if(atr != 0) {
 1058              		.loc 1 733 0
 1059 0028 000055E3 		cmp	r5, #0
 729:calypso/sim.c **** 	writew(readw(REG_SIM_CONF1) | REG_SIM_CONF1_CONFSRSTLEV, REG_SIM_CONF1);
 1060              		.loc 1 729 0
 1061 002c 013B83E3 		orr	r3, r3, #1024
 1062 0030 BB3F44E1 		strh	r3, [r4, #-251]	@ movhi
 1063              		.loc 1 733 0
 1064 0034 0600000A 		beq	.L68
 734:calypso/sim.c **** 		calypso_sim_receive(atr, 0);
 1065              		.loc 1 734 0
 1066 0038 0500A0E1 		mov	r0, r5
 1067 003c 0010A0E3 		mov	r1, #0
 1068 0040 FEFFFFEB 		bl	calypso_sim_receive
 735:calypso/sim.c **** 		while (!rxDoneFlag)
 1069              		.loc 1 735 0
 1070 0044 18309FE5 		ldr	r3, .L71+8
 1071              	.L69:
 1072              		.loc 1 735 0 is_stmt 0 discriminator 1
 1073 0048 002093E5 		ldr	r2, [r3, #0]
 1074 004c 000052E3 		cmp	r2, #0
 1075 0050 FCFFFF0A 		beq	.L69
 1076              	.L68:
 736:calypso/sim.c **** 			;
 737:calypso/sim.c **** 	}
 738:calypso/sim.c **** 
 739:calypso/sim.c **** 	return 0;
 740:calypso/sim.c **** }
 1077              		.loc 1 740 0 is_stmt 1
 1078 0054 0000A0E3 		mov	r0, #0
 1079 0058 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 1080              	.L72:
 1081              		.align	2
 1082              	.L71:
 1083 005c FF00FEFF 		.word	-130817
 1084 0060 FFFB0000 		.word	64511
 1085 0064 00000000 		.word	.LANCHOR0
 1086              		.cfi_endproc
 1087              	.LFE45:
 1089              		.section	.rodata.str1.1,"aMS",%progbits,1
 1090              	.LC0:
 1091 0000 53696D20 		.ascii	"Sim reader currently busy...\012\000"
 1091      72656164 
 1091      65722063 
 1091      75727265 
 1091      6E746C79 
 1092              	.LC1:
 1093 001e 6C316374 		.ascii	"l1ctl1\000"
 1093      6C3100
 1094              	.LC2:
 1095 0025 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 1095      28257029 
 1095      3A204E6F 
 1095      7420656E 
 1095      6F756768 
 1096 0057 00       		.ascii	"\000"
 1097              	.LC3:
 1098 0058 53494D3A 		.ascii	"SIM: Failed to read status\012\000"
 1098      20466169 
 1098      6C656420 
 1098      746F2072 
 1098      65616420 
 1099              	.LC4:
 1100 0074 53494D3A 		.ascii	"SIM: command failed\012\000"
 1100      20636F6D 
 1100      6D616E64 
 1100      20666169 
 1100      6C65640A 
 1101              	.LC5:
 1102 0089 53494D3A 		.ascii	"SIM: ACK read failed\012\000"
 1102      2041434B 
 1102      20726561 
 1102      64206661 
 1102      696C6564 
 1103              	.LC6:
 1104 009f 53494D3A 		.ascii	"SIM: ACK does not match request\012\000"
 1104      2041434B 
 1104      20646F65 
 1104      73206E6F 
 1104      74206D61 
 1105              	.LC7:
 1106 00c0 53494D3A 		.ascii	"SIM: Failed to read data\012\000"
 1106      20466169 
 1106      6C656420 
 1106      746F2072 
 1106      65616420 
 1107              	.LC8:
 1108 00da 53494D20 		.ascii	"SIM Response (%d): %s\012\000"
 1108      52657370 
 1108      6F6E7365 
 1108      20282564 
 1108      293A2025 
 1109              	.LC9:
 1110 00f1 6D736762 		.ascii	"msgb(%p): Not enough headroom msgb_push (%u < %u)\012"
 1110      28257029 
 1110      3A204E6F 
 1110      7420656E 
 1110      6F756768 
 1111 0123 00       		.ascii	"\000"
 1112              		.bss
 1113              		.align	2
 1114              		.set	.LANCHOR0,. + 0
 1117              	rxDoneFlag:
 1118 0000 00000000 		.space	4
 1121              	sim_tx_character_count:
 1122 0004 00000000 		.space	4
 1125              	sim_tx_character_length:
 1126 0008 00000000 		.space	4
 1129              	txDoneFlag:
 1130 000c 00000000 		.space	4
 1133              	tx_buffer:
 1134 0010 00000000 		.space	4
 1137              	sim_ignore_waiting_char:
 1138 0014 00       		.space	1
 1139 0015 000000   		.space	3
 1142              	sim_rx_character_count:
 1143 0018 00000000 		.space	4
 1146              	rx_buffer:
 1147 001c 00000000 		.space	4
 1150              	sim_rx_max_character_count:
 1151 0020 00000000 		.space	4
 1154              	sim_state:
 1155 0024 00       		.space	1
 1156 0025 000000   		.space	3
 1159              	sim_data:
 1160 0028 00000000 		.space	256
 1160      00000000 
 1160      00000000 
 1160      00000000 
 1160      00000000 
 1163              	sim_len:
 1164 0128 0000     		.space	2
 1167              	mode.2038:
 1168 012a 00       		.space	1
 1169 012b 00       		.space	1
 1172              	length.2040:
 1173 012c 0000     		.space	2
 1174 012e 0000     		.space	2
 1177              	msg.2036:
 1178 0130 00000000 		.space	4
 1181              	response.2039:
 1182 0134 00000000 		.space	4
 1183              		.text
 1184              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 sim.c
     /tmp/ccOkzpeV.s:12     .text.sim_irq_handler:0000000000000000 $a
     /tmp/ccOkzpeV.s:15     .text.sim_irq_handler:0000000000000000 sim_irq_handler
     /tmp/ccOkzpeV.s:114    .text.sim_irq_handler:00000000000000e4 $d
     /tmp/ccOkzpeV.s:122    .text.calypso_sim_regdump:0000000000000000 $a
     /tmp/ccOkzpeV.s:125    .text.calypso_sim_regdump:0000000000000000 calypso_sim_regdump
     /tmp/ccOkzpeV.s:138    .text.calypso_sim_receive:0000000000000000 $a
     /tmp/ccOkzpeV.s:141    .text.calypso_sim_receive:0000000000000000 calypso_sim_receive
     /tmp/ccOkzpeV.s:178    .text.calypso_sim_receive:000000000000003c $d
     /tmp/ccOkzpeV.s:185    .text.calypso_sim_transmit:0000000000000000 $a
     /tmp/ccOkzpeV.s:188    .text.calypso_sim_transmit:0000000000000000 calypso_sim_transmit
     /tmp/ccOkzpeV.s:232    .text.calypso_sim_transmit:000000000000004c $d
     /tmp/ccOkzpeV.s:238    .text.sim_apdu:0000000000000000 $a
     /tmp/ccOkzpeV.s:241    .text.sim_apdu:0000000000000000 sim_apdu
     /tmp/ccOkzpeV.s:287    .text.sim_apdu:0000000000000040 $d
     /tmp/ccOkzpeV.s:293    .text.sim_handler:0000000000000000 $a
     /tmp/ccOkzpeV.s:296    .text.sim_handler:0000000000000000 sim_handler
     /tmp/ccOkzpeV.s:316    .text.sim_handler:0000000000000018 $d
     /tmp/ccOkzpeV.s:324    .text.sim_handler:0000000000000030 $a
     /tmp/ccOkzpeV.s:851    .text.sim_handler:0000000000000470 $d
     /tmp/ccOkzpeV.s:866    .text.calypso_sim_init:0000000000000000 $a
     /tmp/ccOkzpeV.s:869    .text.calypso_sim_init:0000000000000000 calypso_sim_init
     /tmp/ccOkzpeV.s:898    .text.calypso_sim_init:0000000000000030 $d
     /tmp/ccOkzpeV.s:903    .text.calypso_sim_powerup:0000000000000000 $a
     /tmp/ccOkzpeV.s:906    .text.calypso_sim_powerup:0000000000000000 calypso_sim_powerup
     /tmp/ccOkzpeV.s:965    .text.calypso_sim_powerup:0000000000000068 $d
     /tmp/ccOkzpeV.s:971    .text.calypso_sim_powerdown:0000000000000000 $a
     /tmp/ccOkzpeV.s:974    .text.calypso_sim_powerdown:0000000000000000 calypso_sim_powerdown
     /tmp/ccOkzpeV.s:1021   .text.calypso_sim_powerdown:0000000000000058 $d
     /tmp/ccOkzpeV.s:1027   .text.calypso_sim_reset:0000000000000000 $a
     /tmp/ccOkzpeV.s:1030   .text.calypso_sim_reset:0000000000000000 calypso_sim_reset
     /tmp/ccOkzpeV.s:1083   .text.calypso_sim_reset:000000000000005c $d
     /tmp/ccOkzpeV.s:1113   .bss:0000000000000000 $d
     /tmp/ccOkzpeV.s:1117   .bss:0000000000000000 rxDoneFlag
     /tmp/ccOkzpeV.s:1121   .bss:0000000000000004 sim_tx_character_count
     /tmp/ccOkzpeV.s:1125   .bss:0000000000000008 sim_tx_character_length
     /tmp/ccOkzpeV.s:1129   .bss:000000000000000c txDoneFlag
     /tmp/ccOkzpeV.s:1133   .bss:0000000000000010 tx_buffer
     /tmp/ccOkzpeV.s:1137   .bss:0000000000000014 sim_ignore_waiting_char
     /tmp/ccOkzpeV.s:1142   .bss:0000000000000018 sim_rx_character_count
     /tmp/ccOkzpeV.s:1146   .bss:000000000000001c rx_buffer
     /tmp/ccOkzpeV.s:1150   .bss:0000000000000020 sim_rx_max_character_count
     /tmp/ccOkzpeV.s:1154   .bss:0000000000000024 sim_state
     /tmp/ccOkzpeV.s:1159   .bss:0000000000000028 sim_data
     /tmp/ccOkzpeV.s:1163   .bss:0000000000000128 sim_len
     /tmp/ccOkzpeV.s:1167   .bss:000000000000012a mode.2038
     /tmp/ccOkzpeV.s:1172   .bss:000000000000012c length.2040
     /tmp/ccOkzpeV.s:1177   .bss:0000000000000130 msg.2036
     /tmp/ccOkzpeV.s:1181   .bss:0000000000000134 response.2039
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
puts
memcpy
msgb_alloc
osmo_panic
osmo_hexdump
printf
l1_queue_for_l2
irq_register_handler
irq_config
irq_enable
twl3025_reg_write
delay_ms
