   1              		.file	"trf6151.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.tpu_enq_at,"ax",%progbits
  12              		.align	2
  14              	tpu_enq_at:
  15              	.LFB6:
  16              		.file 1 "include/calypso/tpu.h"
   1:include/calypso/tpu.h **** #ifndef _CALYPSO_TPU_H
   2:include/calypso/tpu.h **** #define _CALYPSO_TPU_H
   3:include/calypso/tpu.h **** 
   4:include/calypso/tpu.h **** #define BITS_PER_TDMA		1250
   5:include/calypso/tpu.h **** #define QBITS_PER_TDMA		(BITS_PER_TDMA * 4)	/* 5000 */
   6:include/calypso/tpu.h **** #define TPU_RANGE		QBITS_PER_TDMA
   7:include/calypso/tpu.h **** #define	SWITCH_TIME		(TPU_RANGE-10)
   8:include/calypso/tpu.h **** 
   9:include/calypso/tpu.h **** /* Assert or de-assert TPU reset */
  10:include/calypso/tpu.h **** void tpu_reset(int active);
  11:include/calypso/tpu.h **** /* Enable or Disable a new scenario loaded into the TPU */
  12:include/calypso/tpu.h **** void tpu_enable(int active);
  13:include/calypso/tpu.h **** /* Enable or Disable the clock of the TPU Module */
  14:include/calypso/tpu.h **** void tpu_clk_enable(int active);
  15:include/calypso/tpu.h **** /* Enable Frame Interrupt generation on next frame.  DSP will reset it */
  16:include/calypso/tpu.h **** void tpu_dsp_frameirq_enable(void);
  17:include/calypso/tpu.h **** /* Is a Frame interrupt still pending for the DSP ? */
  18:include/calypso/tpu.h **** int tpu_dsp_fameirq_pending(void);
  19:include/calypso/tpu.h **** /* Rewind the TPU, i.e. restart enqueueing instructions at the base addr */
  20:include/calypso/tpu.h **** void tpu_rewind(void);
  21:include/calypso/tpu.h **** /* Enqueue a raw TPU instruction */
  22:include/calypso/tpu.h **** void tpu_enqueue(uint16_t instr);
  23:include/calypso/tpu.h **** /* Initialize TPU and TPU driver */
  24:include/calypso/tpu.h **** void tpu_init(void);
  25:include/calypso/tpu.h **** /* (Busy)Wait until TPU is idle */
  26:include/calypso/tpu.h **** void tpu_wait_idle(void);
  27:include/calypso/tpu.h **** /* Enable FRAME interrupt generation */
  28:include/calypso/tpu.h **** void tpu_frame_irq_en(int mcu, int dsp);
  29:include/calypso/tpu.h **** /* Force the generation of a DSP interrupt */
  30:include/calypso/tpu.h **** void tpu_force_dsp_frame_irq(void);
  31:include/calypso/tpu.h **** 
  32:include/calypso/tpu.h **** /* Get the current TPU SYNCHRO register */
  33:include/calypso/tpu.h **** uint16_t tpu_get_synchro(void);
  34:include/calypso/tpu.h **** /* Get the current TPU OFFSET register */
  35:include/calypso/tpu.h **** uint16_t tpu_get_offset(void);
  36:include/calypso/tpu.h **** 
  37:include/calypso/tpu.h **** enum tpu_instr {
  38:include/calypso/tpu.h **** 	TPU_INSTR_AT		= (1 << 13),
  39:include/calypso/tpu.h **** 	TPU_INSTR_OFFSET	= (2 << 13),
  40:include/calypso/tpu.h **** 	TPU_INSTR_SYNCHRO	= (3 << 13),	/* Loading delta synchro value in TPU synchro register */
  41:include/calypso/tpu.h **** 	TPU_INSTR_WAIT		= (5 << 13),	/* Wait a certain period (in GSM qbits) */
  42:include/calypso/tpu.h **** 	TPU_INSTR_SLEEP		= (0 << 13),	/* Stop the sequencer by disabling TPU ENABLE bit in ctrl reg */
  43:include/calypso/tpu.h **** 	/* data processing */
  44:include/calypso/tpu.h **** 	TPU_INSTR_MOVE		= (4 << 13),
  45:include/calypso/tpu.h **** };
  46:include/calypso/tpu.h **** 
  47:include/calypso/tpu.h **** /* Addresses internal to the TPU, only accessible via MOVE */
  48:include/calypso/tpu.h **** enum tpu_reg_int {
  49:include/calypso/tpu.h **** 	TPUI_TSP_CTRL1	= 0x00,
  50:include/calypso/tpu.h **** 	TPUI_TSP_CTRL2	= 0x01,
  51:include/calypso/tpu.h **** 	TPUI_TX_1	= 0x04,
  52:include/calypso/tpu.h **** 	TPUI_TX_2	= 0x03,
  53:include/calypso/tpu.h **** 	TPUI_TX_3	= 0x02,
  54:include/calypso/tpu.h **** 	TPUI_TX_4	= 0x05,
  55:include/calypso/tpu.h **** 	TPUI_TSP_ACT_L	= 0x06,
  56:include/calypso/tpu.h **** 	TPUI_TSP_ACT_U	= 0x07,
  57:include/calypso/tpu.h **** 	TPUI_TSP_SET1	= 0x09,
  58:include/calypso/tpu.h **** 	TPUI_TSP_SET2	= 0x0a,
  59:include/calypso/tpu.h **** 	TPUI_TSP_SET3	= 0x0b,
  60:include/calypso/tpu.h **** 	TPUI_DSP_INT_PG	= 0x10,
  61:include/calypso/tpu.h **** 	TPUI_GAUGING_EN = 0x11,
  62:include/calypso/tpu.h **** };
  63:include/calypso/tpu.h **** 
  64:include/calypso/tpu.h **** enum tpui_ctrl2_bits {
  65:include/calypso/tpu.h **** 	TPUI_CTRL2_RD		= (1 << 0),
  66:include/calypso/tpu.h **** 	TPUI_CTRL2_WR		= (1 << 1),
  67:include/calypso/tpu.h **** };
  68:include/calypso/tpu.h **** 
  69:include/calypso/tpu.h **** static inline uint16_t tpu_mod5000(int16_t time)
  70:include/calypso/tpu.h **** {
  71:include/calypso/tpu.h **** 	if (time < 0)
  72:include/calypso/tpu.h **** 		return time + 5000;
  73:include/calypso/tpu.h **** 	if (time >= 5000)
  74:include/calypso/tpu.h **** 		return time - 5000;
  75:include/calypso/tpu.h **** 	return time;
  76:include/calypso/tpu.h **** }
  77:include/calypso/tpu.h **** 
  78:include/calypso/tpu.h **** /* Enqueue a SLEEP operation (stop sequencer by disabling TPU ENABLE bit) */
  79:include/calypso/tpu.h **** static inline void tpu_enq_sleep(void)
  80:include/calypso/tpu.h **** {
  81:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SLEEP);
  82:include/calypso/tpu.h **** }
  83:include/calypso/tpu.h **** 
  84:include/calypso/tpu.h **** /* Enqueue a MOVE operation */
  85:include/calypso/tpu.h **** static inline void tpu_enq_move(uint8_t addr, uint8_t data)
  86:include/calypso/tpu.h **** {
  87:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_MOVE | (data << 5) | (addr & 0x1f));
  88:include/calypso/tpu.h **** }
  89:include/calypso/tpu.h **** 
  90:include/calypso/tpu.h **** /* Enqueue an AT operation */
  91:include/calypso/tpu.h **** static inline void tpu_enq_at(int16_t time)
  92:include/calypso/tpu.h **** {
  17              		.loc 1 92 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              		@ link register save eliminated.
  22              	.LVL0:
  23              	.LBB17:
  24              	.LBB18:
  71:include/calypso/tpu.h **** 	if (time < 0)
  25              		.loc 1 71 0
  26 0000 000050E3 		cmp	r0, #0
  27              	.LVL1:
  72:include/calypso/tpu.h **** 		return time + 5000;
  28              		.loc 1 72 0
  29 0004 4E0D80B2 		addlt	r0, r0, #4992
  30 0008 080080B2 		addlt	r0, r0, #8
  71:include/calypso/tpu.h **** 	if (time < 0)
  31              		.loc 1 71 0
  32 000c 030000BA 		blt	.L4
  73:include/calypso/tpu.h **** 	if (time >= 5000)
  33              		.loc 1 73 0
  34 0010 18309FE5 		ldr	r3, .L5
  35 0014 030050E1 		cmp	r0, r3
  74:include/calypso/tpu.h **** 		return time - 5000;
  36              		.loc 1 74 0
  37 0018 4E0D40C2 		subgt	r0, r0, #4992
  38 001c 080040C2 		subgt	r0, r0, #8
  39              	.L4:
  75:include/calypso/tpu.h **** 	return time;
  40              		.loc 1 75 0
  41 0020 0008A0E1 		mov	r0, r0, asl #16
  42 0024 2008A0E1 		mov	r0, r0, lsr #16
  43              	.LBE18:
  44              	.LBE17:
  93:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_AT | tpu_mod5000(time));
  45              		.loc 1 93 0
  46 0028 020A80E3 		orr	r0, r0, #8192
  94:include/calypso/tpu.h **** }
  47              		.loc 1 94 0
  93:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_AT | tpu_mod5000(time));
  48              		.loc 1 93 0
  49 002c FEFFFFEA 		b	tpu_enqueue
  50              	.L6:
  51              		.align	2
  52              	.L5:
  53 0030 87130000 		.word	4999
  54              		.cfi_endproc
  55              	.LFE6:
  57              		.section	.text.tpu_enq_wait,"ax",%progbits
  58              		.align	2
  60              	tpu_enq_wait:
  61              	.LFB8:
  95:include/calypso/tpu.h **** 
  96:include/calypso/tpu.h **** /* Enqueue a SYNC operation */
  97:include/calypso/tpu.h **** static inline void tpu_enq_sync(int16_t time)
  98:include/calypso/tpu.h **** {
  99:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SYNCHRO | time);
 100:include/calypso/tpu.h **** }
 101:include/calypso/tpu.h **** 
 102:include/calypso/tpu.h **** /* Enqueue a WAIT operation */
 103:include/calypso/tpu.h **** static inline void tpu_enq_wait(int16_t time)
 104:include/calypso/tpu.h **** {
  62              		.loc 1 104 0
  63              		.cfi_startproc
  64              		@ args = 0, pretend = 0, frame = 0
  65              		@ frame_needed = 0, uses_anonymous_args = 0
  66              		@ link register save eliminated.
  67              	.LVL2:
 105:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_WAIT | time);
  68              		.loc 1 105 0
  69 0000 08309FE5 		ldr	r3, .L8
  70 0004 033000E0 		and	r3, r0, r3
  71 0008 0A0A83E3 		orr	r0, r3, #40960
  72              	.LVL3:
 106:include/calypso/tpu.h **** }
  73              		.loc 1 106 0
 105:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_WAIT | time);
  74              		.loc 1 105 0
  75 000c FEFFFFEA 		b	tpu_enqueue
  76              	.L9:
  77              		.align	2
  78              	.L8:
  79 0010 FF5F0000 		.word	24575
  80              		.cfi_endproc
  81              	.LFE8:
  83              		.section	.text.trf6151_reg_write,"ax",%progbits
  84              		.align	2
  86              	trf6151_reg_write:
  87              	.LFB11:
  88              		.file 2 "rf/trf6151.c"
   1:rf/trf6151.c  **** /* Driver for RF Transceiver Circuit (TRF6151) */
   2:rf/trf6151.c  **** 
   3:rf/trf6151.c  **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:rf/trf6151.c  ****  *
   5:rf/trf6151.c  ****  * All Rights Reserved
   6:rf/trf6151.c  ****  *
   7:rf/trf6151.c  ****  * This program is free software; you can redistribute it and/or modify
   8:rf/trf6151.c  ****  * it under the terms of the GNU General Public License as published by
   9:rf/trf6151.c  ****  * the Free Software Foundation; either version 2 of the License, or
  10:rf/trf6151.c  ****  * (at your option) any later version.
  11:rf/trf6151.c  ****  *
  12:rf/trf6151.c  ****  * This program is distributed in the hope that it will be useful,
  13:rf/trf6151.c  ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:rf/trf6151.c  ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:rf/trf6151.c  ****  * GNU General Public License for more details.
  16:rf/trf6151.c  ****  *
  17:rf/trf6151.c  ****  * You should have received a copy of the GNU General Public License along
  18:rf/trf6151.c  ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:rf/trf6151.c  ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:rf/trf6151.c  ****  *
  21:rf/trf6151.c  ****  */
  22:rf/trf6151.c  **** 
  23:rf/trf6151.c  **** #include <stdint.h>
  24:rf/trf6151.c  **** #include <stdio.h>
  25:rf/trf6151.c  **** 
  26:rf/trf6151.c  **** #include <debug.h>
  27:rf/trf6151.c  **** #include <memory.h>
  28:rf/trf6151.c  **** #include <keypad.h>
  29:rf/trf6151.c  **** #include <osmocom/gsm/gsm_utils.h>
  30:rf/trf6151.c  **** 
  31:rf/trf6151.c  **** #include <calypso/tpu.h>
  32:rf/trf6151.c  **** #include <calypso/tsp.h>
  33:rf/trf6151.c  **** #include <layer1/agc.h>
  34:rf/trf6151.c  **** #include <rffe.h>
  35:rf/trf6151.c  **** 
  36:rf/trf6151.c  **** #include <rf/trf6151.h>
  37:rf/trf6151.c  **** 
  38:rf/trf6151.c  **** /* #define WARN_OUT_OF_SPEC 1 */
  39:rf/trf6151.c  **** 
  40:rf/trf6151.c  **** enum trf6151_reg {
  41:rf/trf6151.c  **** 	REG_RX		= 0,	/* RF general settings */
  42:rf/trf6151.c  **** 	REG_PLL		= 1,	/* PLL settings */
  43:rf/trf6151.c  **** 	REG_PWR		= 2,	/* Power on/off functional blocks */
  44:rf/trf6151.c  **** 	REG_CFG		= 3,	/* Transceiver and PA controller settings */
  45:rf/trf6151.c  **** 	REG_TEST1	= 4,
  46:rf/trf6151.c  **** 	REG_TEST2	= 5,
  47:rf/trf6151.c  **** 	REG_TEST3	= 6,
  48:rf/trf6151.c  **** 	REG_TEST4	= 7,
  49:rf/trf6151.c  **** 	_MAX_REG
  50:rf/trf6151.c  **** };
  51:rf/trf6151.c  **** 
  52:rf/trf6151.c  **** /* REG_RX */
  53:rf/trf6151.c  **** #define RX_READ_EN		(1 << 7)
  54:rf/trf6151.c  **** #define RX_CAL_MODE		(1 << 8)
  55:rf/trf6151.c  **** #define RX_RF_GAIN_HIGH		(3 << 9)
  56:rf/trf6151.c  **** #define RX_VGA_GAIN_SHIFT	11
  57:rf/trf6151.c  **** 
  58:rf/trf6151.c  **** /* REG_PWR */
  59:rf/trf6151.c  **** #define PWR_BANDGAP_SHIFT	3
  60:rf/trf6151.c  **** #define PWR_BANDGAP_OFF		(0 << PWR_BANDGAP_SHIFT)
  61:rf/trf6151.c  **** #define PWR_BANDGAP_ON_SPEEDUP	(2 << PWR_BANDGAP_SHIFT)
  62:rf/trf6151.c  **** #define PWR_BANDGAP_ON		(3 << PWR_BANDGAP_SHIFT)
  63:rf/trf6151.c  **** #define PWR_REGUL_ON		(1 << 5)
  64:rf/trf6151.c  **** #define PWR_SYNTHE_OFF		(0)
  65:rf/trf6151.c  **** #define PWR_SYNTHE_RX_ON	(1 << 9)
  66:rf/trf6151.c  **** #define PWR_SYNTHE_TX_ON	(1 << 10)
  67:rf/trf6151.c  **** #define PWR_RX_MODE		(1 << 11)
  68:rf/trf6151.c  **** #define PWR_TX_MODE		(1 << 13)
  69:rf/trf6151.c  **** #define PWR_PACTRL_APC		(1 << 14)
  70:rf/trf6151.c  **** #define PWR_PACTRL_APCEN	(1 << 15)
  71:rf/trf6151.c  **** 
  72:rf/trf6151.c  **** /* REG_CFG */
  73:rf/trf6151.c  **** #define CFG_TX_LOOP_MANU	(1 << 3)
  74:rf/trf6151.c  **** #define CFG_PACTLR_IDIOD_30uA	(0 << 4)
  75:rf/trf6151.c  **** #define CFG_PACTLR_IDIOD_300uA	(1 << 4)
  76:rf/trf6151.c  **** #define CFG_PACTLR_RES_OPEN	(0 << 10)
  77:rf/trf6151.c  **** #define CFG_PACTLR_RES_150k	(1 << 10)
  78:rf/trf6151.c  **** #define CFG_PACTLR_RES_300k	(2 << 10)
  79:rf/trf6151.c  **** #define CFG_PACTLR_CAP_0pF	(0 << 12)
  80:rf/trf6151.c  **** #define CFG_PACTLR_CAP_12p5F	(1 << 12)
  81:rf/trf6151.c  **** #define CFG_PACTLR_CAP_25pF	(3 << 12)
  82:rf/trf6151.c  **** #define CFG_PACTLR_CAP_50pF	(2 << 12)
  83:rf/trf6151.c  **** #define CFG_TEMP_SENSOR		(1 << 14)
  84:rf/trf6151.c  **** #define CFG_ILOGIC_INIT_DIS	(1 << 15)
  85:rf/trf6151.c  **** 
  86:rf/trf6151.c  **** /* FIXME: This must be defined in the RFFE configuration */
  87:rf/trf6151.c  **** #define TRF6151_TSP_UID		2
  88:rf/trf6151.c  **** #define TRF6151_PACTRL_CFG	(CFG_PACTLR_RES_OPEN|CFG_PACTLR_CAP_0pF|CFG_PACTLR_IDIOD_30uA)
  89:rf/trf6151.c  **** 
  90:rf/trf6151.c  **** #define PLL_VAL(a, b)	((a << 3) | (((b)-64) << 9))
  91:rf/trf6151.c  **** 
  92:rf/trf6151.c  **** /* All values in qbits unless otherwise specified */
  93:rf/trf6151.c  **** #define TRF6151_LDO_DELAY_TS	6	/* six TDMA frames (at least 25ms) */
  94:rf/trf6151.c  **** #define TRF6151_RX_PLL_DELAY	184	/* 170 us */
  95:rf/trf6151.c  **** #define TRF6151_TX_PLL_DELAY	260	/* 240 us */
  96:rf/trf6151.c  **** 
  97:rf/trf6151.c  **** 
  98:rf/trf6151.c  **** enum trf6151_pwr_unit {
  99:rf/trf6151.c  **** 	TRF1651_PACTLR_APC,
 100:rf/trf6151.c  **** 	TRF6151_PACTRL_APCEN,
 101:rf/trf6151.c  **** 	TRF6151_TRANSMITTER,
 102:rf/trf6151.c  **** 	TRF6151_REGULATORS,
 103:rf/trf6151.c  **** };
 104:rf/trf6151.c  **** 
 105:rf/trf6151.c  **** enum trf6151_gsm_band {
 106:rf/trf6151.c  **** 	GSM900		= 1,
 107:rf/trf6151.c  **** 	GSM1800		= 2,
 108:rf/trf6151.c  **** 	GSM850_LOW	= 4,
 109:rf/trf6151.c  **** 	GSM850_HIGH	= 5,
 110:rf/trf6151.c  **** 	GSM1900		= 6,
 111:rf/trf6151.c  **** };
 112:rf/trf6151.c  **** 
 113:rf/trf6151.c  **** 
 114:rf/trf6151.c  **** uint16_t rf_arfcn = 871;	/* TODO: this needs to be private */
 115:rf/trf6151.c  **** static uint16_t rf_band;
 116:rf/trf6151.c  **** 
 117:rf/trf6151.c  **** static uint8_t trf6151_tsp_uid;
 118:rf/trf6151.c  **** static uint8_t trf6151_vga_dbm = 40;
 119:rf/trf6151.c  **** static int trf6151_gain_high = 1;
 120:rf/trf6151.c  **** 
 121:rf/trf6151.c  **** static uint16_t trf6151_reg_cache[_MAX_REG] = {
 122:rf/trf6151.c  **** 	[REG_RX] 	= 0x9E00,
 123:rf/trf6151.c  **** 	[REG_PLL]	= 0x0000,
 124:rf/trf6151.c  **** 	[REG_PWR]	= 0x0000,
 125:rf/trf6151.c  **** 	[REG_CFG]	= 0x2980,
 126:rf/trf6151.c  **** };
 127:rf/trf6151.c  **** 
 128:rf/trf6151.c  **** /* Write to a TRF6151 register (4 TPU instructions) */
 129:rf/trf6151.c  **** static void trf6151_reg_write(uint16_t reg, uint16_t val)
 130:rf/trf6151.c  **** {
  89              		.loc 2 130 0
  90              		.cfi_startproc
  91              		@ args = 0, pretend = 0, frame = 0
  92              		@ frame_needed = 0, uses_anonymous_args = 0
  93              	.LVL4:
  94 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
  95              	.LCFI0:
  96              		.cfi_def_cfa_offset 12
 131:rf/trf6151.c  **** 	printd("trf6151_reg_write(reg=%u, val=0x%04x)\n", reg, val);
 132:rf/trf6151.c  **** 	/* each TSP write takes 4 TPU instructions */
 133:rf/trf6151.c  **** 	tsp_write(trf6151_tsp_uid, 16, (reg | val));
  97              		.loc 2 133 0
  98 0004 24309FE5 		ldr	r3, .L11
 130:rf/trf6151.c  **** {
  99              		.loc 2 130 0
 100 0008 0050A0E1 		mov	r5, r0
 101              		.cfi_offset 14, -4
 102              		.cfi_offset 5, -8
 103              		.cfi_offset 4, -12
 104 000c 0140A0E1 		mov	r4, r1
 105              		.loc 2 133 0
 106 0010 0000D3E5 		ldrb	r0, [r3, #0]	@ zero_extendqisi2
 107              	.LVL5:
 108 0014 052084E1 		orr	r2, r4, r5
 109 0018 1010A0E3 		mov	r1, #16
 110              	.LVL6:
 111 001c FEFFFFEB 		bl	tsp_write
 134:rf/trf6151.c  **** 	trf6151_reg_cache[reg] = val;
 112              		.loc 2 134 0
 113 0020 0C309FE5 		ldr	r3, .L11+4
 114 0024 8550A0E1 		mov	r5, r5, asl #1
 115 0028 B54083E1 		strh	r4, [r3, r5]	@ movhi
 135:rf/trf6151.c  **** }
 116              		.loc 2 135 0
 117 002c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 118              	.L12:
 119              		.align	2
 120              	.L11:
 121 0030 00000000 		.word	.LANCHOR0
 122 0034 00000000 		.word	.LANCHOR1
 123              		.cfi_endproc
 124              	.LFE11:
 126              		.section	.text.trf6151_set_gain_reg,"ax",%progbits
 127              		.align	2
 128              		.global	trf6151_set_gain_reg
 130              	trf6151_set_gain_reg:
 131              	.LFB12:
 136:rf/trf6151.c  **** 
 137:rf/trf6151.c  **** /* Frontend gain can be switched high or low (dB) */
 138:rf/trf6151.c  **** #define TRF6151_FE_GAIN_LOW	7
 139:rf/trf6151.c  **** #define TRF6151_FE_GAIN_HIGH	27
 140:rf/trf6151.c  **** 
 141:rf/trf6151.c  **** /* VGA at baseband can be adjusted in this range (dB) */
 142:rf/trf6151.c  **** #define TRF6151_VGA_GAIN_MIN	14
 143:rf/trf6151.c  **** #define TRF6151_VGA_GAIN_MAX	40
 144:rf/trf6151.c  **** 
 145:rf/trf6151.c  **** /* put current set (or computed) gain to register */
 146:rf/trf6151.c  **** int trf6151_set_gain_reg(uint8_t dbm, int high)
 147:rf/trf6151.c  **** {
 132              		.loc 2 147 0
 133              		.cfi_startproc
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              	.LVL7:
 137 0000 FF0000E2 		and	r0, r0, #255
 138              	.LVL8:
 148:rf/trf6151.c  **** 	uint16_t reg = trf6151_reg_cache[REG_RX] & 0x07ff;
 149:rf/trf6151.c  **** 	printd("trf6151_set_gain_reg(%u, %d)\n", dbm, high);
 150:rf/trf6151.c  **** 
 151:rf/trf6151.c  **** 	if (dbm < TRF6151_VGA_GAIN_MIN || dbm > TRF6151_VGA_GAIN_MAX)
 139              		.loc 2 151 0
 140 0004 0E0040E2 		sub	r0, r0, #14
 148:rf/trf6151.c  **** 	uint16_t reg = trf6151_reg_cache[REG_RX] & 0x07ff;
 141              		.loc 2 148 0
 142 0008 50309FE5 		ldr	r3, .L18
 143              		.loc 2 151 0
 144 000c FF2000E2 		and	r2, r0, #255
 145 0010 1A0052E3 		cmp	r2, #26
 147:rf/trf6151.c  **** {
 146              		.loc 2 147 0
 147 0014 04E02DE5 		str	lr, [sp, #-4]!
 148              	.LCFI1:
 149              		.cfi_def_cfa_offset 4
 148:rf/trf6151.c  **** 	uint16_t reg = trf6151_reg_cache[REG_RX] & 0x07ff;
 150              		.loc 2 148 0
 151 0018 B030D3E1 		ldrh	r3, [r3, #0]
 152              	.LVL9:
 153              		.loc 2 151 0
 154 001c 0D00008A 		bhi	.L17
 155              		.cfi_offset 14, -4
 152:rf/trf6151.c  **** 		return -1;
 153:rf/trf6151.c  **** 
 154:rf/trf6151.c  **** 	/* clear the gain bits first */
 155:rf/trf6151.c  **** 	reg &= ~((0x1F) << RX_VGA_GAIN_SHIFT);
 156:rf/trf6151.c  **** 	/* OR-in the new gain value */
 157:rf/trf6151.c  **** 	reg |= (6 + (dbm-TRF6151_VGA_GAIN_MIN)/2) << RX_VGA_GAIN_SHIFT;
 156              		.loc 2 157 0
 157 0020 C000A0E1 		mov	r0, r0, asr #1
 155:rf/trf6151.c  **** 	reg &= ~((0x1F) << RX_VGA_GAIN_SHIFT);
 158              		.loc 2 155 0
 159 0024 833AA0E1 		mov	r3, r3, asl #21
 160              	.LVL10:
 161              		.loc 2 157 0
 162 0028 060080E2 		add	r0, r0, #6
 155:rf/trf6151.c  **** 	reg &= ~((0x1F) << RX_VGA_GAIN_SHIFT);
 163              		.loc 2 155 0
 164 002c A33AA0E1 		mov	r3, r3, lsr #21
 165              		.loc 2 157 0
 166 0030 803583E1 		orr	r3, r3, r0, asl #11
 167 0034 0338A0E1 		mov	r3, r3, asl #16
 168 0038 2338A0E1 		mov	r3, r3, lsr #16
 169              	.LVL11:
 158:rf/trf6151.c  **** 
 159:rf/trf6151.c  **** 	if (high)
 170              		.loc 2 159 0
 171 003c 000051E3 		cmp	r1, #0
 160:rf/trf6151.c  **** 		reg |= RX_RF_GAIN_HIGH;
 161:rf/trf6151.c  **** 	else
 162:rf/trf6151.c  **** 		reg &= ~RX_RF_GAIN_HIGH;
 163:rf/trf6151.c  **** 
 164:rf/trf6151.c  **** 	trf6151_reg_write(REG_RX, reg);
 172              		.loc 2 164 0
 173 0040 0000A0E3 		mov	r0, #0
 160:rf/trf6151.c  **** 		reg |= RX_RF_GAIN_HIGH;
 174              		.loc 2 160 0
 175 0044 061C8313 		orrne	r1, r3, #1536
 176              	.LVL12:
 162:rf/trf6151.c  **** 		reg &= ~RX_RF_GAIN_HIGH;
 177              		.loc 2 162 0
 178 0048 061CC303 		biceq	r1, r3, #1536
 179              	.LVL13:
 180              		.loc 2 164 0
 181 004c FEFFFFEB 		bl	trf6151_reg_write
 182              	.LVL14:
 165:rf/trf6151.c  **** 
 166:rf/trf6151.c  **** 	return 0;
 183              		.loc 2 166 0
 184 0050 0000A0E3 		mov	r0, #0
 185 0054 04F09DE4 		ldr	pc, [sp], #4
 186              	.LVL15:
 187              	.L17:
 152:rf/trf6151.c  **** 		return -1;
 188              		.loc 2 152 0
 189 0058 0000E0E3 		mvn	r0, #0
 167:rf/trf6151.c  **** }
 190              		.loc 2 167 0
 191 005c 04F09DE4 		ldr	pc, [sp], #4
 192              	.L19:
 193              		.align	2
 194              	.L18:
 195 0060 00000000 		.word	.LANCHOR1
 196              		.cfi_endproc
 197              	.LFE12:
 199              		.section	.text.trf6151_set_gain,"ax",%progbits
 200              		.align	2
 201              		.global	trf6151_set_gain
 203              	trf6151_set_gain:
 204              	.LFB13:
 168:rf/trf6151.c  **** 
 169:rf/trf6151.c  **** int trf6151_set_gain(uint8_t dbm)
 170:rf/trf6151.c  **** {
 205              		.loc 2 170 0
 206              		.cfi_startproc
 207              		@ args = 0, pretend = 0, frame = 0
 208              		@ frame_needed = 0, uses_anonymous_args = 0
 209              		@ link register save eliminated.
 210              	.LVL16:
 211              		.loc 2 170 0
 212 0000 FF0000E2 		and	r0, r0, #255
 213              	.LVL17:
 171:rf/trf6151.c  **** 	int high = 0;
 172:rf/trf6151.c  **** 
 173:rf/trf6151.c  **** 	printd("trf6151_set_gain(%u, %d)\n", dbm);
 174:rf/trf6151.c  **** 	/* If this is negative or less than TRF6151_GAIN_MIN, we are pretty
 175:rf/trf6151.c  **** 	 * much lost as we cannot reduce the system inherent gain.  If it is
 176:rf/trf6151.c  **** 	 * positive, it corresponds to the gain that we need to configure */
 177:rf/trf6151.c  **** 	if (dbm < TRF6151_FE_GAIN_LOW + TRF6151_VGA_GAIN_MIN) {
 214              		.loc 2 177 0
 215 0004 140050E3 		cmp	r0, #20
 216 0008 0500008A 		bhi	.L21
 178:rf/trf6151.c  **** 		printd("AGC Input level overflow\n");
 179:rf/trf6151.c  **** 		trf6151_vga_dbm = TRF6151_VGA_GAIN_MIN;
 217              		.loc 2 179 0
 218 000c 5C309FE5 		ldr	r3, .L28
 219 0010 0E20A0E3 		mov	r2, #14
 220 0014 1020C3E5 		strb	r2, [r3, #16]
 180:rf/trf6151.c  **** 		trf6151_gain_high = 0;
 221              		.loc 2 180 0
 222 0018 0020A0E3 		mov	r2, #0
 223 001c 142083E5 		str	r2, [r3, #20]
 181:rf/trf6151.c  **** 		return 0;
 224              		.loc 2 181 0
 225 0020 100000EA 		b	.L22
 226              	.L21:
 182:rf/trf6151.c  **** 	} else if (dbm >= TRF6151_FE_GAIN_HIGH + TRF6151_VGA_GAIN_MIN) {
 227              		.loc 2 182 0
 228 0024 280050E3 		cmp	r0, #40
 229 0028 0500009A 		bls	.L23
 230              	.LVL18:
 183:rf/trf6151.c  **** 		high = 1;
 184:rf/trf6151.c  **** 		dbm -= TRF6151_FE_GAIN_HIGH;
 231              		.loc 2 184 0
 232 002c 1B0040E2 		sub	r0, r0, #27
 233 0030 FF0000E2 		and	r0, r0, #255
 234              	.LVL19:
 185:rf/trf6151.c  **** 	} else
 186:rf/trf6151.c  **** 		dbm -= TRF6151_FE_GAIN_LOW;
 187:rf/trf6151.c  **** 	if (dbm > TRF6151_VGA_GAIN_MAX)
 235              		.loc 2 187 0
 236 0034 280050E3 		cmp	r0, #40
 183:rf/trf6151.c  **** 		high = 1;
 237              		.loc 2 183 0
 238 0038 0130A093 		movls	r3, #1
 239              		.loc 2 187 0
 240 003c 0400008A 		bhi	.L27
 241 0040 050000EA 		b	.L24
 242              	.LVL20:
 243              	.L23:
 186:rf/trf6151.c  **** 		dbm -= TRF6151_FE_GAIN_LOW;
 244              		.loc 2 186 0
 245 0044 070040E2 		sub	r0, r0, #7
 246 0048 FF0000E2 		and	r0, r0, #255
 247              	.LVL21:
 171:rf/trf6151.c  **** 	int high = 0;
 248              		.loc 2 171 0
 249 004c 0030A0E3 		mov	r3, #0
 250 0050 010000EA 		b	.L24
 251              	.LVL22:
 252              	.L27:
 183:rf/trf6151.c  **** 		high = 1;
 253              		.loc 2 183 0
 254 0054 0130A0E3 		mov	r3, #1
 188:rf/trf6151.c  **** 		dbm = TRF6151_VGA_GAIN_MAX;
 255              		.loc 2 188 0
 256 0058 2800A0E3 		mov	r0, #40
 257              	.LVL23:
 258              	.L24:
 189:rf/trf6151.c  **** 
 190:rf/trf6151.c  **** 	/* update the static global variables which are used when programming
 191:rf/trf6151.c  **** 	 * the window */
 192:rf/trf6151.c  **** 	trf6151_vga_dbm = dbm;
 259              		.loc 2 192 0
 260 005c 0C209FE5 		ldr	r2, .L28
 261 0060 1000C2E5 		strb	r0, [r2, #16]
 193:rf/trf6151.c  **** 	trf6151_gain_high = high;
 262              		.loc 2 193 0
 263 0064 143082E5 		str	r3, [r2, #20]
 264              	.LVL24:
 265              	.L22:
 194:rf/trf6151.c  **** 
 195:rf/trf6151.c  **** 	return 0;
 196:rf/trf6151.c  **** }
 266              		.loc 2 196 0
 267 0068 0000A0E3 		mov	r0, #0
 268 006c 1EFF2FE1 		bx	lr
 269              	.L29:
 270              		.align	2
 271              	.L28:
 272 0070 00000000 		.word	.LANCHOR1
 273              		.cfi_endproc
 274              	.LFE13:
 276              		.section	.text.trf6151_power,"ax",%progbits
 277              		.align	2
 278              		.global	trf6151_power
 280              	trf6151_power:
 281              	.LFB18:
 197:rf/trf6151.c  **** 
 198:rf/trf6151.c  **** #define SCALE_100KHZ	100
 199:rf/trf6151.c  **** 
 200:rf/trf6151.c  **** /* Compute TRF6151 PLL valuese */
 201:rf/trf6151.c  **** static void trf6151_pll_rx(uint32_t freq_khz,
 202:rf/trf6151.c  ****                            uint16_t *pll_config, enum trf6151_gsm_band *band)
 203:rf/trf6151.c  **** {
 204:rf/trf6151.c  **** 	const uint32_t p=64, r=65;
 205:rf/trf6151.c  **** 	uint32_t freq_100khz, vco_freq_100khz;
 206:rf/trf6151.c  **** 	uint32_t l, n;
 207:rf/trf6151.c  **** 	uint32_t a, b;
 208:rf/trf6151.c  **** 
 209:rf/trf6151.c  **** 	/* Scale into 100kHz unit (avoid overflow in intermediates) */
 210:rf/trf6151.c  **** 	freq_100khz = freq_khz / SCALE_100KHZ;
 211:rf/trf6151.c  **** 
 212:rf/trf6151.c  **** 	/* L selects hi/lo band */
 213:rf/trf6151.c  **** 	l = (freq_khz > 1350000) ? 2 : 4; /* cut at mid point :) */
 214:rf/trf6151.c  **** 
 215:rf/trf6151.c  **** 	/* VCO frequency */
 216:rf/trf6151.c  **** 	vco_freq_100khz = freq_100khz * l;
 217:rf/trf6151.c  **** 
 218:rf/trf6151.c  **** 	/* vco_freq = 26MHz / R * N  with R=65 and N=B*P+A */
 219:rf/trf6151.c  **** 	n = (vco_freq_100khz * r) / 260;
 220:rf/trf6151.c  **** 	a = n % p;
 221:rf/trf6151.c  **** 	b = n / p;
 222:rf/trf6151.c  **** 
 223:rf/trf6151.c  **** 	*pll_config = PLL_VAL(a, b);
 224:rf/trf6151.c  **** 
 225:rf/trf6151.c  **** 	/* Out-of-spec tuning warning */
 226:rf/trf6151.c  **** #ifdef WARN_OUT_OF_SPEC
 227:rf/trf6151.c  **** 	if ((l == 4 && (b < 135 || b > 150)) ||
 228:rf/trf6151.c  **** 	    (l == 2 && (b < 141 || b > 155)))
 229:rf/trf6151.c  **** 		printf("Frequency %u kHz is out of spec\n", (unsigned int)freq_khz);
 230:rf/trf6151.c  **** #endif
 231:rf/trf6151.c  **** 
 232:rf/trf6151.c  **** 	/* Select band */
 233:rf/trf6151.c  **** 	if (l==4) {
 234:rf/trf6151.c  **** 		/* If in the low band, same port for both GSM850/GSM900, so we
 235:rf/trf6151.c  **** 		 * choose the best VCO (VCOMAIN1=3.37GHz, VCOMAIN2=3.8GHz) */
 236:rf/trf6151.c  **** 		if (vco_freq_100khz < 35850) /* midpoint */
 237:rf/trf6151.c  **** 			*band = GSM850_LOW;
 238:rf/trf6151.c  **** 		else
 239:rf/trf6151.c  **** 			*band = GSM900;
 240:rf/trf6151.c  **** 
 241:rf/trf6151.c  **** 		/* Out-of-spec freq check */
 242:rf/trf6151.c  **** #ifdef WARN_OUT_OF_SPEC
 243:rf/trf6151.c  **** 		if (!(freq_khz >= 869000 && freq_khz <= 894000) &&
 244:rf/trf6151.c  **** 		    !(freq_khz >= 921000 && freq_khz <= 960000)) /* include GSM-R */
 245:rf/trf6151.c  **** 			printf("Frequency %u outside normal filter range for selected port\n", (unsigned int)freq_khz);
 246:rf/trf6151.c  **** #endif
 247:rf/trf6151.c  **** 	} else {
 248:rf/trf6151.c  **** 		/* In the high band, different ports for DCS/PCS, so
 249:rf/trf6151.c  **** 		 * take what's best and available */
 250:rf/trf6151.c  **** 		/* We're stuck to VCOMAIN2=3.8GHz though ... */
 251:rf/trf6151.c  **** 		uint32_t rx_ports = rffe_get_rx_ports();
 252:rf/trf6151.c  **** 		uint32_t port;
 253:rf/trf6151.c  **** 
 254:rf/trf6151.c  **** 		/* Select port */
 255:rf/trf6151.c  **** 		port = (freq_khz < 1905000) ? (1 << PORT_DCS1800) : (1 << PORT_PCS1900);
 256:rf/trf6151.c  **** 		port = (port & rx_ports) ? port : rx_ports;
 257:rf/trf6151.c  **** 
 258:rf/trf6151.c  **** 		/* Select band */
 259:rf/trf6151.c  **** 		*band = (port & (1 << PORT_DCS1800)) ? GSM1800 : GSM1900;
 260:rf/trf6151.c  **** 
 261:rf/trf6151.c  **** 		/* Out-of-spec freq check */
 262:rf/trf6151.c  **** #ifdef WARN_OUT_OF_SPEC
 263:rf/trf6151.c  **** 		if ((*band == GSM1800 && (freq_khz < 1805000 || freq_khz > 1880000)) ||
 264:rf/trf6151.c  **** 		    (*band == GSM1900 && (freq_khz < 1930000 || freq_khz > 1990000)))
 265:rf/trf6151.c  **** 			printf("Frequency %u outside normal filter range for selected port\n", (unsigned int)freq_khz);
 266:rf/trf6151.c  **** #endif
 267:rf/trf6151.c  **** 	}
 268:rf/trf6151.c  **** 
 269:rf/trf6151.c  **** 	/* Debug */
 270:rf/trf6151.c  **** 	printd("RX Freq %u kHz => A = %u, B = %u, band = %d, vco_freq = %u kHz\n", freq_khz, a, b, *band, 
 271:rf/trf6151.c  **** 
 272:rf/trf6151.c  **** 	/* All done */
 273:rf/trf6151.c  **** 	return;
 274:rf/trf6151.c  **** }
 275:rf/trf6151.c  **** 
 276:rf/trf6151.c  **** /* Compute TRF6151 PLL TX values */
 277:rf/trf6151.c  **** static void trf6151_pll_tx(uint32_t freq_khz,
 278:rf/trf6151.c  ****                            uint16_t *pll_config, enum trf6151_gsm_band *band)
 279:rf/trf6151.c  **** {
 280:rf/trf6151.c  **** 	const uint32_t p=64;
 281:rf/trf6151.c  **** 	uint32_t r, l, m, m_op_l; /* m_op_l = m +/- l depending on mode */
 282:rf/trf6151.c  **** 	uint32_t freq_100khz;
 283:rf/trf6151.c  **** 	uint32_t n, a, b, b_min, b_max;
 284:rf/trf6151.c  **** 
 285:rf/trf6151.c  **** 	/* Scale into 100kHz unit (avoid overflow in intermediates) */
 286:rf/trf6151.c  **** 	freq_100khz = freq_khz / SCALE_100KHZ;
 287:rf/trf6151.c  **** 
 288:rf/trf6151.c  **** 	/* Select band (and PLL mode) */
 289:rf/trf6151.c  **** 	if (freq_khz > 1350000) {
 290:rf/trf6151.c  **** 		/* High band, so only 1 real PLL mode. band doesn't matter
 291:rf/trf6151.c  **** 		 * that much (or at all) but we still do it :p */
 292:rf/trf6151.c  **** 		*band = (freq_khz < 1817500) ? GSM1800 : GSM1900;
 293:rf/trf6151.c  **** 		r = 70;
 294:rf/trf6151.c  **** 		l = 2;
 295:rf/trf6151.c  **** 		m = 26;
 296:rf/trf6151.c  **** 		m_op_l = m + l;
 297:rf/trf6151.c  **** 		b_min = 133;
 298:rf/trf6151.c  **** 		b_max = 149;
 299:rf/trf6151.c  **** 	} else {
 300:rf/trf6151.c  **** 		/* Low band. We have 3 possible PLL modes that output on
 301:rf/trf6151.c  **** 		 * the right port: GSM900, GSM850_HIGH, GSM850_LOW.
 302:rf/trf6151.c  **** 		 *
 303:rf/trf6151.c  **** 		 * The transistion points have been chosen looking at the VCO
 304:rf/trf6151.c  **** 		 * and IF frequencies for various frequencies for theses modes
 305:rf/trf6151.c  **** 		 */
 306:rf/trf6151.c  **** 		if (freq_khz < 837100) {
 307:rf/trf6151.c  **** 			/* GSM850_LOW */
 308:rf/trf6151.c  **** 			*band = GSM850_LOW;
 309:rf/trf6151.c  **** 			r = 55;
 310:rf/trf6151.c  **** 			l = 4;
 311:rf/trf6151.c  **** 			m = 26;
 312:rf/trf6151.c  **** 			m_op_l = m - l;
 313:rf/trf6151.c  **** 			b_min = 128;
 314:rf/trf6151.c  **** 			b_max = 130;
 315:rf/trf6151.c  **** 		} else if (freq_khz < 850000) {
 316:rf/trf6151.c  **** 			/* GSM850_HIGH */
 317:rf/trf6151.c  **** 			*band = GSM850_HIGH;
 318:rf/trf6151.c  **** 			r = 30;
 319:rf/trf6151.c  **** 			l = 4;
 320:rf/trf6151.c  **** 			m = 52;
 321:rf/trf6151.c  **** 			m_op_l = m - l;
 322:rf/trf6151.c  **** 			b_min = 65;
 323:rf/trf6151.c  **** 			b_max = 66;
 324:rf/trf6151.c  **** 		} else {
 325:rf/trf6151.c  **** 			/* GSM900 */
 326:rf/trf6151.c  **** 			*band = GSM900;
 327:rf/trf6151.c  **** 			r = 35;
 328:rf/trf6151.c  **** 			l = 4;
 329:rf/trf6151.c  **** 			m = 52;
 330:rf/trf6151.c  **** 			m_op_l = m + l;
 331:rf/trf6151.c  **** 			b_min = 68;
 332:rf/trf6151.c  **** 			b_max = 71;
 333:rf/trf6151.c  **** 		}
 334:rf/trf6151.c  **** 	}
 335:rf/trf6151.c  **** 
 336:rf/trf6151.c  **** 	/* vco_freq = f * M * L / (M +- L)                 */
 337:rf/trf6151.c  **** 	/*          = 26MHz / R * N  with R=65 and N=B*P+A */
 338:rf/trf6151.c  **** 	n = (freq_100khz * m * l * r) / (m_op_l * 260);
 339:rf/trf6151.c  **** 	a = n % p;
 340:rf/trf6151.c  **** 	b = n / p;
 341:rf/trf6151.c  **** 
 342:rf/trf6151.c  **** 	*pll_config = PLL_VAL(a, b);
 343:rf/trf6151.c  **** 
 344:rf/trf6151.c  **** 	/* Debug */
 345:rf/trf6151.c  **** 	printd("TX Freq %u kHz => A = %u, B = %u, band = %d\n", freq_khz, a, b, *band);
 346:rf/trf6151.c  **** 
 347:rf/trf6151.c  **** 	/* Out-of-spec tuning warning */
 348:rf/trf6151.c  **** #ifdef WARN_OUT_OF_SPEC
 349:rf/trf6151.c  **** 	if (b < b_min || b > b_max)
 350:rf/trf6151.c  **** 		printf("Frequency %u kHz is out of spec\n", (unsigned int)freq_khz);
 351:rf/trf6151.c  **** #endif
 352:rf/trf6151.c  **** 
 353:rf/trf6151.c  **** 	/* All done */
 354:rf/trf6151.c  **** 	return;
 355:rf/trf6151.c  **** }
 356:rf/trf6151.c  **** 
 357:rf/trf6151.c  **** static inline void trf6151_reset(uint16_t reset_id)
 358:rf/trf6151.c  **** {
 359:rf/trf6151.c  **** 	/* pull the nRESET line low */
 360:rf/trf6151.c  **** 	tsp_act_disable(reset_id);
 361:rf/trf6151.c  **** 	tpu_enq_wait(50);
 362:rf/trf6151.c  **** 	/* release nRESET */
 363:rf/trf6151.c  **** 	tsp_act_enable(reset_id);
 364:rf/trf6151.c  **** }
 365:rf/trf6151.c  **** 
 366:rf/trf6151.c  **** void trf6151_init(uint8_t tsp_uid, uint16_t tsp_reset_id)
 367:rf/trf6151.c  **** {
 368:rf/trf6151.c  **** 	trf6151_tsp_uid = tsp_uid;
 369:rf/trf6151.c  **** 
 370:rf/trf6151.c  **** 	/* Configure the TSPEN which is connected to TRF6151 STROBE */
 371:rf/trf6151.c  **** 	tsp_setup(trf6151_tsp_uid, 0, 1, 1);
 372:rf/trf6151.c  **** 
 373:rf/trf6151.c  **** 	trf6151_reset(tsp_reset_id);
 374:rf/trf6151.c  **** 
 375:rf/trf6151.c  **** 	/* configure TRF6151 for operation */
 376:rf/trf6151.c  **** 	trf6151_power(1);
 377:rf/trf6151.c  **** 	trf6151_reg_write(REG_CFG, TRF6151_PACTRL_CFG | CFG_ILOGIC_INIT_DIS);
 378:rf/trf6151.c  **** 
 379:rf/trf6151.c  **** 	/* FIXME: Uplink / Downlink Calibration */
 380:rf/trf6151.c  **** }
 381:rf/trf6151.c  **** 
 382:rf/trf6151.c  **** void trf6151_power(int on)
 383:rf/trf6151.c  **** {
 282              		.loc 2 383 0
 283              		.cfi_startproc
 284              		@ args = 0, pretend = 0, frame = 0
 285              		@ frame_needed = 0, uses_anonymous_args = 0
 286              	.LVL25:
 384:rf/trf6151.c  **** 	if (on) {
 287              		.loc 2 384 0
 288 0000 000050E3 		cmp	r0, #0
 383:rf/trf6151.c  **** {
 289              		.loc 2 383 0
 290 0004 04E02DE5 		str	lr, [sp, #-4]!
 291              	.LCFI2:
 292              		.cfi_def_cfa_offset 4
 293              		.loc 2 384 0
 294 0008 0F00000A 		beq	.L31
 295              		.cfi_offset 14, -4
 385:rf/trf6151.c  **** 		trf6151_reg_write(REG_PWR, PWR_REGUL_ON | PWR_BANDGAP_ON);
 296              		.loc 2 385 0
 297 000c 3810A0E3 		mov	r1, #56
 298 0010 0200A0E3 		mov	r0, #2
 299              	.LVL26:
 300 0014 FEFFFFEB 		bl	trf6151_reg_write
 386:rf/trf6151.c  **** 		/* wait until regulators are stable (25ms == 27100 qbits) */
 387:rf/trf6151.c  **** 		tpu_enq_wait(5000);
 301              		.loc 2 387 0
 302 0018 3C009FE5 		ldr	r0, .L32
 303 001c FEFFFFEB 		bl	tpu_enq_wait
 388:rf/trf6151.c  **** 		tpu_enq_wait(5000);
 304              		.loc 2 388 0
 305 0020 34009FE5 		ldr	r0, .L32
 306 0024 FEFFFFEB 		bl	tpu_enq_wait
 389:rf/trf6151.c  **** 		tpu_enq_wait(5000);
 307              		.loc 2 389 0
 308 0028 2C009FE5 		ldr	r0, .L32
 309 002c FEFFFFEB 		bl	tpu_enq_wait
 390:rf/trf6151.c  **** 		tpu_enq_wait(5000);
 310              		.loc 2 390 0
 311 0030 24009FE5 		ldr	r0, .L32
 312 0034 FEFFFFEB 		bl	tpu_enq_wait
 391:rf/trf6151.c  **** 		tpu_enq_wait(5000);
 313              		.loc 2 391 0
 314 0038 1C009FE5 		ldr	r0, .L32
 315 003c FEFFFFEB 		bl	tpu_enq_wait
 392:rf/trf6151.c  **** 		tpu_enq_wait(2100);
 316              		.loc 2 392 0
 317 0040 18009FE5 		ldr	r0, .L32+4
 393:rf/trf6151.c  **** 	} else
 394:rf/trf6151.c  **** 		trf6151_reg_write(REG_PWR, PWR_BANDGAP_ON);
 395:rf/trf6151.c  **** }
 318              		.loc 2 395 0
 319 0044 04E09DE4 		ldr	lr, [sp], #4
 392:rf/trf6151.c  **** 		tpu_enq_wait(2100);
 320              		.loc 2 392 0
 321 0048 FEFFFFEA 		b	tpu_enq_wait
 322              	.LVL27:
 323              	.L31:
 394:rf/trf6151.c  **** 		trf6151_reg_write(REG_PWR, PWR_BANDGAP_ON);
 324              		.loc 2 394 0
 325 004c 0200A0E3 		mov	r0, #2
 326              	.LVL28:
 327 0050 1810A0E3 		mov	r1, #24
 328              		.loc 2 395 0
 329 0054 04E09DE4 		ldr	lr, [sp], #4
 394:rf/trf6151.c  **** 		trf6151_reg_write(REG_PWR, PWR_BANDGAP_ON);
 330              		.loc 2 394 0
 331 0058 FEFFFFEA 		b	trf6151_reg_write
 332              	.L33:
 333              		.align	2
 334              	.L32:
 335 005c 88130000 		.word	5000
 336 0060 34080000 		.word	2100
 337              		.cfi_endproc
 338              	.LFE18:
 340              		.section	.text.trf6151_init,"ax",%progbits
 341              		.align	2
 342              		.global	trf6151_init
 344              	trf6151_init:
 345              	.LFB17:
 367:rf/trf6151.c  **** {
 346              		.loc 2 367 0
 347              		.cfi_startproc
 348              		@ args = 0, pretend = 0, frame = 0
 349              		@ frame_needed = 0, uses_anonymous_args = 0
 350              	.LVL29:
 368:rf/trf6151.c  **** 	trf6151_tsp_uid = tsp_uid;
 351              		.loc 2 368 0
 352 0000 50309FE5 		ldr	r3, .L35
 371:rf/trf6151.c  **** 	tsp_setup(trf6151_tsp_uid, 0, 1, 1);
 353              		.loc 2 371 0
 354 0004 0120A0E3 		mov	r2, #1
 367:rf/trf6151.c  **** {
 355              		.loc 2 367 0
 356 0008 FF0000E2 		and	r0, r0, #255
 357              	.LVL30:
 358 000c 0118A0E1 		mov	r1, r1, asl #16
 359              	.LVL31:
 360 0010 10402DE9 		stmfd	sp!, {r4, lr}
 361              	.LCFI3:
 362              		.cfi_def_cfa_offset 8
 367:rf/trf6151.c  **** {
 363              		.loc 2 367 0
 364 0014 2148A0E1 		mov	r4, r1, lsr #16
 365              		.cfi_offset 14, -4
 366              		.cfi_offset 4, -8
 368:rf/trf6151.c  **** 	trf6151_tsp_uid = tsp_uid;
 367              		.loc 2 368 0
 368 0018 0000C3E5 		strb	r0, [r3, #0]
 371:rf/trf6151.c  **** 	tsp_setup(trf6151_tsp_uid, 0, 1, 1);
 369              		.loc 2 371 0
 370 001c 0010A0E3 		mov	r1, #0
 371 0020 0230A0E1 		mov	r3, r2
 372 0024 FEFFFFEB 		bl	tsp_setup
 373              	.LVL32:
 374              	.LBB19:
 375              	.LBB20:
 360:rf/trf6151.c  **** 	tsp_act_disable(reset_id);
 376              		.loc 2 360 0
 377 0028 0400A0E1 		mov	r0, r4
 378 002c FEFFFFEB 		bl	tsp_act_disable
 361:rf/trf6151.c  **** 	tpu_enq_wait(50);
 379              		.loc 2 361 0
 380 0030 3200A0E3 		mov	r0, #50
 381 0034 FEFFFFEB 		bl	tpu_enq_wait
 363:rf/trf6151.c  **** 	tsp_act_enable(reset_id);
 382              		.loc 2 363 0
 383 0038 0400A0E1 		mov	r0, r4
 384 003c FEFFFFEB 		bl	tsp_act_enable
 385              	.LBE20:
 386              	.LBE19:
 376:rf/trf6151.c  **** 	trf6151_power(1);
 387              		.loc 2 376 0
 388 0040 0100A0E3 		mov	r0, #1
 389 0044 FEFFFFEB 		bl	trf6151_power
 377:rf/trf6151.c  **** 	trf6151_reg_write(REG_CFG, TRF6151_PACTRL_CFG | CFG_ILOGIC_INIT_DIS);
 390              		.loc 2 377 0
 391 0048 0300A0E3 		mov	r0, #3
 392 004c 0219A0E3 		mov	r1, #32768
 380:rf/trf6151.c  **** }
 393              		.loc 2 380 0
 394 0050 1040BDE8 		ldmfd	sp!, {r4, lr}
 377:rf/trf6151.c  **** 	trf6151_reg_write(REG_CFG, TRF6151_PACTRL_CFG | CFG_ILOGIC_INIT_DIS);
 395              		.loc 2 377 0
 396 0054 FEFFFFEA 		b	trf6151_reg_write
 397              	.L36:
 398              		.align	2
 399              	.L35:
 400 0058 00000000 		.word	.LANCHOR0
 401              		.cfi_endproc
 402              	.LFE17:
 404              		.section	.text.trf6151_set_mode,"ax",%progbits
 405              		.align	2
 406              		.global	trf6151_set_mode
 408              	trf6151_set_mode:
 409              	.LFB19:
 396:rf/trf6151.c  **** 
 397:rf/trf6151.c  **** /* Set the operational mode of the TRF6151 chip */
 398:rf/trf6151.c  **** void trf6151_set_mode(enum trf6151_mode mode)
 399:rf/trf6151.c  **** {
 410              		.loc 2 399 0
 411              		.cfi_startproc
 412              		@ args = 0, pretend = 0, frame = 0
 413              		@ frame_needed = 0, uses_anonymous_args = 0
 414              		@ link register save eliminated.
 415              	.LVL33:
 400:rf/trf6151.c  **** 	uint16_t pwr = (PWR_REGUL_ON | PWR_BANDGAP_ON | (rf_band<<6));
 416              		.loc 2 400 0
 417 0000 28309FE5 		ldr	r3, .L41
 418 0004 B210D3E1 		ldrh	r1, [r3, #2]
 419 0008 011BA0E1 		mov	r1, r1, asl #22
 420 000c 0E1781E3 		orr	r1, r1, #3670016
 421 0010 2118A0E1 		mov	r1, r1, lsr #16
 422              	.LVL34:
 401:rf/trf6151.c  **** 
 402:rf/trf6151.c  **** 	switch (mode) {
 423              		.loc 2 402 0
 424 0014 010050E3 		cmp	r0, #1
 403:rf/trf6151.c  **** 	case TRF6151_IDLE:
 404:rf/trf6151.c  **** 		/* should we switch of the RF gain for power saving? */
 405:rf/trf6151.c  **** 		break;
 406:rf/trf6151.c  **** 	case TRF6151_RX:
 407:rf/trf6151.c  **** 		pwr |= (PWR_SYNTHE_RX_ON | PWR_RX_MODE);
 425              		.loc 2 407 0
 426 0018 0A1C8103 		orreq	r1, r1, #2560
 427              	.LVL35:
 402:rf/trf6151.c  **** 	switch (mode) {
 428              		.loc 2 402 0
 429 001c 0100000A 		beq	.L38
 430 0020 020050E3 		cmp	r0, #2
 408:rf/trf6151.c  **** 		break;
 409:rf/trf6151.c  **** 	case TRF6151_TX:
 410:rf/trf6151.c  **** #if 0
 411:rf/trf6151.c  **** 		pwr |= (PWR_SYNTHE_TX_ON | PWR_TX_MODE);
 412:rf/trf6151.c  **** #else // Dieter: we should turn power control on (for TPU: check timing and order !)
 413:rf/trf6151.c  **** 		pwr |= (PWR_SYNTHE_TX_ON | PWR_TX_MODE | PWR_PACTRL_APC | PWR_PACTRL_APCEN); // Dieter: TODO
 431              		.loc 2 413 0
 432 0024 391B8103 		orreq	r1, r1, #58368
 433              	.LVL36:
 434              	.L38:
 414:rf/trf6151.c  **** #endif
 415:rf/trf6151.c  **** 		break;
 416:rf/trf6151.c  **** 	}
 417:rf/trf6151.c  **** 	trf6151_reg_write(REG_PWR, pwr);
 435              		.loc 2 417 0
 436 0028 0200A0E3 		mov	r0, #2
 437              	.LVL37:
 418:rf/trf6151.c  **** }
 438              		.loc 2 418 0
 417:rf/trf6151.c  **** 	trf6151_reg_write(REG_PWR, pwr);
 439              		.loc 2 417 0
 440 002c FEFFFFEA 		b	trf6151_reg_write
 441              	.LVL38:
 442              	.L42:
 443              		.align	2
 444              	.L41:
 445 0030 00000000 		.word	.LANCHOR0
 446              		.cfi_endproc
 447              	.LFE19:
 449              		.global	__udivsi3
 450              		.section	.text.trf6151_set_arfcn,"ax",%progbits
 451              		.align	2
 452              		.global	trf6151_set_arfcn
 454              	trf6151_set_arfcn:
 455              	.LFB21:
 419:rf/trf6151.c  **** 
 420:rf/trf6151.c  **** static void trf6151_band_select(enum trf6151_gsm_band band)
 421:rf/trf6151.c  **** {
 422:rf/trf6151.c  **** 	uint16_t pwr = trf6151_reg_cache[REG_PWR];
 423:rf/trf6151.c  **** 
 424:rf/trf6151.c  **** 	pwr &= ~(3 << 6);
 425:rf/trf6151.c  **** 	pwr |= (band << 6);
 426:rf/trf6151.c  **** 
 427:rf/trf6151.c  **** 	trf6151_reg_write(REG_PWR, pwr);
 428:rf/trf6151.c  **** }
 429:rf/trf6151.c  **** 
 430:rf/trf6151.c  **** /* Set ARFCN.  Takes 2 reg_write, i.e. 8 TPU instructions */
 431:rf/trf6151.c  **** void trf6151_set_arfcn(uint16_t arfcn, int tx)
 432:rf/trf6151.c  **** {
 456              		.loc 2 432 0
 457              		.cfi_startproc
 458              		@ args = 0, pretend = 0, frame = 0
 459              		@ frame_needed = 0, uses_anonymous_args = 0
 460              	.LVL39:
 461 0000 0008A0E1 		mov	r0, r0, asl #16
 462              	.LVL40:
 463 0004 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 464              	.LCFI4:
 465              		.cfi_def_cfa_offset 24
 466              		.loc 2 432 0
 467 0008 2068A0E1 		mov	r6, r0, lsr #16
 468              		.cfi_offset 14, -4
 469              		.cfi_offset 8, -8
 470              		.cfi_offset 7, -12
 471              		.cfi_offset 6, -16
 472              		.cfi_offset 5, -20
 473              		.cfi_offset 4, -24
 433:rf/trf6151.c  **** 	uint32_t freq_khz;
 434:rf/trf6151.c  **** 	uint16_t pll_config;
 435:rf/trf6151.c  **** 	int uplink;
 436:rf/trf6151.c  **** 	enum trf6151_gsm_band pll_band;
 437:rf/trf6151.c  **** 
 438:rf/trf6151.c  **** 	uplink = !!(arfcn & ARFCN_UPLINK);
 474              		.loc 2 438 0
 475 000c 010916E3 		tst	r6, #16384
 439:rf/trf6151.c  **** 	arfcn != ~ARFCN_UPLINK;
 440:rf/trf6151.c  **** 
 441:rf/trf6151.c  **** 	switch (gsm_arfcn2band(arfcn)) {
 476              		.loc 2 441 0
 477 0010 0600A0E1 		mov	r0, r6
 438:rf/trf6151.c  **** 	uplink = !!(arfcn & ARFCN_UPLINK);
 478              		.loc 2 438 0
 479 0014 0050A003 		moveq	r5, #0
 480 0018 0150A013 		movne	r5, #1
 481              	.LVL41:
 432:rf/trf6151.c  **** {
 482              		.loc 2 432 0
 483 001c 0140A0E1 		mov	r4, r1
 484              		.loc 2 441 0
 485 0020 FEFFFFEB 		bl	gsm_arfcn2band
 486              	.LVL42:
 487 0024 200050E3 		cmp	r0, #32
 488 0028 0600000A 		beq	.L45
 489 002c 0100008A 		bhi	.L46
 490 0030 100050E3 		cmp	r0, #16
 491 0034 020000EA 		b	.L63
 492              	.L46:
 493 0038 400050E3 		cmp	r0, #64
 494 003c 0100000A 		beq	.L45
 495 0040 800050E3 		cmp	r0, #128
 496              	.L63:
 497 0044 0100001A 		bne	.L44
 498              	.L45:
 442:rf/trf6151.c  **** 	case GSM_BAND_850:
 443:rf/trf6151.c  **** 	case GSM_BAND_900:
 444:rf/trf6151.c  **** 	case GSM_BAND_1800:
 445:rf/trf6151.c  **** 	case GSM_BAND_1900:
 446:rf/trf6151.c  **** 		/* Supported */
 447:rf/trf6151.c  **** 		break;
 448:rf/trf6151.c  **** 	case GSM_BAND_450:
 449:rf/trf6151.c  **** 	case GSM_BAND_480:
 450:rf/trf6151.c  **** 	case GSM_BAND_750:
 451:rf/trf6151.c  **** 	case GSM_BAND_810:
 452:rf/trf6151.c  **** 		printf("Unsupported band ! YMMV.\n");
 499              		.loc 2 452 0
 500 0048 A8019FE5 		ldr	r0, .L65
 501 004c FEFFFFEB 		bl	puts
 502              	.L44:
 453:rf/trf6151.c  **** 		break;
 454:rf/trf6151.c  **** 	}
 455:rf/trf6151.c  **** 
 456:rf/trf6151.c  **** 	freq_khz = gsm_arfcn2freq10(arfcn, uplink) * 100;
 503              		.loc 2 456 0
 504 0050 0510A0E1 		mov	r1, r5
 505 0054 0600A0E1 		mov	r0, r6
 506 0058 FEFFFFEB 		bl	gsm_arfcn2freq10
 507 005c 6410A0E3 		mov	r1, #100
 457:rf/trf6151.c  **** 	printd("ARFCN %u -> %u kHz\n", arfcn, freq_khz);
 458:rf/trf6151.c  **** 
 459:rf/trf6151.c  **** 	if (!tx)
 508              		.loc 2 459 0
 509 0060 000054E3 		cmp	r4, #0
 456:rf/trf6151.c  **** 	freq_khz = gsm_arfcn2freq10(arfcn, uplink) * 100;
 510              		.loc 2 456 0
 511 0064 910005E0 		mul	r5, r1, r0
 512              	.LVL43:
 513              		.loc 2 459 0
 514 0068 2200001A 		bne	.L47
 515              	.LVL44:
 516              	.LBB21:
 517              	.LBB22:
 210:rf/trf6151.c  **** 	freq_100khz = freq_khz / SCALE_100KHZ;
 518              		.loc 2 210 0
 519 006c 0500A0E1 		mov	r0, r5
 520 0070 FEFFFFEB 		bl	__udivsi3
 521              	.LVL45:
 213:rf/trf6151.c  **** 	l = (freq_khz > 1350000) ? 2 : 4; /* cut at mid point :) */
 522              		.loc 2 213 0
 523 0074 80819FE5 		ldr	r8, .L65+4
 524 0078 080055E1 		cmp	r5, r8
 525 007c 0480A093 		movls	r8, #4
 526 0080 0280A083 		movhi	r8, #2
 527              	.LVL46:
 216:rf/trf6151.c  **** 	vco_freq_100khz = freq_100khz * l;
 528              		.loc 2 216 0
 529 0084 900804E0 		mul	r4, r0, r8
 530              	.LVL47:
 219:rf/trf6151.c  **** 	n = (vco_freq_100khz * r) / 260;
 531              		.loc 2 219 0
 532 0088 411FA0E3 		mov	r1, #260
 533 008c 040384E0 		add	r0, r4, r4, asl #6
 534              	.LVL48:
 535 0090 FEFFFFEB 		bl	__udivsi3
 536              	.LVL49:
 221:rf/trf6151.c  **** 	b = n / p;
 537              		.loc 2 221 0
 538 0094 2073A0E1 		mov	r7, r0, lsr #6
 220:rf/trf6151.c  **** 	a = n % p;
 539              		.loc 2 220 0
 540 0098 3F0000E2 		and	r0, r0, #63
 541              	.LVL50:
 223:rf/trf6151.c  **** 	*pll_config = PLL_VAL(a, b);
 542              		.loc 2 223 0
 543 009c 407047E2 		sub	r7, r7, #64
 544              	.LVL51:
 545 00a0 8001A0E1 		mov	r0, r0, asl #3
 546              	.LVL52:
 547 00a4 877480E1 		orr	r7, r0, r7, asl #9
 548              	.LVL53:
 549 00a8 0778A0E1 		mov	r7, r7, asl #16
 233:rf/trf6151.c  **** 	if (l==4) {
 550              		.loc 2 233 0
 551 00ac 040058E3 		cmp	r8, #4
 223:rf/trf6151.c  **** 	*pll_config = PLL_VAL(a, b);
 552              		.loc 2 223 0
 553 00b0 2778A0E1 		mov	r7, r7, lsr #16
 554              	.LVL54:
 233:rf/trf6151.c  **** 	if (l==4) {
 555              		.loc 2 233 0
 556 00b4 0400001A 		bne	.L49
 237:rf/trf6151.c  **** 			*band = GSM850_LOW;
 557              		.loc 2 237 0
 558 00b8 40319FE5 		ldr	r3, .L65+8
 559 00bc 030054E1 		cmp	r4, r3
 560 00c0 0140A083 		movhi	r4, #1
 561              	.LVL55:
 562 00c4 0440A093 		movls	r4, #4
 563 00c8 3D0000EA 		b	.L50
 564              	.LVL56:
 565              	.L49:
 566              	.LBB23:
 251:rf/trf6151.c  **** 		uint32_t rx_ports = rffe_get_rx_ports();
 567              		.loc 2 251 0
 568 00cc FEFFFFEB 		bl	rffe_get_rx_ports
 569              	.LVL57:
 255:rf/trf6151.c  **** 		port = (freq_khz < 1905000) ? (1 << PORT_DCS1800) : (1 << PORT_PCS1900);
 570              		.loc 2 255 0
 571 00d0 2C319FE5 		ldr	r3, .L65+12
 572 00d4 030055E1 		cmp	r5, r3
 573 00d8 2050A083 		movhi	r5, #32
 574              	.LVL58:
 575 00dc 1050A093 		movls	r5, #16
 576              	.LVL59:
 256:rf/trf6151.c  **** 		port = (port & rx_ports) ? port : rx_ports;
 577              		.loc 2 256 0
 578 00e0 000015E1 		tst	r5, r0
 579 00e4 0500A011 		movne	r0, r5
 580              	.LVL60:
 259:rf/trf6151.c  **** 		*band = (port & (1 << PORT_DCS1800)) ? GSM1800 : GSM1900;
 581              		.loc 2 259 0
 582 00e8 100010E3 		tst	r0, #16
 583 00ec 0640A003 		moveq	r4, #6
 584 00f0 0240A013 		movne	r4, #2
 585              	.LVL61:
 586 00f4 320000EA 		b	.L50
 587              	.LVL62:
 588              	.L47:
 589              	.LBE23:
 590              	.LBE22:
 591              	.LBE21:
 592              	.LBB24:
 593              	.LBB25:
 286:rf/trf6151.c  **** 	freq_100khz = freq_khz / SCALE_100KHZ;
 594              		.loc 2 286 0
 595 00f8 0500A0E1 		mov	r0, r5
 596 00fc FEFFFFEB 		bl	__udivsi3
 597              	.LVL63:
 289:rf/trf6151.c  **** 	if (freq_khz > 1350000) {
 598              		.loc 2 289 0
 599 0100 F4309FE5 		ldr	r3, .L65+4
 600 0104 030055E1 		cmp	r5, r3
 601 0108 0700009A 		bls	.L53
 292:rf/trf6151.c  **** 		*band = (freq_khz < 1817500) ? GSM1800 : GSM1900;
 602              		.loc 2 292 0
 603 010c F4309FE5 		ldr	r3, .L65+16
 604 0110 030055E1 		cmp	r5, r3
 605 0114 1200008A 		bhi	.L59
 606 0118 0240A0E3 		mov	r4, #2
 607              	.LVL64:
 296:rf/trf6151.c  **** 		m_op_l = m + l;
 608              		.loc 2 296 0
 609 011c 1C30A0E3 		mov	r3, #28
 295:rf/trf6151.c  **** 		m = 26;
 610              		.loc 2 295 0
 611 0120 1A10A0E3 		mov	r1, #26
 294:rf/trf6151.c  **** 		l = 2;
 612              		.loc 2 294 0
 613 0124 04C0A0E1 		mov	ip, r4
 614 0128 110000EA 		b	.L64
 615              	.LVL65:
 616              	.L53:
 306:rf/trf6151.c  **** 		if (freq_khz < 837100) {
 617              		.loc 2 306 0
 618 012c D8309FE5 		ldr	r3, .L65+20
 619 0130 030055E1 		cmp	r5, r3
 620 0134 1000009A 		bls	.L60
 315:rf/trf6151.c  **** 		} else if (freq_khz < 850000) {
 621              		.loc 2 315 0
 622 0138 D0309FE5 		ldr	r3, .L65+24
 317:rf/trf6151.c  **** 			*band = GSM850_HIGH;
 623              		.loc 2 317 0
 624 013c 030055E1 		cmp	r5, r3
 625 0140 0140A083 		movhi	r4, #1
 626 0144 0540A093 		movls	r4, #5
 627              	.LVL66:
 628 0148 3830A083 		movhi	r3, #56
 629 014c 3030A093 		movls	r3, #48
 630 0150 3410A0E3 		mov	r1, #52
 631 0154 04C0A0E3 		mov	ip, #4
 632 0158 2320A083 		movhi	r2, #35
 633 015c 1E20A093 		movls	r2, #30
 634 0160 0A0000EA 		b	.L54
 635              	.LVL67:
 636              	.L59:
 292:rf/trf6151.c  **** 		*band = (freq_khz < 1817500) ? GSM1800 : GSM1900;
 637              		.loc 2 292 0
 638 0164 0640A0E3 		mov	r4, #6
 639              	.LVL68:
 296:rf/trf6151.c  **** 		m_op_l = m + l;
 640              		.loc 2 296 0
 641 0168 1C30A0E3 		mov	r3, #28
 295:rf/trf6151.c  **** 		m = 26;
 642              		.loc 2 295 0
 643 016c 1A10A0E3 		mov	r1, #26
 294:rf/trf6151.c  **** 		l = 2;
 644              		.loc 2 294 0
 645 0170 02C0A0E3 		mov	ip, #2
 646              	.L64:
 293:rf/trf6151.c  **** 		r = 70;
 647              		.loc 2 293 0
 648 0174 4620A0E3 		mov	r2, #70
 649 0178 040000EA 		b	.L54
 650              	.LVL69:
 651              	.L60:
 308:rf/trf6151.c  **** 			*band = GSM850_LOW;
 652              		.loc 2 308 0
 653 017c 0440A0E3 		mov	r4, #4
 654              	.LVL70:
 312:rf/trf6151.c  **** 			m_op_l = m - l;
 655              		.loc 2 312 0
 656 0180 1630A0E3 		mov	r3, #22
 311:rf/trf6151.c  **** 			m = 26;
 657              		.loc 2 311 0
 658 0184 1A10A0E3 		mov	r1, #26
 310:rf/trf6151.c  **** 			l = 4;
 659              		.loc 2 310 0
 660 0188 04C0A0E1 		mov	ip, r4
 309:rf/trf6151.c  **** 			r = 55;
 661              		.loc 2 309 0
 662 018c 3720A0E3 		mov	r2, #55
 663              	.L54:
 664              	.LVL71:
 338:rf/trf6151.c  **** 	n = (freq_100khz * m * l * r) / (m_op_l * 260);
 665              		.loc 2 338 0
 666 0190 9C0101E0 		mul	r1, ip, r1
 667              	.LVL72:
 668 0194 910000E0 		mul	r0, r1, r0
 669              	.LVL73:
 670 0198 411FA0E3 		mov	r1, #260
 671 019c 920000E0 		mul	r0, r2, r0
 672 01a0 930101E0 		mul	r1, r3, r1
 673 01a4 FEFFFFEB 		bl	__udivsi3
 674              	.LVL74:
 340:rf/trf6151.c  **** 	b = n / p;
 675              		.loc 2 340 0
 676 01a8 2073A0E1 		mov	r7, r0, lsr #6
 339:rf/trf6151.c  **** 	a = n % p;
 677              		.loc 2 339 0
 678 01ac 3F0000E2 		and	r0, r0, #63
 679              	.LVL75:
 342:rf/trf6151.c  **** 	*pll_config = PLL_VAL(a, b);
 680              		.loc 2 342 0
 681 01b0 407047E2 		sub	r7, r7, #64
 682              	.LVL76:
 683 01b4 8001A0E1 		mov	r0, r0, asl #3
 684              	.LVL77:
 685 01b8 877480E1 		orr	r7, r0, r7, asl #9
 686              	.LVL78:
 687 01bc 0778A0E1 		mov	r7, r7, asl #16
 688 01c0 2778A0E1 		mov	r7, r7, lsr #16
 689              	.LVL79:
 690              	.L50:
 691              	.LBE25:
 692              	.LBE24:
 693              	.LBB26:
 694              	.LBB27:
 422:rf/trf6151.c  **** 	uint16_t pwr = trf6151_reg_cache[REG_PWR];
 695              		.loc 2 422 0
 696 01c4 48509FE5 		ldr	r5, .L65+28
 697 01c8 B410D5E1 		ldrh	r1, [r5, #4]
 698              	.LVL80:
 424:rf/trf6151.c  **** 	pwr &= ~(3 << 6);
 699              		.loc 2 424 0
 700 01cc C010C1E3 		bic	r1, r1, #192
 701              	.LVL81:
 427:rf/trf6151.c  **** 	trf6151_reg_write(REG_PWR, pwr);
 702              		.loc 2 427 0
 703 01d0 0200A0E3 		mov	r0, #2
 704 01d4 041381E1 		orr	r1, r1, r4, asl #6
 705              	.LVL82:
 706 01d8 FEFFFFEB 		bl	trf6151_reg_write
 707              	.LBE27:
 708              	.LBE26:
 460:rf/trf6151.c  **** 		trf6151_pll_rx(freq_khz, &pll_config, &pll_band);
 461:rf/trf6151.c  **** 	else
 462:rf/trf6151.c  **** 		trf6151_pll_tx(freq_khz, &pll_config, &pll_band);
 463:rf/trf6151.c  **** 
 464:rf/trf6151.c  **** 	trf6151_band_select(pll_band);
 465:rf/trf6151.c  **** 	trf6151_reg_write(REG_PLL, pll_config);
 709              		.loc 2 465 0
 710 01dc 0100A0E3 		mov	r0, #1
 711 01e0 0710A0E1 		mov	r1, r7
 712 01e4 FEFFFFEB 		bl	trf6151_reg_write
 466:rf/trf6151.c  **** 
 467:rf/trf6151.c  **** 	rf_band = pll_band;
 713              		.loc 2 467 0
 714 01e8 28309FE5 		ldr	r3, .L65+32
 468:rf/trf6151.c  **** 	rf_arfcn = arfcn; // TODO: arfcn is referenced at other places
 715              		.loc 2 468 0
 716 01ec B861C5E1 		strh	r6, [r5, #24]	@ movhi
 467:rf/trf6151.c  **** 	rf_band = pll_band;
 717              		.loc 2 467 0
 718 01f0 B240C3E1 		strh	r4, [r3, #2]	@ movhi
 469:rf/trf6151.c  **** }
 719              		.loc 2 469 0
 720 01f4 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 721              	.L66:
 722              		.align	2
 723              	.L65:
 724 01f8 00000000 		.word	.LC0
 725 01fc 70991400 		.word	1350000
 726 0200 098C0000 		.word	35849
 727 0204 67111D00 		.word	1904999
 728 0208 9BBB1B00 		.word	1817499
 729 020c EBC50C00 		.word	837099
 730 0210 4FF80C00 		.word	849999
 731 0214 00000000 		.word	.LANCHOR1
 732 0218 00000000 		.word	.LANCHOR0
 733              		.cfi_endproc
 734              	.LFE21:
 736              		.section	.text.trf6151_calib_dc_offs,"ax",%progbits
 737              		.align	2
 738              		.global	trf6151_calib_dc_offs
 740              	trf6151_calib_dc_offs:
 741              	.LFB22:
 470:rf/trf6151.c  **** 
 471:rf/trf6151.c  **** void trf6151_calib_dc_offs(void)
 472:rf/trf6151.c  **** {
 742              		.loc 2 472 0
 743              		.cfi_startproc
 744              		@ args = 0, pretend = 0, frame = 0
 745              		@ frame_needed = 0, uses_anonymous_args = 0
 746              	.LVL83:
 473:rf/trf6151.c  **** 	uint16_t rx = trf6151_reg_cache[REG_RX];
 747              		.loc 2 473 0
 748 0000 1C309FE5 		ldr	r3, .L68
 474:rf/trf6151.c  **** 
 475:rf/trf6151.c  **** 	/* Set RX CAL Mode bit, it will re-set automatically */
 476:rf/trf6151.c  **** 	trf6151_reg_write(REG_RX, rx | RX_CAL_MODE);
 749              		.loc 2 476 0
 750 0004 B010D3E1 		ldrh	r1, [r3, #0]
 472:rf/trf6151.c  **** {
 751              		.loc 2 472 0
 752 0008 04E02DE5 		str	lr, [sp, #-4]!
 753              	.LCFI5:
 754              		.cfi_def_cfa_offset 4
 755              		.loc 2 476 0
 756 000c 0000A0E3 		mov	r0, #0
 757 0010 011C81E3 		orr	r1, r1, #256
 758              		.cfi_offset 14, -4
 759 0014 FEFFFFEB 		bl	trf6151_reg_write
 760              	.LVL84:
 477:rf/trf6151.c  **** 	/* DC offset calibration can take up to 50us, i.e. 54.16 * 923ns*/
 478:rf/trf6151.c  **** 	tpu_enq_wait(55);
 761              		.loc 2 478 0
 762 0018 3700A0E3 		mov	r0, #55
 479:rf/trf6151.c  **** }
 763              		.loc 2 479 0
 764 001c 04E09DE4 		ldr	lr, [sp], #4
 478:rf/trf6151.c  **** 	tpu_enq_wait(55);
 765              		.loc 2 478 0
 766 0020 FEFFFFEA 		b	tpu_enq_wait
 767              	.L69:
 768              		.align	2
 769              	.L68:
 770 0024 00000000 		.word	.LANCHOR1
 771              		.cfi_endproc
 772              	.LFE22:
 774              		.section	.text.trf6151_get_gain_reg,"ax",%progbits
 775              		.align	2
 776              		.global	trf6151_get_gain_reg
 778              	trf6151_get_gain_reg:
 779              	.LFB23:
 480:rf/trf6151.c  **** 
 481:rf/trf6151.c  **** uint8_t trf6151_get_gain_reg(void)
 482:rf/trf6151.c  **** {
 780              		.loc 2 482 0
 781              		.cfi_startproc
 782              		@ args = 0, pretend = 0, frame = 0
 783              		@ frame_needed = 0, uses_anonymous_args = 0
 784              		@ link register save eliminated.
 483:rf/trf6151.c  **** 	uint16_t vga, reg_rx = trf6151_reg_cache[REG_RX];
 785              		.loc 2 483 0
 786 0000 2C309FE5 		ldr	r3, .L73
 787 0004 B030D3E1 		ldrh	r3, [r3, #0]
 788              	.LVL85:
 789 0008 28109FE5 		ldr	r1, .L73+4
 484:rf/trf6151.c  **** 	uint8_t gain = 0;
 485:rf/trf6151.c  **** 
 486:rf/trf6151.c  **** 	switch ((reg_rx >> 9) & 3) {
 790              		.loc 2 486 0
 791 000c A324A0E1 		mov	r2, r3, lsr #9
 487:rf/trf6151.c  **** 	case 0:
 488:rf/trf6151.c  **** 		gain += TRF6151_FE_GAIN_LOW;
 489:rf/trf6151.c  **** 		break;
 490:rf/trf6151.c  **** 	case 3:
 491:rf/trf6151.c  **** 		gain += TRF6151_FE_GAIN_HIGH;
 492:rf/trf6151.c  **** 		break;
 493:rf/trf6151.c  **** 	}
 494:rf/trf6151.c  **** 
 495:rf/trf6151.c  **** 	vga = (reg_rx >> RX_VGA_GAIN_SHIFT) & 0x1f;
 792              		.loc 2 495 0
 793 0010 A335A0E1 		mov	r3, r3, lsr #11
 794              	.LVL86:
 496:rf/trf6151.c  **** 	if (vga < 6)
 497:rf/trf6151.c  **** 		vga = 6;
 795              		.loc 2 497 0
 796 0014 050053E3 		cmp	r3, #5
 486:rf/trf6151.c  **** 	switch ((reg_rx >> 9) & 3) {
 797              		.loc 2 486 0
 798 0018 032002E2 		and	r2, r2, #3
 483:rf/trf6151.c  **** 	uint16_t vga, reg_rx = trf6151_reg_cache[REG_RX];
 799              		.loc 2 483 0
 800 001c 0220D1E7 		ldrb	r2, [r1, r2]	@ zero_extendqisi2
 801              	.LVL87:
 802              		.loc 2 497 0
 803 0020 0630A093 		movls	r3, #6
 804              	.LVL88:
 498:rf/trf6151.c  **** 
 499:rf/trf6151.c  **** 	gain += TRF6151_VGA_GAIN_MIN + (vga - 6) * 2;
 805              		.loc 2 499 0
 806 0024 013083E2 		add	r3, r3, #1
 807              	.LVL89:
 496:rf/trf6151.c  **** 	if (vga < 6)
 808              		.loc 2 496 0
 809 0028 830082E0 		add	r0, r2, r3, asl #1
 500:rf/trf6151.c  **** 
 501:rf/trf6151.c  **** 	return gain;
 502:rf/trf6151.c  **** }
 810              		.loc 2 502 0
 811 002c FF0000E2 		and	r0, r0, #255
 812 0030 1EFF2FE1 		bx	lr
 813              	.L74:
 814              		.align	2
 815              	.L73:
 816 0034 00000000 		.word	.LANCHOR1
 817 0038 00000000 		.word	.LANCHOR2
 818              		.cfi_endproc
 819              	.LFE23:
 821              		.section	.text.trf6151_get_gain,"ax",%progbits
 822              		.align	2
 823              		.global	trf6151_get_gain
 825              	trf6151_get_gain:
 826              	.LFB24:
 503:rf/trf6151.c  **** 
 504:rf/trf6151.c  **** uint8_t trf6151_get_gain(void)
 505:rf/trf6151.c  **** {
 827              		.loc 2 505 0
 828              		.cfi_startproc
 829              		@ args = 0, pretend = 0, frame = 0
 830              		@ frame_needed = 0, uses_anonymous_args = 0
 831              		@ link register save eliminated.
 506:rf/trf6151.c  **** 	uint8_t gain;
 507:rf/trf6151.c  **** 	
 508:rf/trf6151.c  **** 	gain = trf6151_vga_dbm;
 832              		.loc 2 508 0
 833 0000 1C309FE5 		ldr	r3, .L78
 834 0004 1000D3E5 		ldrb	r0, [r3, #16]	@ zero_extendqisi2
 835              	.LVL90:
 509:rf/trf6151.c  **** 	if (trf6151_gain_high)
 836              		.loc 2 509 0
 837 0008 143093E5 		ldr	r3, [r3, #20]
 838 000c 000053E3 		cmp	r3, #0
 510:rf/trf6151.c  **** 		gain += TRF6151_FE_GAIN_HIGH;
 839              		.loc 2 510 0
 840 0010 1B008012 		addne	r0, r0, #27
 841              	.LVL91:
 511:rf/trf6151.c  **** 	else
 512:rf/trf6151.c  **** 		gain += TRF6151_FE_GAIN_LOW;
 842              		.loc 2 512 0
 843 0014 07008002 		addeq	r0, r0, #7
 510:rf/trf6151.c  **** 		gain += TRF6151_FE_GAIN_HIGH;
 844              		.loc 2 510 0
 845 0018 FF000012 		andne	r0, r0, #255
 846              		.loc 2 512 0
 847 001c FF000002 		andeq	r0, r0, #255
 848              	.LVL92:
 513:rf/trf6151.c  **** 
 514:rf/trf6151.c  **** 	return gain;
 515:rf/trf6151.c  **** }
 849              		.loc 2 515 0
 850 0020 1EFF2FE1 		bx	lr
 851              	.L79:
 852              		.align	2
 853              	.L78:
 854 0024 00000000 		.word	.LANCHOR1
 855              		.cfi_endproc
 856              	.LFE24:
 858              		.section	.text.trf6151_test,"ax",%progbits
 859              		.align	2
 860              		.global	trf6151_test
 862              	trf6151_test:
 863              	.LFB25:
 516:rf/trf6151.c  **** 
 517:rf/trf6151.c  **** void trf6151_test(uint16_t arfcn)
 518:rf/trf6151.c  **** {
 864              		.loc 2 518 0
 865              		.cfi_startproc
 866              		@ args = 0, pretend = 0, frame = 0
 867              		@ frame_needed = 0, uses_anonymous_args = 0
 868              	.LVL93:
 869 0000 0008A0E1 		mov	r0, r0, asl #16
 870              	.LVL94:
 871 0004 04E02DE5 		str	lr, [sp, #-4]!
 872              	.LCFI6:
 873              		.cfi_def_cfa_offset 4
 519:rf/trf6151.c  **** 	/* Select ARFCN downlink */
 520:rf/trf6151.c  **** 	trf6151_set_arfcn(arfcn, 0);
 874              		.loc 2 520 0
 875 0008 0010A0E3 		mov	r1, #0
 876 000c 2008A0E1 		mov	r0, r0, lsr #16
 877              		.cfi_offset 14, -4
 878 0010 FEFFFFEB 		bl	trf6151_set_arfcn
 521:rf/trf6151.c  **** 
 522:rf/trf6151.c  **** 	trf6151_set_mode(TRF6151_RX);
 879              		.loc 2 522 0
 880 0014 0100A0E3 		mov	r0, #1
 881 0018 FEFFFFEB 		bl	trf6151_set_mode
 523:rf/trf6151.c  **** 	//trf6151_reg_write(REG_PWR, (PWR_SYNTHE_RX_ON | PWR_RX_MODE | PWR_REGUL_ON | (rf_band<<6) | PWR_B
 524:rf/trf6151.c  **** 	/* Wait for PLL stabilization (170us max) */
 525:rf/trf6151.c  **** 	tpu_enq_wait(TRF6151_RX_PLL_DELAY);
 882              		.loc 2 525 0
 883 001c B800A0E3 		mov	r0, #184
 884 0020 FEFFFFEB 		bl	tpu_enq_wait
 526:rf/trf6151.c  **** 
 527:rf/trf6151.c  **** 	/* Use DC offset calibration after RX mode has been switched on
 528:rf/trf6151.c  **** 	 * (might not be needed) */
 529:rf/trf6151.c  **** 	trf6151_calib_dc_offs();
 885              		.loc 2 529 0
 886 0024 FEFFFFEB 		bl	trf6151_calib_dc_offs
 887              	.LBB28:
 888              	.LBB29:
  81:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SLEEP);
 889              		.loc 1 81 0
 890 0028 0000A0E3 		mov	r0, #0
 891 002c FEFFFFEB 		bl	tpu_enqueue
 892              	.LBE29:
 893              	.LBE28:
 530:rf/trf6151.c  **** 
 531:rf/trf6151.c  **** 	tpu_enq_sleep();
 532:rf/trf6151.c  **** 	tpu_enable(1);
 894              		.loc 2 532 0
 895 0030 0100A0E3 		mov	r0, #1
 896 0034 FEFFFFEB 		bl	tpu_enable
 533:rf/trf6151.c  **** 	tpu_wait_idle();
 534:rf/trf6151.c  **** }
 897              		.loc 2 534 0
 898 0038 04E09DE4 		ldr	lr, [sp], #4
 533:rf/trf6151.c  **** 	tpu_wait_idle();
 899              		.loc 2 533 0
 900 003c FEFFFFEA 		b	tpu_wait_idle
 901              		.cfi_endproc
 902              	.LFE25:
 904              		.section	.text.trf6151_tx_test,"ax",%progbits
 905              		.align	2
 906              		.global	trf6151_tx_test
 908              	trf6151_tx_test:
 909              	.LFB26:
 535:rf/trf6151.c  **** 
 536:rf/trf6151.c  **** void trf6151_tx_test(uint16_t arfcn)
 537:rf/trf6151.c  **** {
 910              		.loc 2 537 0
 911              		.cfi_startproc
 912              		@ args = 0, pretend = 0, frame = 0
 913              		@ frame_needed = 0, uses_anonymous_args = 0
 914              	.LVL95:
 915 0000 0008A0E1 		mov	r0, r0, asl #16
 916              	.LVL96:
 538:rf/trf6151.c  **** 	/* Select ARFCN uplink */
 539:rf/trf6151.c  **** 	trf6151_set_arfcn(arfcn | ARFCN_UPLINK, 1);
 917              		.loc 2 539 0
 918 0004 010180E3 		orr	r0, r0, #1073741824
 537:rf/trf6151.c  **** {
 919              		.loc 2 537 0
 920 0008 04E02DE5 		str	lr, [sp, #-4]!
 921              	.LCFI7:
 922              		.cfi_def_cfa_offset 4
 923              		.loc 2 539 0
 924 000c 0110A0E3 		mov	r1, #1
 925 0010 2008A0E1 		mov	r0, r0, lsr #16
 926              		.cfi_offset 14, -4
 927 0014 FEFFFFEB 		bl	trf6151_set_arfcn
 540:rf/trf6151.c  **** 
 541:rf/trf6151.c  **** 	trf6151_set_mode(TRF6151_TX);
 928              		.loc 2 541 0
 929 0018 0200A0E3 		mov	r0, #2
 930 001c FEFFFFEB 		bl	trf6151_set_mode
 542:rf/trf6151.c  **** 	tpu_enq_wait(TRF6151_RX_PLL_DELAY);
 931              		.loc 2 542 0
 932 0020 B800A0E3 		mov	r0, #184
 933 0024 FEFFFFEB 		bl	tpu_enq_wait
 934              	.LBB30:
 935              	.LBB31:
  81:include/calypso/tpu.h **** 	tpu_enqueue(TPU_INSTR_SLEEP);
 936              		.loc 1 81 0
 937 0028 0000A0E3 		mov	r0, #0
 938 002c FEFFFFEB 		bl	tpu_enqueue
 939              	.LBE31:
 940              	.LBE30:
 543:rf/trf6151.c  **** 
 544:rf/trf6151.c  **** 	tpu_enq_sleep();
 545:rf/trf6151.c  **** 	tpu_enable(1);
 941              		.loc 2 545 0
 942 0030 0100A0E3 		mov	r0, #1
 943 0034 FEFFFFEB 		bl	tpu_enable
 546:rf/trf6151.c  **** 	tpu_wait_idle();
 547:rf/trf6151.c  **** }
 944              		.loc 2 547 0
 945 0038 04E09DE4 		ldr	lr, [sp], #4
 546:rf/trf6151.c  **** 	tpu_wait_idle();
 946              		.loc 2 546 0
 947 003c FEFFFFEA 		b	tpu_wait_idle
 948              		.cfi_endproc
 949              	.LFE26:
 951              		.section	.text.trf6151_rx_window,"ax",%progbits
 952              		.align	2
 953              		.global	trf6151_rx_window
 955              	trf6151_rx_window:
 956              	.LFB27:
 548:rf/trf6151.c  **** 
 549:rf/trf6151.c  **** #define TRF6151_REGWR_QBITS	8	/* 4 GSM qbits + 4 TPU instructions */
 550:rf/trf6151.c  **** #define TRF6151_RX_TPU_INSTR	4	/* set_gain_reg(1), set_arfcn(2), set_mode(1) */
 551:rf/trf6151.c  **** 
 552:rf/trf6151.c  **** /* delay caused by this driver programming the TPU for RX mode */
 553:rf/trf6151.c  **** #define TRF6151_RX_TPU_DELAY	(TRF6151_RX_TPU_INSTR * TRF6151_REGWR_QBITS)
 554:rf/trf6151.c  **** 
 555:rf/trf6151.c  **** /* prepare a Rx window with the TRF6151 finished at time 'start' (in qbits) */
 556:rf/trf6151.c  **** void trf6151_rx_window(int16_t start_qbits, uint16_t arfcn)
 557:rf/trf6151.c  **** {
 957              		.loc 2 557 0
 958              		.cfi_startproc
 959              		@ args = 0, pretend = 0, frame = 0
 960              		@ frame_needed = 0, uses_anonymous_args = 0
 961              	.LVL97:
 962 0000 0118A0E1 		mov	r1, r1, asl #16
 963              	.LVL98:
 964 0004 0008A0E1 		mov	r0, r0, asl #16
 965              	.LVL99:
 966 0008 10402DE9 		stmfd	sp!, {r4, lr}
 967              	.LCFI8:
 968              		.cfi_def_cfa_offset 8
 558:rf/trf6151.c  **** 	int16_t start_pll_qbits;
 559:rf/trf6151.c  **** 
 560:rf/trf6151.c  **** 	/* power up at the right time _before_ the 'start_qbits' point in time */
 561:rf/trf6151.c  **** 	start_pll_qbits = add_mod5000(start_qbits,  -(TRF6151_RX_PLL_DELAY + TRF6151_RX_TPU_DELAY));
 969              		.loc 2 561 0
 970 000c 4008A0E1 		mov	r0, r0, asr #16
 557:rf/trf6151.c  **** {
 971              		.loc 2 557 0
 972 0010 2148A0E1 		mov	r4, r1, lsr #16
 973              		.cfi_offset 14, -4
 974              		.cfi_offset 4, -8
 975              		.loc 2 561 0
 976 0014 D710E0E3 		mvn	r1, #215
 977 0018 FEFFFFEB 		bl	add_mod5000
 978              	.LVL100:
 562:rf/trf6151.c  **** 	tpu_enq_at(start_pll_qbits);
 979              		.loc 2 562 0
 980 001c 0008A0E1 		mov	r0, r0, asl #16
 981              	.LVL101:
 982 0020 4008A0E1 		mov	r0, r0, asr #16
 983 0024 FEFFFFEB 		bl	tpu_enq_at
 563:rf/trf6151.c  **** 
 564:rf/trf6151.c  **** 	/* Set the AGC and PLL registers */
 565:rf/trf6151.c  **** 	trf6151_set_arfcn(arfcn, 0);
 984              		.loc 2 565 0
 985 0028 0400A0E1 		mov	r0, r4
 986 002c 0010A0E3 		mov	r1, #0
 987 0030 FEFFFFEB 		bl	trf6151_set_arfcn
 566:rf/trf6151.c  **** 	trf6151_set_gain_reg(trf6151_vga_dbm, trf6151_gain_high);
 988              		.loc 2 566 0
 989 0034 14309FE5 		ldr	r3, .L83
 990 0038 1000D3E5 		ldrb	r0, [r3, #16]	@ zero_extendqisi2
 991 003c 141093E5 		ldr	r1, [r3, #20]
 992 0040 FEFFFFEB 		bl	trf6151_set_gain_reg
 567:rf/trf6151.c  **** 	trf6151_set_mode(TRF6151_RX);
 993              		.loc 2 567 0
 994 0044 0100A0E3 		mov	r0, #1
 568:rf/trf6151.c  **** 
 569:rf/trf6151.c  **** 	/* FIXME: power down at the right time again */
 570:rf/trf6151.c  **** }
 995              		.loc 2 570 0
 996 0048 1040BDE8 		ldmfd	sp!, {r4, lr}
 567:rf/trf6151.c  **** 	trf6151_set_mode(TRF6151_RX);
 997              		.loc 2 567 0
 998 004c FEFFFFEA 		b	trf6151_set_mode
 999              	.L84:
 1000              		.align	2
 1001              	.L83:
 1002 0050 00000000 		.word	.LANCHOR1
 1003              		.cfi_endproc
 1004              	.LFE27:
 1006              		.section	.text.trf6151_tx_window,"ax",%progbits
 1007              		.align	2
 1008              		.global	trf6151_tx_window
 1010              	trf6151_tx_window:
 1011              	.LFB28:
 571:rf/trf6151.c  **** 
 572:rf/trf6151.c  **** /* prepare a Tx window with the TRF6151 finished at time 'start' (in qbits) */
 573:rf/trf6151.c  **** void trf6151_tx_window(int16_t start_qbits, uint16_t arfcn)
 574:rf/trf6151.c  **** {
 1012              		.loc 2 574 0
 1013              		.cfi_startproc
 1014              		@ args = 0, pretend = 0, frame = 0
 1015              		@ frame_needed = 0, uses_anonymous_args = 0
 1016              	.LVL102:
 1017 0000 0118A0E1 		mov	r1, r1, asl #16
 1018              	.LVL103:
 1019 0004 0008A0E1 		mov	r0, r0, asl #16
 1020              	.LVL104:
 1021 0008 10402DE9 		stmfd	sp!, {r4, lr}
 1022              	.LCFI9:
 1023              		.cfi_def_cfa_offset 8
 575:rf/trf6151.c  **** #ifdef CONFIG_TX_ENABLE
 576:rf/trf6151.c  **** 	int16_t start_pll_qbits;
 577:rf/trf6151.c  **** 
 578:rf/trf6151.c  **** 	/* power up at the right time _before_ the 'start_qbits' point in time */
 579:rf/trf6151.c  **** 	start_pll_qbits = add_mod5000(start_qbits,  -(TRF6151_TX_PLL_DELAY + TRF6151_RX_TPU_DELAY));
 1024              		.loc 2 579 0
 1025 000c 4008A0E1 		mov	r0, r0, asr #16
 574:rf/trf6151.c  **** {
 1026              		.loc 2 574 0
 1027 0010 2148A0E1 		mov	r4, r1, lsr #16
 1028              		.cfi_offset 14, -4
 1029              		.cfi_offset 4, -8
 1030              		.loc 2 579 0
 1031 0014 24109FE5 		ldr	r1, .L86
 1032 0018 FEFFFFEB 		bl	add_mod5000
 1033              	.LVL105:
 580:rf/trf6151.c  **** 	tpu_enq_at(start_pll_qbits);
 1034              		.loc 2 580 0
 1035 001c 0008A0E1 		mov	r0, r0, asl #16
 1036              	.LVL106:
 1037 0020 4008A0E1 		mov	r0, r0, asr #16
 1038 0024 FEFFFFEB 		bl	tpu_enq_at
 581:rf/trf6151.c  **** 
 582:rf/trf6151.c  **** 	trf6151_set_arfcn(arfcn, 1);
 1039              		.loc 2 582 0
 1040 0028 0400A0E1 		mov	r0, r4
 1041 002c 0110A0E3 		mov	r1, #1
 1042 0030 FEFFFFEB 		bl	trf6151_set_arfcn
 583:rf/trf6151.c  **** 	trf6151_set_mode(TRF6151_TX);
 1043              		.loc 2 583 0
 1044 0034 0200A0E3 		mov	r0, #2
 584:rf/trf6151.c  **** 
 585:rf/trf6151.c  **** 	/* FIXME: power down at the right time again */
 586:rf/trf6151.c  **** #endif
 587:rf/trf6151.c  **** }
 1045              		.loc 2 587 0
 1046 0038 1040BDE8 		ldmfd	sp!, {r4, lr}
 583:rf/trf6151.c  **** 	trf6151_set_mode(TRF6151_TX);
 1047              		.loc 2 583 0
 1048 003c FEFFFFEA 		b	trf6151_set_mode
 1049              	.L87:
 1050              		.align	2
 1051              	.L86:
 1052 0040 DCFEFFFF 		.word	-292
 1053              		.cfi_endproc
 1054              	.LFE28:
 1056              		.section	.text.trf6151_compute_gain,"ax",%progbits
 1057              		.align	2
 1058              		.global	trf6151_compute_gain
 1060              	trf6151_compute_gain:
 1061              	.LFB29:
 588:rf/trf6151.c  **** 
 589:rf/trf6151.c  **** /* Given the expected input level of exp_inp dBm and the target of target_bb
 590:rf/trf6151.c  ****  * dBm, configure the RF Frontend with the respective gain */
 591:rf/trf6151.c  **** void trf6151_compute_gain(int16_t exp_inp, int16_t target_bb)
 592:rf/trf6151.c  **** {
 1062              		.loc 2 592 0
 1063              		.cfi_startproc
 1064              		@ args = 0, pretend = 0, frame = 0
 1065              		@ frame_needed = 0, uses_anonymous_args = 0
 1066              		@ link register save eliminated.
 1067              	.LVL107:
 593:rf/trf6151.c  **** 	/* TRF6151 VGA gain between 14 to 40 dB, plus 20db high/low */
 594:rf/trf6151.c  **** 	int16_t exp_bb, delta;
 595:rf/trf6151.c  **** 
 596:rf/trf6151.c  **** 	/* calculate the dBm8 that we expect at the baseband */
 597:rf/trf6151.c  **** 	exp_bb = exp_inp + system_inherent_gain;
 1068              		.loc 2 597 0
 1069 0000 1C309FE5 		ldr	r3, .L89
 592:rf/trf6151.c  **** {
 1070              		.loc 2 592 0
 1071 0004 0118A0E1 		mov	r1, r1, asl #16
 1072              	.LVL108:
 1073 0008 4118A0E1 		mov	r1, r1, asr #16
 1074              		.loc 2 597 0
 1075 000c 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 592:rf/trf6151.c  **** {
 1076              		.loc 2 592 0
 1077 0010 0008A0E1 		mov	r0, r0, asl #16
 1078              	.LVL109:
 1079              		.loc 2 597 0
 1080 0014 400841E0 		sub	r0, r1, r0, asr #16
 1081              	.LVL110:
 598:rf/trf6151.c  **** 
 599:rf/trf6151.c  **** 	/* calculate the error that we expect. */
 600:rf/trf6151.c  **** 	delta = target_bb - exp_bb;
 601:rf/trf6151.c  **** 
 602:rf/trf6151.c  **** 	printd("computed gain %d\n", delta);
 603:rf/trf6151.c  **** 	trf6151_set_gain(delta);
 1082              		.loc 2 603 0
 1083 0018 000063E0 		rsb	r0, r3, r0
 1084 001c FF0000E2 		and	r0, r0, #255
 604:rf/trf6151.c  **** }
 1085              		.loc 2 604 0
 603:rf/trf6151.c  **** 	trf6151_set_gain(delta);
 1086              		.loc 2 603 0
 1087 0020 FEFFFFEA 		b	trf6151_set_gain
 1088              	.L90:
 1089              		.align	2
 1090              	.L89:
 1091 0024 00000000 		.word	system_inherent_gain
 1092              		.cfi_endproc
 1093              	.LFE29:
 1095              		.section	.text.trf6151_iq_swapped,"ax",%progbits
 1096              		.align	2
 1097              		.global	trf6151_iq_swapped
 1099              	trf6151_iq_swapped:
 1100              	.LFB30:
 605:rf/trf6151.c  **** 
 606:rf/trf6151.c  **** int trf6151_iq_swapped(uint16_t band_arfcn, int tx)
 607:rf/trf6151.c  **** {
 1101              		.loc 2 607 0
 1102              		.cfi_startproc
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              	.LVL111:
 1106 0000 0008A0E1 		mov	r0, r0, asl #16
 1107              	.LVL112:
 608:rf/trf6151.c  **** 	if (!tx)
 1108              		.loc 2 608 0
 1109 0004 000051E3 		cmp	r1, #0
 607:rf/trf6151.c  **** {
 1110              		.loc 2 607 0
 1111 0008 04E02DE5 		str	lr, [sp, #-4]!
 1112              	.LCFI10:
 1113              		.cfi_def_cfa_offset 4
 607:rf/trf6151.c  **** {
 1114              		.loc 2 607 0
 1115 000c 2008A0E1 		mov	r0, r0, lsr #16
 1116              		.loc 2 608 0
 1117 0010 0400000A 		beq	.L93
 1118              		.cfi_offset 14, -4
 609:rf/trf6151.c  **** 		return 0;
 610:rf/trf6151.c  **** 
 611:rf/trf6151.c  **** 	switch (gsm_arfcn2band(band_arfcn)) {
 1119              		.loc 2 611 0
 1120 0014 FEFFFFEB 		bl	gsm_arfcn2band
 1121              	.LVL113:
 609:rf/trf6151.c  **** 		return 0;
 1122              		.loc 2 609 0
 1123 0018 010050E3 		cmp	r0, #1
 1124 001c 0000A013 		movne	r0, #0
 1125 0020 0100A003 		moveq	r0, #1
 1126 0024 04F09DE4 		ldr	pc, [sp], #4
 1127              	.LVL114:
 1128              	.L93:
 1129 0028 0100A0E1 		mov	r0, r1
 612:rf/trf6151.c  **** 		case GSM_BAND_850:
 613:rf/trf6151.c  **** 			return 1;
 614:rf/trf6151.c  **** 		default:
 615:rf/trf6151.c  **** 			break;
 616:rf/trf6151.c  **** 	}
 617:rf/trf6151.c  **** 
 618:rf/trf6151.c  **** 	return 0;
 619:rf/trf6151.c  **** }
 1130              		.loc 2 619 0
 1131 002c 04F09DE4 		ldr	pc, [sp], #4
 1132              		.cfi_endproc
 1133              	.LFE30:
 1135              		.global	rf_arfcn
 1136              		.section	.rodata
 1137              		.align	2
 1138              		.set	.LANCHOR2,. + 0
 1141              	CSWTCH.21:
 1142 0000 07       		.byte	7
 1143 0001 00       		.byte	0
 1144 0002 00       		.byte	0
 1145 0003 1B       		.byte	27
 1146              		.section	.rodata.str1.1,"aMS",%progbits,1
 1147              	.LC0:
 1148 0000 556E7375 		.ascii	"Unsupported band ! YMMV.\000"
 1148      70706F72 
 1148      74656420 
 1148      62616E64 
 1148      20212059 
 1149              		.data
 1150              		.align	2
 1151              		.set	.LANCHOR1,. + 0
 1154              	trf6151_reg_cache:
 1155 0000 009E     		.short	-25088
 1156 0002 0000     		.short	0
 1157 0004 0000     		.short	0
 1158 0006 8029     		.short	10624
 1159 0008 00000000 		.space	8
 1159      00000000 
 1162              	trf6151_vga_dbm:
 1163 0010 28       		.byte	40
 1164 0011 000000   		.space	3
 1167              	trf6151_gain_high:
 1168 0014 01000000 		.word	1
 1171              	rf_arfcn:
 1172 0018 6703     		.short	871
 1173 001a 0000     		.bss
 1174              		.align	1
 1175              		.set	.LANCHOR0,. + 0
 1178              	trf6151_tsp_uid:
 1179 0000 00       		.space	1
 1180 0001 00       		.space	1
 1183              	rf_band:
 1184 0002 0000     		.space	2
 1185              		.text
 1186              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 trf6151.c
     /tmp/ccoJr8Ow.s:12     .text.tpu_enq_at:0000000000000000 $a
     /tmp/ccoJr8Ow.s:14     .text.tpu_enq_at:0000000000000000 tpu_enq_at
     /tmp/ccoJr8Ow.s:53     .text.tpu_enq_at:0000000000000030 $d
     /tmp/ccoJr8Ow.s:58     .text.tpu_enq_wait:0000000000000000 $a
     /tmp/ccoJr8Ow.s:60     .text.tpu_enq_wait:0000000000000000 tpu_enq_wait
     /tmp/ccoJr8Ow.s:79     .text.tpu_enq_wait:0000000000000010 $d
     /tmp/ccoJr8Ow.s:84     .text.trf6151_reg_write:0000000000000000 $a
     /tmp/ccoJr8Ow.s:86     .text.trf6151_reg_write:0000000000000000 trf6151_reg_write
     /tmp/ccoJr8Ow.s:121    .text.trf6151_reg_write:0000000000000030 $d
     /tmp/ccoJr8Ow.s:127    .text.trf6151_set_gain_reg:0000000000000000 $a
     /tmp/ccoJr8Ow.s:130    .text.trf6151_set_gain_reg:0000000000000000 trf6151_set_gain_reg
     /tmp/ccoJr8Ow.s:195    .text.trf6151_set_gain_reg:0000000000000060 $d
     /tmp/ccoJr8Ow.s:200    .text.trf6151_set_gain:0000000000000000 $a
     /tmp/ccoJr8Ow.s:203    .text.trf6151_set_gain:0000000000000000 trf6151_set_gain
     /tmp/ccoJr8Ow.s:272    .text.trf6151_set_gain:0000000000000070 $d
     /tmp/ccoJr8Ow.s:277    .text.trf6151_power:0000000000000000 $a
     /tmp/ccoJr8Ow.s:280    .text.trf6151_power:0000000000000000 trf6151_power
     /tmp/ccoJr8Ow.s:335    .text.trf6151_power:000000000000005c $d
     /tmp/ccoJr8Ow.s:341    .text.trf6151_init:0000000000000000 $a
     /tmp/ccoJr8Ow.s:344    .text.trf6151_init:0000000000000000 trf6151_init
     /tmp/ccoJr8Ow.s:400    .text.trf6151_init:0000000000000058 $d
     /tmp/ccoJr8Ow.s:405    .text.trf6151_set_mode:0000000000000000 $a
     /tmp/ccoJr8Ow.s:408    .text.trf6151_set_mode:0000000000000000 trf6151_set_mode
     /tmp/ccoJr8Ow.s:445    .text.trf6151_set_mode:0000000000000030 $d
     /tmp/ccoJr8Ow.s:451    .text.trf6151_set_arfcn:0000000000000000 $a
     /tmp/ccoJr8Ow.s:454    .text.trf6151_set_arfcn:0000000000000000 trf6151_set_arfcn
     /tmp/ccoJr8Ow.s:724    .text.trf6151_set_arfcn:00000000000001f8 $d
     /tmp/ccoJr8Ow.s:737    .text.trf6151_calib_dc_offs:0000000000000000 $a
     /tmp/ccoJr8Ow.s:740    .text.trf6151_calib_dc_offs:0000000000000000 trf6151_calib_dc_offs
     /tmp/ccoJr8Ow.s:770    .text.trf6151_calib_dc_offs:0000000000000024 $d
     /tmp/ccoJr8Ow.s:775    .text.trf6151_get_gain_reg:0000000000000000 $a
     /tmp/ccoJr8Ow.s:778    .text.trf6151_get_gain_reg:0000000000000000 trf6151_get_gain_reg
     /tmp/ccoJr8Ow.s:816    .text.trf6151_get_gain_reg:0000000000000034 $d
     /tmp/ccoJr8Ow.s:822    .text.trf6151_get_gain:0000000000000000 $a
     /tmp/ccoJr8Ow.s:825    .text.trf6151_get_gain:0000000000000000 trf6151_get_gain
     /tmp/ccoJr8Ow.s:854    .text.trf6151_get_gain:0000000000000024 $d
     /tmp/ccoJr8Ow.s:859    .text.trf6151_test:0000000000000000 $a
     /tmp/ccoJr8Ow.s:862    .text.trf6151_test:0000000000000000 trf6151_test
     /tmp/ccoJr8Ow.s:905    .text.trf6151_tx_test:0000000000000000 $a
     /tmp/ccoJr8Ow.s:908    .text.trf6151_tx_test:0000000000000000 trf6151_tx_test
     /tmp/ccoJr8Ow.s:952    .text.trf6151_rx_window:0000000000000000 $a
     /tmp/ccoJr8Ow.s:955    .text.trf6151_rx_window:0000000000000000 trf6151_rx_window
     /tmp/ccoJr8Ow.s:1002   .text.trf6151_rx_window:0000000000000050 $d
     /tmp/ccoJr8Ow.s:1007   .text.trf6151_tx_window:0000000000000000 $a
     /tmp/ccoJr8Ow.s:1010   .text.trf6151_tx_window:0000000000000000 trf6151_tx_window
     /tmp/ccoJr8Ow.s:1052   .text.trf6151_tx_window:0000000000000040 $d
     /tmp/ccoJr8Ow.s:1057   .text.trf6151_compute_gain:0000000000000000 $a
     /tmp/ccoJr8Ow.s:1060   .text.trf6151_compute_gain:0000000000000000 trf6151_compute_gain
     /tmp/ccoJr8Ow.s:1091   .text.trf6151_compute_gain:0000000000000024 $d
     /tmp/ccoJr8Ow.s:1096   .text.trf6151_iq_swapped:0000000000000000 $a
     /tmp/ccoJr8Ow.s:1099   .text.trf6151_iq_swapped:0000000000000000 trf6151_iq_swapped
     /tmp/ccoJr8Ow.s:1171   .data:0000000000000018 rf_arfcn
     /tmp/ccoJr8Ow.s:1137   .rodata:0000000000000000 $d
     /tmp/ccoJr8Ow.s:1141   .rodata:0000000000000000 CSWTCH.21
     /tmp/ccoJr8Ow.s:1150   .data:0000000000000000 $d
     /tmp/ccoJr8Ow.s:1154   .data:0000000000000000 trf6151_reg_cache
     /tmp/ccoJr8Ow.s:1162   .data:0000000000000010 trf6151_vga_dbm
     /tmp/ccoJr8Ow.s:1167   .data:0000000000000014 trf6151_gain_high
     /tmp/ccoJr8Ow.s:1174   .bss:0000000000000000 $d
     /tmp/ccoJr8Ow.s:1178   .bss:0000000000000000 trf6151_tsp_uid
     /tmp/ccoJr8Ow.s:1183   .bss:0000000000000002 rf_band
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
tpu_enqueue
tsp_write
tsp_setup
tsp_act_disable
tsp_act_enable
__udivsi3
gsm_arfcn2band
puts
gsm_arfcn2freq10
rffe_get_rx_ports
tpu_enable
tpu_wait_idle
add_mod5000
system_inherent_gain
