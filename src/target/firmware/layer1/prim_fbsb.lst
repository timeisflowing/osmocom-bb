   1              		.file	"prim_fbsb.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.l1ctl_fbsb_resp,"ax",%progbits
  12              		.align	2
  14              	l1ctl_fbsb_resp:
  15              	.LFB66:
  16              		.file 1 "layer1/prim_fbsb.c"
   1:layer1/prim_fbsb.c **** /* Layer 1 - FCCH and SCH burst handling */
   2:layer1/prim_fbsb.c **** 
   3:layer1/prim_fbsb.c **** /* (C) 2010 by Harald Welte <laforge@gnumonks.org>
   4:layer1/prim_fbsb.c ****  *
   5:layer1/prim_fbsb.c ****  * All Rights Reserved
   6:layer1/prim_fbsb.c ****  *
   7:layer1/prim_fbsb.c ****  * This program is free software; you can redistribute it and/or modify
   8:layer1/prim_fbsb.c ****  * it under the terms of the GNU General Public License as published by
   9:layer1/prim_fbsb.c ****  * the Free Software Foundation; either version 2 of the License, or
  10:layer1/prim_fbsb.c ****  * (at your option) any later version.
  11:layer1/prim_fbsb.c ****  *
  12:layer1/prim_fbsb.c ****  * This program is distributed in the hope that it will be useful,
  13:layer1/prim_fbsb.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:layer1/prim_fbsb.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:layer1/prim_fbsb.c ****  * GNU General Public License for more details.
  16:layer1/prim_fbsb.c ****  *
  17:layer1/prim_fbsb.c ****  * You should have received a copy of the GNU General Public License along
  18:layer1/prim_fbsb.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:layer1/prim_fbsb.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:layer1/prim_fbsb.c ****  *
  21:layer1/prim_fbsb.c ****  */
  22:layer1/prim_fbsb.c **** 
  23:layer1/prim_fbsb.c **** #include <stdint.h>
  24:layer1/prim_fbsb.c **** #include <stdio.h>
  25:layer1/prim_fbsb.c **** #include <string.h>
  26:layer1/prim_fbsb.c **** #include <stdlib.h>
  27:layer1/prim_fbsb.c **** #include <errno.h>
  28:layer1/prim_fbsb.c **** #include <inttypes.h>
  29:layer1/prim_fbsb.c **** #include <defines.h>
  30:layer1/prim_fbsb.c **** #include <debug.h>
  31:layer1/prim_fbsb.c **** #include <memory.h>
  32:layer1/prim_fbsb.c **** #include <byteorder.h>
  33:layer1/prim_fbsb.c **** #include <rffe.h>
  34:layer1/prim_fbsb.c **** #include <osmocom/gsm/gsm_utils.h>
  35:layer1/prim_fbsb.c **** #include <osmocom/core/msgb.h>
  36:layer1/prim_fbsb.c **** #include <calypso/dsp_api.h>
  37:layer1/prim_fbsb.c **** #include <calypso/irq.h>
  38:layer1/prim_fbsb.c **** #include <calypso/tpu.h>
  39:layer1/prim_fbsb.c **** #include <calypso/tsp.h>
  40:layer1/prim_fbsb.c **** #include <calypso/dsp.h>
  41:layer1/prim_fbsb.c **** #include <calypso/timer.h>
  42:layer1/prim_fbsb.c **** #include <comm/sercomm.h>
  43:layer1/prim_fbsb.c **** 
  44:layer1/prim_fbsb.c **** #include <layer1/sync.h>
  45:layer1/prim_fbsb.c **** #include <layer1/afc.h>
  46:layer1/prim_fbsb.c **** #include <layer1/toa.h>
  47:layer1/prim_fbsb.c **** #include <layer1/tdma_sched.h>
  48:layer1/prim_fbsb.c **** #include <layer1/mframe_sched.h>
  49:layer1/prim_fbsb.c **** #include <layer1/tpu_window.h>
  50:layer1/prim_fbsb.c **** #include <layer1/l23_api.h>
  51:layer1/prim_fbsb.c **** #include <layer1/agc.h>
  52:layer1/prim_fbsb.c **** 
  53:layer1/prim_fbsb.c **** #include <l1ctl_proto.h>
  54:layer1/prim_fbsb.c **** 
  55:layer1/prim_fbsb.c **** #define FB0_RETRY_COUNT		3
  56:layer1/prim_fbsb.c **** #define AFC_RETRY_COUNT		30
  57:layer1/prim_fbsb.c **** 
  58:layer1/prim_fbsb.c **** extern uint16_t rf_arfcn; // TODO
  59:layer1/prim_fbsb.c **** 
  60:layer1/prim_fbsb.c **** struct mon_state {
  61:layer1/prim_fbsb.c **** 	uint32_t fnr_report;	/* frame number when DSP reported it */
  62:layer1/prim_fbsb.c **** 	int attempt;		/* which attempt was this ? */
  63:layer1/prim_fbsb.c **** 
  64:layer1/prim_fbsb.c **** 	int16_t toa;
  65:layer1/prim_fbsb.c **** 	uint16_t pm;
  66:layer1/prim_fbsb.c **** 	uint16_t angle;
  67:layer1/prim_fbsb.c **** 	uint16_t snr;
  68:layer1/prim_fbsb.c **** 
  69:layer1/prim_fbsb.c **** 	/* computed values */
  70:layer1/prim_fbsb.c **** 	int16_t freq_diff;
  71:layer1/prim_fbsb.c **** 
  72:layer1/prim_fbsb.c **** 	/* Sync Burst (SB) */
  73:layer1/prim_fbsb.c **** 	uint8_t bsic;
  74:layer1/prim_fbsb.c **** 	struct gsm_time time;
  75:layer1/prim_fbsb.c **** };
  76:layer1/prim_fbsb.c **** 
  77:layer1/prim_fbsb.c **** struct l1a_fb_state {
  78:layer1/prim_fbsb.c **** 	struct mon_state mon;
  79:layer1/prim_fbsb.c **** 	struct l1ctl_fbsb_req req;
  80:layer1/prim_fbsb.c **** 	int16_t initial_freq_err;
  81:layer1/prim_fbsb.c **** 	uint8_t fb_retries;
  82:layer1/prim_fbsb.c **** 	uint8_t afc_retries;
  83:layer1/prim_fbsb.c **** };
  84:layer1/prim_fbsb.c **** 
  85:layer1/prim_fbsb.c **** static struct l1a_fb_state fbs;
  86:layer1/prim_fbsb.c **** static struct mon_state *last_fb = &fbs.mon;
  87:layer1/prim_fbsb.c **** 
  88:layer1/prim_fbsb.c **** static void dump_mon_state(struct mon_state *fb)
  89:layer1/prim_fbsb.c **** {
  90:layer1/prim_fbsb.c **** #if 0
  91:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz, "
  92:layer1/prim_fbsb.c **** 		"SNR=%04x(%d.%u) OFFSET=%u SYNCHRO=%u\n",
  93:layer1/prim_fbsb.c **** 		fb->fnr_report, fb->attempt, fb->toa,
  94:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle),
  95:layer1/prim_fbsb.c **** 		fb->snr, l1s_snr_int(fb->snr), l1s_snr_fract(fb->snr),
  96:layer1/prim_fbsb.c **** 		tpu_get_offset(), tpu_get_synchro());
  97:layer1/prim_fbsb.c **** #else
  98:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\n",
  99:layer1/prim_fbsb.c **** 		fb->fnr_report, fb->attempt, fb->toa,
 100:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle));
 101:layer1/prim_fbsb.c **** #endif
 102:layer1/prim_fbsb.c **** }
 103:layer1/prim_fbsb.c **** 
 104:layer1/prim_fbsb.c **** static int l1ctl_fbsb_resp(uint8_t res)
 105:layer1/prim_fbsb.c **** {
  17              		.loc 1 105 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              	.LVL0:
  22 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  23              	.LCFI0:
  24              		.cfi_def_cfa_offset 16
 106:layer1/prim_fbsb.c **** 	struct msgb *msg;
 107:layer1/prim_fbsb.c **** 	struct l1ctl_fbsb_conf *resp;
 108:layer1/prim_fbsb.c **** 
 109:layer1/prim_fbsb.c **** 	msg = l1_create_l2_msg(L1CTL_FBSB_CONF, fbs.mon.time.fn,
  25              		.loc 1 109 0
  26 0004 AC409FE5 		ldr	r4, .L5
  27              		.cfi_offset 14, -4
  28              		.cfi_offset 6, -8
  29              		.cfi_offset 5, -12
  30              		.cfi_offset 4, -16
 105:layer1/prim_fbsb.c **** {
  31              		.loc 1 105 0
  32 0008 0060A0E1 		mov	r6, r0
 110:layer1/prim_fbsb.c **** 				l1s_snr_int(fbs.mon.snr),
  33              		.loc 1 110 0
  34 000c BE00D4E1 		ldrh	r0, [r4, #14]
  35              	.LVL1:
 109:layer1/prim_fbsb.c **** 	msg = l1_create_l2_msg(L1CTL_FBSB_CONF, fbs.mon.time.fn,
  36              		.loc 1 109 0
  37 0010 145094E5 		ldr	r5, [r4, #20]
  38              		.loc 1 110 0
  39 0014 FEFFFFEB 		bl	l1s_snr_int
 109:layer1/prim_fbsb.c **** 	msg = l1_create_l2_msg(L1CTL_FBSB_CONF, fbs.mon.time.fn,
  40              		.loc 1 109 0
  41 0018 0028A0E1 		mov	r2, r0, asl #16
  42 001c B032D4E1 		ldrh	r3, [r4, #32]
  43 0020 0200A0E3 		mov	r0, #2
  44 0024 0510A0E1 		mov	r1, r5
  45 0028 2228A0E1 		mov	r2, r2, lsr #16
  46 002c FEFFFFEB 		bl	l1_create_l2_msg
  47              	.LVL2:
 111:layer1/prim_fbsb.c **** 				fbs.req.band_arfcn);
 112:layer1/prim_fbsb.c **** 	if (!msg)
  48              		.loc 1 112 0
  49 0030 004050E2 		subs	r4, r0, #0
  50 0034 1D00000A 		beq	.L4
  51              	.LVL3:
  52              	.LBB37:
  53              	.LBB38:
  54              	.LBB39:
  55              	.LBB40:
  56              		.file 2 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
  57              		.loc 2 152 0
  58 0038 B433D4E1 		ldrh	r3, [r4, #52]
  59              	.LBE40:
  60              	.LBE39:
  61 003c 382084E2 		add	r2, r4, #56
  62 0040 240092E8 		ldmia	r2, {r2, r5}	@ phole ldm
  63              	.LVL4:
  64              	.LBB42:
  65              	.LBB41:
  66 0044 032082E0 		add	r2, r2, r3
  67 0048 022065E0 		rsb	r2, r5, r2
  68              	.LBE41:
  69              	.LBE42:
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
  70              		.loc 2 182 0
  71 004c 030052E3 		cmp	r2, #3
  72              	.LVL5:
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
  73              		.loc 2 183 0
  74 0050 64009FD5 		ldrle	r0, .L5+4
  75              	.LVL6:
  76 0054 0410A0D1 		movle	r1, r4
  77 0058 0430A0D3 		movle	r3, #4
  78 005c FEFFFFDB 		blle	osmo_panic
  79              	.LVL7:
  80              	.L3:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
  81              		.loc 2 185 0
  82 0060 3C3094E5 		ldr	r3, [r4, #60]
  83 0064 043083E2 		add	r3, r3, #4
  84 0068 3C3084E5 		str	r3, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
  85              		.loc 2 186 0
  86 006c B633D4E1 		ldrh	r3, [r4, #54]
  87 0070 043083E2 		add	r3, r3, #4
  88 0074 B633C4E1 		strh	r3, [r4, #54]	@ movhi
  89              	.LVL8:
  90              	.LBE38:
  91              	.LBE37:
 113:layer1/prim_fbsb.c **** 		return -ENOMEM;
 114:layer1/prim_fbsb.c **** 
 115:layer1/prim_fbsb.c **** 	resp = (struct l1ctl_fbsb_conf *) msgb_put(msg, sizeof(*resp));
 116:layer1/prim_fbsb.c **** 	resp->initial_freq_err = htons(fbs.initial_freq_err);
  92              		.loc 1 116 0
  93 0078 38309FE5 		ldr	r3, .L5
  94 007c BE22D3E1 		ldrh	r2, [r3, #46]
  95              	.LVL9:
  96              	.LBB43:
  97              	.LBB44:
  98              		.file 3 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
  99              		.loc 3 51 0
 100 0080 2214A0E1 		mov	r1, r2, lsr #8
 101 0084 022481E1 		orr	r2, r1, r2, asl #8
 102              	.LVL10:
 103              	.LBE44:
 104              	.LBE43:
 105              		.loc 1 116 0
 106 0088 0020C5E5 		strb	r2, [r5, #0]
 107 008c 2224A0E1 		mov	r2, r2, lsr #8
 108 0090 0120C5E5 		strb	r2, [r5, #1]
 117:layer1/prim_fbsb.c **** 	resp->result = res;
 109              		.loc 1 117 0
 110 0094 0260C5E5 		strb	r6, [r5, #2]
 118:layer1/prim_fbsb.c **** 	resp->bsic = fbs.mon.bsic;
 111              		.loc 1 118 0
 112 0098 1230D3E5 		ldrb	r3, [r3, #18]	@ zero_extendqisi2
 119:layer1/prim_fbsb.c **** 
 120:layer1/prim_fbsb.c **** 	/* no need to set BSIC, as it is never used here */
 121:layer1/prim_fbsb.c **** 	l1_queue_for_l2(msg);
 113              		.loc 1 121 0
 114 009c 0400A0E1 		mov	r0, r4
 118:layer1/prim_fbsb.c **** 	resp->bsic = fbs.mon.bsic;
 115              		.loc 1 118 0
 116 00a0 0330C5E5 		strb	r3, [r5, #3]
 117              		.loc 1 121 0
 118 00a4 FEFFFFEB 		bl	l1_queue_for_l2
 122:layer1/prim_fbsb.c **** 
 123:layer1/prim_fbsb.c **** 	return 0;
 119              		.loc 1 123 0
 120 00a8 0000A0E3 		mov	r0, #0
 121 00ac 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 122              	.LVL11:
 123              	.L4:
 113:layer1/prim_fbsb.c **** 		return -ENOMEM;
 124              		.loc 1 113 0
 125 00b0 0B00E0E3 		mvn	r0, #11
 124:layer1/prim_fbsb.c **** }
 126              		.loc 1 124 0
 127 00b4 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 128              	.L6:
 129              		.align	2
 130              	.L5:
 131 00b8 00000000 		.word	.LANCHOR0
 132 00bc 00000000 		.word	.LC0
 133              		.cfi_endproc
 134              	.LFE66:
 136              		.global	__udivsi3
 137              		.section	.text.l1s_sbdet_resp,"ax",%progbits
 138              		.align	2
 140              	l1s_sbdet_resp:
 141              	.LFB69:
 125:layer1/prim_fbsb.c **** 
 126:layer1/prim_fbsb.c **** /* SCH Burst Detection ********************************************************/
 127:layer1/prim_fbsb.c **** 
 128:layer1/prim_fbsb.c **** /* determine the GSM time and BSIC from a Sync Burst */
 129:layer1/prim_fbsb.c **** static uint8_t l1s_decode_sb(struct gsm_time *time, uint32_t sb)
 130:layer1/prim_fbsb.c **** {
 131:layer1/prim_fbsb.c **** 	uint8_t bsic = (sb >> 2) & 0x3f;
 132:layer1/prim_fbsb.c **** 	uint8_t t3p;
 133:layer1/prim_fbsb.c **** 
 134:layer1/prim_fbsb.c **** 	memset(time, 0, sizeof(*time));
 135:layer1/prim_fbsb.c **** 
 136:layer1/prim_fbsb.c **** 	/* TS 05.02 Chapter 3.3.2.2.1 SCH Frame Numbers */
 137:layer1/prim_fbsb.c **** 	time->t1 = ((sb >> 23) & 1) | ((sb >> 7) & 0x1fe) | ((sb << 9) & 0x600);
 138:layer1/prim_fbsb.c **** 	time->t2 = (sb >> 18) & 0x1f;
 139:layer1/prim_fbsb.c **** 	t3p = ((sb >> 24) & 1) | ((sb >> 15) & 6);
 140:layer1/prim_fbsb.c **** 	time->t3 = t3p*10 + 1;
 141:layer1/prim_fbsb.c **** 
 142:layer1/prim_fbsb.c **** 	/* TS 05.02 Chapter 4.3.3 TDMA frame number */
 143:layer1/prim_fbsb.c **** 	time->fn = gsm_gsmtime2fn(time);
 144:layer1/prim_fbsb.c **** 
 145:layer1/prim_fbsb.c **** 	time->tc = (time->fn / 51) % 8;
 146:layer1/prim_fbsb.c **** 
 147:layer1/prim_fbsb.c **** 	return bsic;
 148:layer1/prim_fbsb.c **** }
 149:layer1/prim_fbsb.c **** 
 150:layer1/prim_fbsb.c **** static void read_sb_result(struct mon_state *st, int attempt)
 151:layer1/prim_fbsb.c **** {
 152:layer1/prim_fbsb.c **** 	st->toa = dsp_api.db_r->a_serv_demod[D_TOA];
 153:layer1/prim_fbsb.c **** 	st->pm = dsp_api.db_r->a_serv_demod[D_PM]>>3;
 154:layer1/prim_fbsb.c **** 	st->angle = dsp_api.db_r->a_serv_demod[D_ANGLE];
 155:layer1/prim_fbsb.c **** 	st->snr = dsp_api.db_r->a_serv_demod[D_SNR];
 156:layer1/prim_fbsb.c **** 
 157:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(st->angle);
 158:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 159:layer1/prim_fbsb.c **** 	st->attempt = attempt;
 160:layer1/prim_fbsb.c **** 
 161:layer1/prim_fbsb.c **** 	dump_mon_state(st);
 162:layer1/prim_fbsb.c **** 
 163:layer1/prim_fbsb.c **** 	if (st->snr > AFC_SNR_THRESHOLD)
 164:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 1);
 165:layer1/prim_fbsb.c **** 	else
 166:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 0);
 167:layer1/prim_fbsb.c **** 
 168:layer1/prim_fbsb.c **** 	dsp_api.r_page_used = 1;
 169:layer1/prim_fbsb.c **** }
 170:layer1/prim_fbsb.c **** 
 171:layer1/prim_fbsb.c **** /* Note: When we get the SB response, it is 2 TDMA frames after the SB
 172:layer1/prim_fbsb.c ****  * actually happened, as it is a "C W W R" task */
 173:layer1/prim_fbsb.c **** #define SB2_LATENCY	2
 174:layer1/prim_fbsb.c **** 
 175:layer1/prim_fbsb.c **** static int l1s_sbdet_resp(__unused uint8_t p1, uint8_t attempt,
 176:layer1/prim_fbsb.c **** 			  __unused uint16_t p3)
 177:layer1/prim_fbsb.c **** {
 142              		.loc 1 177 0
 143              		.cfi_startproc
 144              		@ args = 0, pretend = 0, frame = 0
 145              		@ frame_needed = 0, uses_anonymous_args = 0
 146              	.LVL12:
 147 0000 F3452DE9 		stmfd	sp!, {r0, r1, r4, r5, r6, r7, r8, sl, lr}
 148              	.LCFI1:
 149              		.cfi_def_cfa_offset 36
 178:layer1/prim_fbsb.c **** 	uint32_t sb;
 179:layer1/prim_fbsb.c **** 	int qbits, fn_offset;
 180:layer1/prim_fbsb.c **** 	struct l1_cell_info *cinfo = &l1s.serving_cell;
 181:layer1/prim_fbsb.c **** 	int fnr_delta, bits_delta;
 182:layer1/prim_fbsb.c **** 
 183:layer1/prim_fbsb.c **** 	putchart('s');
 184:layer1/prim_fbsb.c **** 
 185:layer1/prim_fbsb.c **** 	if (dsp_api.db_r->a_sch[0] & (1<<B_SCH_CRC)) {
 150              		.loc 1 185 0
 151 0004 E8429FE5 		ldr	r4, .L22
 152              		.cfi_offset 14, -4
 153              		.cfi_offset 10, -8
 154              		.cfi_offset 8, -12
 155              		.cfi_offset 7, -16
 156              		.cfi_offset 6, -20
 157              		.cfi_offset 5, -24
 158              		.cfi_offset 4, -28
 159              		.cfi_offset 1, -32
 160              		.cfi_offset 0, -36
 161 0008 043094E5 		ldr	r3, [r4, #4]
 162 000c BE61D3E1 		ldrh	r6, [r3, #30]
 163 0010 016C16E2 		ands	r6, r6, #256
 177:layer1/prim_fbsb.c **** {
 164              		.loc 1 177 0
 165 0014 FF5001E2 		and	r5, r1, #255
 166              		.loc 1 185 0
 167 0018 0700000A 		beq	.L8
 186:layer1/prim_fbsb.c **** 		/* mark READ page as being used */
 187:layer1/prim_fbsb.c **** 		dsp_api.r_page_used = 1;
 168              		.loc 1 187 0
 169 001c 0130A0E3 		mov	r3, #1
 188:layer1/prim_fbsb.c **** 
 189:layer1/prim_fbsb.c **** 		/* after 2nd attempt, we failed */
 190:layer1/prim_fbsb.c **** 		if (attempt == 2) {
 170              		.loc 1 190 0
 171 0020 020055E3 		cmp	r5, #2
 187:layer1/prim_fbsb.c **** 		dsp_api.r_page_used = 1;
 172              		.loc 1 187 0
 173 0024 183084E5 		str	r3, [r4, #24]
 174              		.loc 1 190 0
 175 0028 AF00001A 		bne	.L9
 191:layer1/prim_fbsb.c **** 			last_fb->attempt = 13;
 176              		.loc 1 191 0
 177 002c C4329FE5 		ldr	r3, .L22+4
 178 0030 0D20A0E3 		mov	r2, #13
 179              	.LVL13:
 180 0034 042083E5 		str	r2, [r3, #4]
 181 0038 A90000EA 		b	.L18
 182              	.LVL14:
 183              	.L8:
 192:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 193:layer1/prim_fbsb.c **** 		}
 194:layer1/prim_fbsb.c **** 
 195:layer1/prim_fbsb.c **** 		/* after 1st attempt, we simply wait for 2nd */
 196:layer1/prim_fbsb.c **** 		return 0;
 197:layer1/prim_fbsb.c **** 	}
 198:layer1/prim_fbsb.c **** 
 199:layer1/prim_fbsb.c **** 	printf("SB%d ", attempt);
 184              		.loc 1 199 0
 185 003c 0510A0E1 		mov	r1, r5
 186              	.LVL15:
 187 0040 B4029FE5 		ldr	r0, .L22+8
 188              	.LVL16:
 189 0044 FEFFFFEB 		bl	printf
 190              	.LVL17:
 191              	.LBB51:
 192              	.LBB52:
 152:layer1/prim_fbsb.c **** 	st->toa = dsp_api.db_r->a_serv_demod[D_TOA];
 193              		.loc 1 152 0
 194 0048 043094E5 		ldr	r3, [r4, #4]
 195 004c A4429FE5 		ldr	r4, .L22+4
 196 0050 B0A1D3E1 		ldrh	sl, [r3, #16]
 154:layer1/prim_fbsb.c **** 	st->angle = dsp_api.db_r->a_serv_demod[D_ANGLE];
 197              		.loc 1 154 0
 198 0054 B421D3E1 		ldrh	r2, [r3, #20]
 153:layer1/prim_fbsb.c **** 	st->pm = dsp_api.db_r->a_serv_demod[D_PM]>>3;
 199              		.loc 1 153 0
 200 0058 B201D3E1 		ldrh	r0, [r3, #18]
 155:layer1/prim_fbsb.c **** 	st->snr = dsp_api.db_r->a_serv_demod[D_SNR];
 201              		.loc 1 155 0
 202 005c B631D3E1 		ldrh	r3, [r3, #22]
 157:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(st->angle);
 203              		.loc 1 157 0
 204 0060 98829FE5 		ldr	r8, .L22+12
 155:layer1/prim_fbsb.c **** 	st->snr = dsp_api.db_r->a_serv_demod[D_SNR];
 205              		.loc 1 155 0
 206 0064 BE30C4E1 		strh	r3, [r4, #14]	@ movhi
 157:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(st->angle);
 207              		.loc 1 157 0
 208 0068 0238A0E1 		mov	r3, r2, asl #16
 209 006c 4338A0E1 		mov	r3, r3, asr #16
 210 0070 980303E0 		mul	r3, r8, r3
 154:layer1/prim_fbsb.c **** 	st->angle = dsp_api.db_r->a_serv_demod[D_ANGLE];
 211              		.loc 1 154 0
 212 0074 BC20C4E1 		strh	r2, [r4, #12]	@ movhi
 157:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(st->angle);
 213              		.loc 1 157 0
 214 0078 000053E3 		cmp	r3, #0
 215 007c FF2C83E2 		add	r2, r3, #65280
 216 0080 FF3082B2 		addlt	r3, r2, #255
 217 0084 4338A0E1 		mov	r3, r3, asr #16
 218 0088 B031C4E1 		strh	r3, [r4, #16]	@ movhi
 158:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 219              		.loc 1 158 0
 220 008c 70329FE5 		ldr	r3, .L22+16
 221 0090 007093E5 		ldr	r7, [r3, #0]
 153:layer1/prim_fbsb.c **** 	st->pm = dsp_api.db_r->a_serv_demod[D_PM]>>3;
 222              		.loc 1 153 0
 223 0094 A001A0E1 		mov	r0, r0, lsr #3
 158:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 224              		.loc 1 158 0
 225 0098 007084E5 		str	r7, [r4, #0]
 152:layer1/prim_fbsb.c **** 	st->toa = dsp_api.db_r->a_serv_demod[D_TOA];
 226              		.loc 1 152 0
 227 009c B8A0C4E1 		strh	sl, [r4, #8]	@ movhi
 153:layer1/prim_fbsb.c **** 	st->pm = dsp_api.db_r->a_serv_demod[D_PM]>>3;
 228              		.loc 1 153 0
 229 00a0 BA00C4E1 		strh	r0, [r4, #10]	@ movhi
 159:layer1/prim_fbsb.c **** 	st->attempt = attempt;
 230              		.loc 1 159 0
 231 00a4 045084E5 		str	r5, [r4, #4]
 232              	.LVL18:
 233              	.LBB53:
 234              	.LBB54:
 100:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle));
 235              		.loc 1 100 0
 236 00a8 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
  98:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\n",
 237              		.loc 1 98 0
 238 00ac 0008A0E1 		mov	r0, r0, asl #16
 239 00b0 4008A0E1 		mov	r0, r0, asr #16
 240 00b4 072080E2 		add	r2, r0, #7
 241 00b8 000050E3 		cmp	r0, #0
 242 00bc 0200A0B1 		movlt	r0, r2
 243 00c0 C001A0E1 		mov	r0, r0, asr #3
 244 00c4 00008DE5 		str	r0, [sp, #0]
 100:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle));
 245              		.loc 1 100 0
 246 00c8 FC20D4E1 		ldrsh	r2, [r4, #12]
 247 00cc 920808E0 		mul	r8, r2, r8
  98:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\n",
 248              		.loc 1 98 0
 249 00d0 000058E3 		cmp	r8, #0
 250 00d4 FF2C88E2 		add	r2, r8, #65280
 251 00d8 FF8082B2 		addlt	r8, r2, #255
 252 00dc 0A38A0E1 		mov	r3, sl, asl #16
 253 00e0 0710A0E1 		mov	r1, r7
 254 00e4 0520A0E1 		mov	r2, r5
 255 00e8 4338A0E1 		mov	r3, r3, asr #16
 256 00ec 4888A0E1 		mov	r8, r8, asr #16
 257 00f0 10029FE5 		ldr	r0, .L22+20
 258 00f4 04808DE5 		str	r8, [sp, #4]
 259 00f8 FEFFFFEB 		bl	printf
 260              	.LBE54:
 261              	.LBE53:
 163:layer1/prim_fbsb.c **** 	if (st->snr > AFC_SNR_THRESHOLD)
 262              		.loc 1 163 0
 263 00fc BE30D4E1 		ldrh	r3, [r4, #14]
 264 0100 0A0C53E3 		cmp	r3, #2560
 265 0104 00329FE5 		ldr	r3, .L22+24
 166:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 0);
 266              		.loc 1 166 0
 267 0108 0620A091 		movls	r2, r6
 164:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 1);
 268              		.loc 1 164 0
 269 010c B010D381 		ldrhih	r1, [r3, #0]
 166:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 0);
 270              		.loc 1 166 0
 271 0110 B010D391 		ldrlsh	r1, [r3, #0]
 164:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 1);
 272              		.loc 1 164 0
 273 0114 0120A083 		movhi	r2, #1
 274 0118 F001D4E1 		ldrsh	r0, [r4, #16]
 166:layer1/prim_fbsb.c **** 		afc_input(st->freq_diff, rf_arfcn, 0);
 275              		.loc 1 166 0
 276 011c FEFFFFEB 		bl	afc_input
 168:layer1/prim_fbsb.c **** 	dsp_api.r_page_used = 1;
 277              		.loc 1 168 0
 278 0120 CC319FE5 		ldr	r3, .L22
 279 0124 0120A0E3 		mov	r2, #1
 280 0128 182083E5 		str	r2, [r3, #24]
 281              	.LBE52:
 282              	.LBE51:
 200:layer1/prim_fbsb.c **** 	read_sb_result(last_fb, attempt);
 201:layer1/prim_fbsb.c **** 
 202:layer1/prim_fbsb.c **** 	sb = dsp_api.db_r->a_sch[3] | dsp_api.db_r->a_sch[4] << 16;
 283              		.loc 1 202 0
 284 012c 043093E5 		ldr	r3, [r3, #4]
 285              	.LBB55:
 286              	.LBB57:
 203:layer1/prim_fbsb.c **** 	fbs.mon.bsic = l1s_decode_sb(&fbs.mon.time, sb);
 287              		.loc 1 203 0
 288 0130 C0419FE5 		ldr	r4, .L22+4
 289              	.LBE57:
 290              	.LBE55:
 202:layer1/prim_fbsb.c **** 	sb = dsp_api.db_r->a_sch[3] | dsp_api.db_r->a_sch[4] << 16;
 291              		.loc 1 202 0
 292 0134 B662D3E1 		ldrh	r6, [r3, #38]
 293 0138 B432D3E1 		ldrh	r3, [r3, #36]
 294              	.LBB60:
 295              	.LBB58:
 134:layer1/prim_fbsb.c **** 	memset(time, 0, sizeof(*time));
 296              		.loc 1 134 0
 297 013c 0010A0E3 		mov	r1, #0
 298 0140 0B2082E2 		add	r2, r2, #11
 299 0144 140084E2 		add	r0, r4, #20
 300              	.LBE58:
 301              	.LBE60:
 202:layer1/prim_fbsb.c **** 	sb = dsp_api.db_r->a_sch[3] | dsp_api.db_r->a_sch[4] << 16;
 302              		.loc 1 202 0
 303 0148 066883E1 		orr	r6, r3, r6, asl #16
 304              	.LVL19:
 305              	.LBB61:
 306              	.LBB56:
 134:layer1/prim_fbsb.c **** 	memset(time, 0, sizeof(*time));
 307              		.loc 1 134 0
 308 014c FEFFFFEB 		bl	memset
 137:layer1/prim_fbsb.c **** 	time->t1 = ((sb >> 23) & 1) | ((sb >> 7) & 0x1fe) | ((sb << 9) & 0x600);
 309              		.loc 1 137 0
 310 0150 B8319FE5 		ldr	r3, .L22+28
 311 0154 A623A0E1 		mov	r2, r6, lsr #7
 312 0158 033002E0 		and	r3, r2, r3
 313 015c 0624A0E1 		mov	r2, r6, asl #8
 314 0160 A23F83E1 		orr	r3, r3, r2, lsr #31
 315 0164 8624A0E1 		mov	r2, r6, asl #9
 316 0168 062C02E2 		and	r2, r2, #1536
 317 016c 023083E1 		orr	r3, r3, r2
 318 0170 B831C4E1 		strh	r3, [r4, #24]	@ movhi
 138:layer1/prim_fbsb.c **** 	time->t2 = (sb >> 18) & 0x1f;
 319              		.loc 1 138 0
 320 0174 2639A0E1 		mov	r3, r6, lsr #18
 321 0178 1F3003E2 		and	r3, r3, #31
 322 017c 1A30C4E5 		strb	r3, [r4, #26]
 139:layer1/prim_fbsb.c **** 	t3p = ((sb >> 24) & 1) | ((sb >> 15) & 6);
 323              		.loc 1 139 0
 324 0180 A637A0E1 		mov	r3, r6, lsr #15
 325 0184 8623A0E1 		mov	r2, r6, asl #7
 326 0188 063003E2 		and	r3, r3, #6
 327 018c A23F83E1 		orr	r3, r3, r2, lsr #31
 140:layer1/prim_fbsb.c **** 	time->t3 = t3p*10 + 1;
 328              		.loc 1 140 0
 329 0190 0A20A0E3 		mov	r2, #10
 330 0194 920303E0 		mul	r3, r2, r3
 331 0198 013083E2 		add	r3, r3, #1
 332 019c 1B30C4E5 		strb	r3, [r4, #27]
 143:layer1/prim_fbsb.c **** 	time->fn = gsm_gsmtime2fn(time);
 333              		.loc 1 143 0
 334 01a0 140084E2 		add	r0, r4, #20
 335 01a4 FEFFFFEB 		bl	gsm_gsmtime2fn
 145:layer1/prim_fbsb.c **** 	time->tc = (time->fn / 51) % 8;
 336              		.loc 1 145 0
 337 01a8 3310A0E3 		mov	r1, #51
 143:layer1/prim_fbsb.c **** 	time->fn = gsm_gsmtime2fn(time);
 338              		.loc 1 143 0
 339 01ac 140084E5 		str	r0, [r4, #20]
 145:layer1/prim_fbsb.c **** 	time->tc = (time->fn / 51) % 8;
 340              		.loc 1 145 0
 341 01b0 FEFFFFEB 		bl	__udivsi3
 131:layer1/prim_fbsb.c **** 	uint8_t bsic = (sb >> 2) & 0x3f;
 342              		.loc 1 131 0
 343 01b4 2671A0E1 		mov	r7, r6, lsr #2
 344 01b8 3F7007E2 		and	r7, r7, #63
 345              	.LVL20:
 145:layer1/prim_fbsb.c **** 	time->tc = (time->fn / 51) % 8;
 346              		.loc 1 145 0
 347 01bc 070000E2 		and	r0, r0, #7
 348              	.LBE56:
 349              	.LBE61:
 204:layer1/prim_fbsb.c **** 	printf("=> SB 0x%08"PRIx32": BSIC=%u ", sb, fbs.mon.bsic);
 350              		.loc 1 204 0
 351 01c0 0610A0E1 		mov	r1, r6
 352 01c4 0720A0E1 		mov	r2, r7
 353              	.LBB62:
 354              	.LBB59:
 145:layer1/prim_fbsb.c **** 	time->tc = (time->fn / 51) % 8;
 355              		.loc 1 145 0
 356 01c8 1C00C4E5 		strb	r0, [r4, #28]
 357              	.LBE59:
 358              	.LBE62:
 203:layer1/prim_fbsb.c **** 	fbs.mon.bsic = l1s_decode_sb(&fbs.mon.time, sb);
 359              		.loc 1 203 0
 360 01cc 1270C4E5 		strb	r7, [r4, #18]
 361              		.loc 1 204 0
 362 01d0 3C019FE5 		ldr	r0, .L22+32
 363 01d4 FEFFFFEB 		bl	printf
 205:layer1/prim_fbsb.c **** 	l1s_time_dump(&fbs.mon.time);
 364              		.loc 1 205 0
 365 01d8 140084E2 		add	r0, r4, #20
 366 01dc FEFFFFEB 		bl	l1s_time_dump
 206:layer1/prim_fbsb.c **** 
 207:layer1/prim_fbsb.c **** 	l1s.serving_cell.bsic = fbs.mon.bsic;
 367              		.loc 1 207 0
 368 01e0 1220D4E5 		ldrb	r2, [r4, #18]	@ zero_extendqisi2
 369 01e4 18319FE5 		ldr	r3, .L22+16
 370 01e8 1A20C3E5 		strb	r2, [r3, #26]
 208:layer1/prim_fbsb.c **** 
 209:layer1/prim_fbsb.c **** 	/* calculate synchronisation value (TODO: only complete for qbits) */
 210:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 371              		.loc 1 210 0
 372 01ec B830D4E1 		ldrh	r3, [r4, #8]
 373 01f0 173043E2 		sub	r3, r3, #23
 374 01f4 0338A0E1 		mov	r3, r3, asl #16
 375 01f8 2338A0E1 		mov	r3, r3, lsr #16
 376 01fc B830C4E1 		strh	r3, [r4, #8]	@ movhi
 211:layer1/prim_fbsb.c **** 	qbits = last_fb->toa * 4;
 377              		.loc 1 211 0
 378 0200 0338A0E1 		mov	r3, r3, asl #16
 379 0204 4338A0E1 		mov	r3, r3, asr #16
 212:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn; // TODO
 213:layer1/prim_fbsb.c **** 
 214:layer1/prim_fbsb.c **** 	if (qbits > QBITS_PER_TDMA) {
 380              		.loc 1 214 0
 381 0208 08219FE5 		ldr	r2, .L22+36
 211:layer1/prim_fbsb.c **** 	qbits = last_fb->toa * 4;
 382              		.loc 1 211 0
 383 020c 0311A0E1 		mov	r1, r3, asl #2
 384              	.LVL21:
 385              		.loc 1 214 0
 386 0210 020051E1 		cmp	r1, r2
 215:layer1/prim_fbsb.c **** 		qbits -= QBITS_PER_TDMA;
 387              		.loc 1 215 0
 388 0214 4E1D41C2 		subgt	r1, r1, #4992
 389              	.LVL22:
 390 0218 081041C2 		subgt	r1, r1, #8
 214:layer1/prim_fbsb.c **** 	if (qbits > QBITS_PER_TDMA) {
 391              		.loc 1 214 0
 392 021c 020000CA 		bgt	.L13
 216:layer1/prim_fbsb.c **** 		fn_offset -= 1;
 217:layer1/prim_fbsb.c **** 	} else if (qbits < 0)  {
 393              		.loc 1 217 0
 394 0220 000051E3 		cmp	r1, #0
 218:layer1/prim_fbsb.c **** 		qbits += QBITS_PER_TDMA;
 395              		.loc 1 218 0
 396 0224 4E1D81B2 		addlt	r1, r1, #4992
 397 0228 081081B2 		addlt	r1, r1, #8
 398              	.LVL23:
 399              	.L13:
 219:layer1/prim_fbsb.c **** 		fn_offset += 1;
 220:layer1/prim_fbsb.c **** 	}
 221:layer1/prim_fbsb.c **** 
 222:layer1/prim_fbsb.c **** 	fnr_delta = last_fb->fnr_report - attempt;
 400              		.loc 1 222 0
 401 022c C4209FE5 		ldr	r2, .L22+4
 402 0230 00C092E5 		ldr	ip, [r2, #0]
 223:layer1/prim_fbsb.c **** 	bits_delta = fnr_delta * BITS_PER_TDMA;
 403              		.loc 1 223 0
 404 0234 E0209FE5 		ldr	r2, .L22+40
 222:layer1/prim_fbsb.c **** 	fnr_delta = last_fb->fnr_report - attempt;
 405              		.loc 1 222 0
 406 0238 0CC065E0 		rsb	ip, r5, ip
 407              	.LVL24:
 408              		.loc 1 223 0
 409 023c 9C0202E0 		mul	r2, ip, r2
 410              	.LVL25:
 224:layer1/prim_fbsb.c **** 
 225:layer1/prim_fbsb.c **** 	cinfo->fn_offset = fnr_delta;
 411              		.loc 1 225 0
 412 0240 BC009FE5 		ldr	r0, .L22+16
 413 0244 1CC080E5 		str	ip, [r0, #28]
 226:layer1/prim_fbsb.c **** 	cinfo->time_alignment = qbits;
 227:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 414              		.loc 1 227 0
 415 0248 BCC09FE5 		ldr	ip, .L22+24
 416              	.LVL26:
 417 024c B0C0DCE1 		ldrh	ip, [ip, #0]
 228:layer1/prim_fbsb.c **** 
 229:layer1/prim_fbsb.c **** 	if (last_fb->toa > bits_delta)
 418              		.loc 1 229 0
 419 0250 020053E1 		cmp	r3, r2
 226:layer1/prim_fbsb.c **** 	cinfo->time_alignment = qbits;
 420              		.loc 1 226 0
 421 0254 201080E5 		str	r1, [r0, #32]
 227:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 422              		.loc 1 227 0
 423 0258 B8C1C0E1 		strh	ip, [r0, #24]	@ movhi
 230:layer1/prim_fbsb.c **** 		printf("=> DSP reports SB in bit that is %d bits in the "
 424              		.loc 1 230 0
 425 025c 031062C0 		rsbgt	r1, r2, r3
 426              	.LVL27:
 427 0260 B8009FC5 		ldrgt	r0, .L22+44
 428              	.LVL28:
 231:layer1/prim_fbsb.c **** 			"future?!?\n", last_fb->toa - bits_delta);
 232:layer1/prim_fbsb.c **** 	else
 233:layer1/prim_fbsb.c **** 		printf(" qbits=%u\n", qbits);
 429              		.loc 1 233 0
 430 0264 B8009FD5 		ldrle	r0, .L22+48
 431 0268 FEFFFFEB 		bl	printf
 432              	.LVL29:
 234:layer1/prim_fbsb.c **** 
 235:layer1/prim_fbsb.c **** 	synchronize_tdma(&l1s.serving_cell);
 433              		.loc 1 235 0
 434 026c B4009FE5 		ldr	r0, .L22+52
 435 0270 FEFFFFEB 		bl	synchronize_tdma
 236:layer1/prim_fbsb.c **** 
 237:layer1/prim_fbsb.c **** 	/* if we have recived a SYNC burst, update our local GSM time */
 238:layer1/prim_fbsb.c **** 	gsm_fn2gsmtime(&l1s.current_time, fbs.mon.time.fn + SB2_LATENCY);
 436              		.loc 1 238 0
 437 0274 7C309FE5 		ldr	r3, .L22+4
 438 0278 84409FE5 		ldr	r4, .L22+16
 439 027c 141093E5 		ldr	r1, [r3, #20]
 440 0280 0400A0E1 		mov	r0, r4
 441 0284 021081E2 		add	r1, r1, #2
 442 0288 FEFFFFEB 		bl	gsm_fn2gsmtime
 239:layer1/prim_fbsb.c **** 	/* compute next time from new current time */
 240:layer1/prim_fbsb.c **** 	l1s.next_time = l1s.current_time;
 443              		.loc 1 240 0
 444 028c 070094E8 		ldmia	r4, {r0, r1, r2}
 445 0290 0C3084E2 		add	r3, r4, #12
 446 0294 070083E8 		stmia	r3, {r0, r1, r2}
 241:layer1/prim_fbsb.c **** 	l1s_time_inc(&l1s.next_time, 1);
 447              		.loc 1 241 0
 448 0298 0300A0E1 		mov	r0, r3
 449 029c 0110A0E3 		mov	r1, #1
 450 02a0 FEFFFFEB 		bl	l1s_time_inc
 242:layer1/prim_fbsb.c **** 
 243:layer1/prim_fbsb.c **** 	/* If we call tdma_sched_reset(), which is only needed if there
 244:layer1/prim_fbsb.c **** 	 * are further l1s_sbdet_resp() scheduled, we will bring
 245:layer1/prim_fbsb.c **** 	 * dsp_api.db_r and dsp_api.db_w out of sync because we changed
 246:layer1/prim_fbsb.c **** 	 * dsp_api.db_w for l1s_sbdet_cmd() and canceled
 247:layer1/prim_fbsb.c **** 	 * l1s_sbdet_resp() which would change dsp_api.db_r. The DSP
 248:layer1/prim_fbsb.c **** 	 * however expects dsp_api.db_w and dsp_api.db_r to be in sync
 249:layer1/prim_fbsb.c **** 	 * (either "0 - 0" or "1 - 1"). So we have to bring dsp_api.db_w
 250:layer1/prim_fbsb.c **** 	 * and dsp_api.db_r into sync again, otherwise NB reading will
 251:layer1/prim_fbsb.c **** 	 * complain. We probably don't need the Abort command and could
 252:layer1/prim_fbsb.c **** 	 * just bring dsp_api.db_w and dsp_api.db_r into sync.  */
 253:layer1/prim_fbsb.c **** 	if (attempt != 2) {
 451              		.loc 1 253 0
 452 02a4 020055E3 		cmp	r5, #2
 453 02a8 0100000A 		beq	.L16
 254:layer1/prim_fbsb.c **** 		tdma_sched_reset();
 454              		.loc 1 254 0
 455 02ac FEFFFFEB 		bl	tdma_sched_reset
 255:layer1/prim_fbsb.c **** 		l1s_dsp_abort();
 456              		.loc 1 255 0
 457 02b0 FEFFFFEB 		bl	l1s_dsp_abort
 458              	.L16:
 256:layer1/prim_fbsb.c **** 	}
 257:layer1/prim_fbsb.c **** 
 258:layer1/prim_fbsb.c **** 	l1s_reset_hw();
 459              		.loc 1 258 0
 460 02b4 FEFFFFEB 		bl	l1s_reset_hw
 259:layer1/prim_fbsb.c **** 	/* enable the MF Task for BCCH reading */
 260:layer1/prim_fbsb.c **** 	mframe_enable(MF_TASK_BCCH_NORM);
 461              		.loc 1 260 0
 462 02b8 0000A0E3 		mov	r0, #0
 463 02bc FEFFFFEB 		bl	mframe_enable
 261:layer1/prim_fbsb.c **** 	if (l1s.serving_cell.ccch_mode == CCCH_MODE_COMBINED)
 464              		.loc 1 261 0
 465 02c0 3C309FE5 		ldr	r3, .L22+16
 466 02c4 1B30D3E5 		ldrb	r3, [r3, #27]	@ zero_extendqisi2
 467 02c8 020053E3 		cmp	r3, #2
 262:layer1/prim_fbsb.c **** 		mframe_enable(MF_TASK_CCCH_COMB);
 468              		.loc 1 262 0
 469 02cc 0300A003 		moveq	r0, #3
 261:layer1/prim_fbsb.c **** 	if (l1s.serving_cell.ccch_mode == CCCH_MODE_COMBINED)
 470              		.loc 1 261 0
 471 02d0 0200000A 		beq	.L21
 263:layer1/prim_fbsb.c **** 	else if (l1s.serving_cell.ccch_mode == CCCH_MODE_NON_COMBINED)
 472              		.loc 1 263 0
 473 02d4 010053E3 		cmp	r3, #1
 474 02d8 0100001A 		bne	.L18
 264:layer1/prim_fbsb.c **** 		mframe_enable(MF_TASK_CCCH);
 475              		.loc 1 264 0
 476 02dc 0200A0E3 		mov	r0, #2
 477              	.L21:
 478 02e0 FEFFFFEB 		bl	mframe_enable
 479              	.LVL30:
 480              	.L18:
 265:layer1/prim_fbsb.c **** 
 266:layer1/prim_fbsb.c **** 	l1s_compl_sched(L1_COMPL_FB);
 481              		.loc 1 266 0
 482 02e4 0000A0E3 		mov	r0, #0
 483 02e8 FEFFFFEB 		bl	l1s_compl_sched
 484              	.L9:
 267:layer1/prim_fbsb.c **** 
 268:layer1/prim_fbsb.c **** 	return 0;
 269:layer1/prim_fbsb.c **** }
 485              		.loc 1 269 0
 486 02ec 0000A0E3 		mov	r0, #0
 487 02f0 FC85BDE8 		ldmfd	sp!, {r2, r3, r4, r5, r6, r7, r8, sl, pc}
 488              	.L23:
 489              		.align	2
 490              	.L22:
 491 02f4 00000000 		.word	dsp_api
 492 02f8 00000000 		.word	.LANCHOR0
 493 02fc 33000000 		.word	.LC1
 494 0300 C0500100 		.word	86208
 495 0304 00000000 		.word	l1s
 496 0308 39000000 		.word	.LC2
 497 030c 00000000 		.word	rf_arfcn
 498 0310 FE010000 		.word	510
 499 0314 67000000 		.word	.LC3
 500 0318 88130000 		.word	5000
 501 031c E2040000 		.word	1250
 502 0320 7F000000 		.word	.LC4
 503 0324 BA000000 		.word	.LC5
 504 0328 18000000 		.word	l1s+24
 505              		.cfi_endproc
 506              	.LFE69:
 508              		.section	.text.l1s_sbdet_cmd,"ax",%progbits
 509              		.align	2
 511              	l1s_sbdet_cmd:
 512              	.LFB70:
 270:layer1/prim_fbsb.c **** 
 271:layer1/prim_fbsb.c **** static int l1s_sbdet_cmd(__unused uint8_t p1, __unused uint8_t p2,
 272:layer1/prim_fbsb.c **** 			 __unused uint16_t p3)
 273:layer1/prim_fbsb.c **** {
 513              		.loc 1 273 0
 514              		.cfi_startproc
 515              		@ args = 0, pretend = 0, frame = 0
 516              		@ frame_needed = 0, uses_anonymous_args = 0
 517              	.LVL31:
 274:layer1/prim_fbsb.c **** 	putchart('S');
 275:layer1/prim_fbsb.c **** 
 276:layer1/prim_fbsb.c **** 	fbs.mon.bsic = 0;
 518              		.loc 1 276 0
 519 0000 40309FE5 		ldr	r3, .L25
 273:layer1/prim_fbsb.c **** {
 520              		.loc 1 273 0
 521 0004 10402DE9 		stmfd	sp!, {r4, lr}
 522              	.LCFI2:
 523              		.cfi_def_cfa_offset 8
 524              		.loc 1 276 0
 525 0008 0040A0E3 		mov	r4, #0
 526              		.cfi_offset 14, -4
 527              		.cfi_offset 4, -8
 528 000c 1240C3E5 		strb	r4, [r3, #18]
 277:layer1/prim_fbsb.c **** 	fbs.mon.time.fn = 0;
 529              		.loc 1 277 0
 530 0010 144083E5 		str	r4, [r3, #20]
 278:layer1/prim_fbsb.c **** 
 279:layer1/prim_fbsb.c **** 	dsp_api.db_w->d_task_md = SB_DSP_TASK;
 531              		.loc 1 279 0
 532 0014 30309FE5 		ldr	r3, .L25+4
 533 0018 082093E5 		ldr	r2, [r3, #8]
 534              	.LVL32:
 280:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_mode = 0; /* wideband search */
 535              		.loc 1 280 0
 536 001c 003093E5 		ldr	r3, [r3, #0]
 279:layer1/prim_fbsb.c **** 	dsp_api.db_w->d_task_md = SB_DSP_TASK;
 537              		.loc 1 279 0
 538 0020 0610A0E3 		mov	r1, #6	@ movhi
 539              	.LVL33:
 540 0024 B810C2E1 		strh	r1, [r2, #8]	@ movhi
 541              		.loc 1 280 0
 542 0028 BA44C3E1 		strh	r4, [r3, #74]	@ movhi
 281:layer1/prim_fbsb.c **** 
 282:layer1/prim_fbsb.c **** 	/* Program TPU */
 283:layer1/prim_fbsb.c **** 	l1s_rx_win_ctrl(rf_arfcn, L1_RXWIN_SB, 0);
 543              		.loc 1 283 0
 544 002c 1C309FE5 		ldr	r3, .L25+8
 545 0030 0210A0E3 		mov	r1, #2
 546 0034 B000D3E1 		ldrh	r0, [r3, #0]
 547              	.LVL34:
 548 0038 0420A0E1 		mov	r2, r4
 549 003c FEFFFFEB 		bl	l1s_rx_win_ctrl
 284:layer1/prim_fbsb.c **** 
 285:layer1/prim_fbsb.c **** 	return 0;
 286:layer1/prim_fbsb.c **** }
 550              		.loc 1 286 0
 551 0040 0400A0E1 		mov	r0, r4
 552 0044 1080BDE8 		ldmfd	sp!, {r4, pc}
 553              	.L26:
 554              		.align	2
 555              	.L25:
 556 0048 00000000 		.word	.LANCHOR0
 557 004c 00000000 		.word	dsp_api
 558 0050 00000000 		.word	rf_arfcn
 559              		.cfi_endproc
 560              	.LFE70:
 562              		.section	.text.l1s_fbdet_cmd,"ax",%progbits
 563              		.align	2
 565              	l1s_fbdet_cmd:
 566              	.LFB74:
 287:layer1/prim_fbsb.c **** 
 288:layer1/prim_fbsb.c **** /* This is how it is done by the TSM30 */
 289:layer1/prim_fbsb.c **** static const struct tdma_sched_item sb_sched_set[] = {
 290:layer1/prim_fbsb.c **** 	SCHED_ITEM_DT(l1s_sbdet_cmd, 0, 0, 1),	SCHED_END_FRAME(),
 291:layer1/prim_fbsb.c **** 	SCHED_ITEM_DT(l1s_sbdet_cmd, 0, 0, 2),	SCHED_END_FRAME(),
 292:layer1/prim_fbsb.c **** 						SCHED_END_FRAME(),
 293:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_sbdet_resp, -4, 0, 1),	SCHED_END_FRAME(),
 294:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_sbdet_resp, -4, 0, 2),	SCHED_END_FRAME(),
 295:layer1/prim_fbsb.c **** 	SCHED_END_SET()
 296:layer1/prim_fbsb.c **** };
 297:layer1/prim_fbsb.c **** 
 298:layer1/prim_fbsb.c **** void l1s_sb_test(uint8_t base_fn)
 299:layer1/prim_fbsb.c **** {
 300:layer1/prim_fbsb.c **** 	tdma_schedule_set(base_fn, sb_sched_set, 0);
 301:layer1/prim_fbsb.c **** }
 302:layer1/prim_fbsb.c **** /* FCCH Burst *****************************************************************/
 303:layer1/prim_fbsb.c **** 
 304:layer1/prim_fbsb.c **** static int read_fb_result(struct mon_state *st, int attempt)
 305:layer1/prim_fbsb.c **** {
 306:layer1/prim_fbsb.c **** 	st->toa = dsp_api.ndb->a_sync_demod[D_TOA];
 307:layer1/prim_fbsb.c **** 	st->pm = dsp_api.ndb->a_sync_demod[D_PM]>>3;
 308:layer1/prim_fbsb.c **** 	st->angle = dsp_api.ndb->a_sync_demod[D_ANGLE];
 309:layer1/prim_fbsb.c **** 	st->snr = dsp_api.ndb->a_sync_demod[D_SNR];
 310:layer1/prim_fbsb.c **** 
 311:layer1/prim_fbsb.c **** 	//last_fb->angle = clip_int16(last_fb->angle, AFC_MAX_ANGLE);
 312:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(last_fb->angle);
 313:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 314:layer1/prim_fbsb.c **** 	st->attempt = attempt;
 315:layer1/prim_fbsb.c **** 
 316:layer1/prim_fbsb.c **** 	dump_mon_state(st);
 317:layer1/prim_fbsb.c **** 
 318:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_det = 0;
 319:layer1/prim_fbsb.c **** 	dsp_api.ndb->a_sync_demod[D_TOA] = 0; /* TSM30 does it (really needed ?) */
 320:layer1/prim_fbsb.c **** 
 321:layer1/prim_fbsb.c **** 	/* Update AFC with current frequency offset */
 322:layer1/prim_fbsb.c **** 	afc_correct(st->freq_diff, rf_arfcn);
 323:layer1/prim_fbsb.c **** 
 324:layer1/prim_fbsb.c **** 	//tpu_dsp_frameirq_enable();
 325:layer1/prim_fbsb.c **** 	return 1;
 326:layer1/prim_fbsb.c **** }
 327:layer1/prim_fbsb.c **** 
 328:layer1/prim_fbsb.c **** static void fbinfo2cellinfo(struct l1_cell_info *cinfo,
 329:layer1/prim_fbsb.c **** 			    const struct mon_state *mon)
 330:layer1/prim_fbsb.c **** {
 331:layer1/prim_fbsb.c **** 	int ntdma, qbits, fn_offset, fnr_delta, bits_delta;
 332:layer1/prim_fbsb.c **** 
 333:layer1/prim_fbsb.c **** 	/* FIXME: where did this magic 23 come from? */
 334:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 335:layer1/prim_fbsb.c **** 
 336:layer1/prim_fbsb.c **** 	if (last_fb->toa < 0) {
 337:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa + BITS_PER_TDMA) * 4;
 338:layer1/prim_fbsb.c **** 		ntdma = -1;
 339:layer1/prim_fbsb.c **** 	} else {
 340:layer1/prim_fbsb.c **** 		ntdma = (last_fb->toa) / BITS_PER_TDMA;
 341:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa - ntdma * BITS_PER_TDMA) * 4;
 342:layer1/prim_fbsb.c **** 	}
 343:layer1/prim_fbsb.c **** 
 344:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 345:layer1/prim_fbsb.c **** 	fnr_delta = last_fb->fnr_report - last_fb->attempt;
 346:layer1/prim_fbsb.c **** 	bits_delta = fnr_delta * BITS_PER_TDMA;
 347:layer1/prim_fbsb.c **** 
 348:layer1/prim_fbsb.c **** 	cinfo->fn_offset = fnr_delta;
 349:layer1/prim_fbsb.c **** 	cinfo->time_alignment = qbits;
 350:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 351:layer1/prim_fbsb.c **** 
 352:layer1/prim_fbsb.c **** 	if (last_fb->toa > bits_delta)
 353:layer1/prim_fbsb.c **** 		printf("=> DSP reports FB in bit that is %d bits in "
 354:layer1/prim_fbsb.c **** 			"the future?!?\n", last_fb->toa - bits_delta);
 355:layer1/prim_fbsb.c **** 	else {
 356:layer1/prim_fbsb.c **** 		int fb_fnr = (last_fb->fnr_report - last_fb->attempt)
 357:layer1/prim_fbsb.c **** 				+ last_fb->toa/BITS_PER_TDMA;
 358:layer1/prim_fbsb.c **** 		printf("=>FB @ FNR %u fn_offset=%d qbits=%u\n",
 359:layer1/prim_fbsb.c **** 			fb_fnr, fn_offset, qbits);
 360:layer1/prim_fbsb.c **** 	}
 361:layer1/prim_fbsb.c **** }
 362:layer1/prim_fbsb.c **** 
 363:layer1/prim_fbsb.c **** /* scheduler callback to issue a FB detection task to the DSP */
 364:layer1/prim_fbsb.c **** static int l1s_fbdet_cmd(__unused uint8_t p1, __unused uint8_t p2,
 365:layer1/prim_fbsb.c **** 			 uint16_t fb_mode)
 366:layer1/prim_fbsb.c **** {
 567              		.loc 1 366 0
 568              		.cfi_startproc
 569              		@ args = 0, pretend = 0, frame = 0
 570              		@ frame_needed = 0, uses_anonymous_args = 0
 571              	.LVL35:
 572 0000 30402DE9 		stmfd	sp!, {r4, r5, lr}
 573              	.LCFI3:
 574              		.cfi_def_cfa_offset 12
 575              		.loc 1 366 0
 576 0004 0228A0E1 		mov	r2, r2, asl #16
 577              	.LVL36:
 367:layer1/prim_fbsb.c **** 	if (fb_mode == 0) {
 368:layer1/prim_fbsb.c **** 		putchart('F');
 369:layer1/prim_fbsb.c **** 	} else {
 370:layer1/prim_fbsb.c **** 		putchart('V');
 371:layer1/prim_fbsb.c **** 	}
 372:layer1/prim_fbsb.c **** 
 373:layer1/prim_fbsb.c **** 	l1s.fb.mode = fb_mode;
 578              		.loc 1 373 0
 579 0008 50309FE5 		ldr	r3, .L28
 374:layer1/prim_fbsb.c **** 
 375:layer1/prim_fbsb.c **** 	/* Tell the RF frontend to set the gain appropriately */
 376:layer1/prim_fbsb.c **** 	rffe_compute_gain(rxlev2dbm(fbs.req.rxlev_exp), CAL_DSP_TGT_BB_LVL);
 580              		.loc 1 376 0
 581 000c 50409FE5 		ldr	r4, .L28+4
 582              		.cfi_offset 14, -4
 583              		.cfi_offset 5, -8
 584              		.cfi_offset 4, -12
 366:layer1/prim_fbsb.c **** {
 585              		.loc 1 366 0
 586 0010 2258A0E1 		mov	r5, r2, lsr #16
 373:layer1/prim_fbsb.c **** 	l1s.fb.mode = fb_mode;
 587              		.loc 1 373 0
 588 0014 F05AC3E5 		strb	r5, [r3, #2800]
 589              		.loc 1 376 0
 590 0018 2C00D4E5 		ldrb	r0, [r4, #44]	@ zero_extendqisi2
 591              	.LVL37:
 592 001c FEFFFFEB 		bl	rxlev2dbm
 593              	.LVL38:
 594 0020 0008A0E1 		mov	r0, r0, asl #16
 595 0024 4008A0E1 		mov	r0, r0, asr #16
 596 0028 5010A0E3 		mov	r1, #80
 597 002c FEFFFFEB 		bl	rffe_compute_gain
 377:layer1/prim_fbsb.c **** 
 378:layer1/prim_fbsb.c **** 	/* Program DSP */
 379:layer1/prim_fbsb.c **** 	dsp_api.db_w->d_task_md = FB_DSP_TASK;	/* maybe with I/Q swap? */
 598              		.loc 1 379 0
 599 0030 30309FE5 		ldr	r3, .L28+8
 600 0034 082093E5 		ldr	r2, [r3, #8]
 380:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_mode = fb_mode;
 601              		.loc 1 380 0
 602 0038 003093E5 		ldr	r3, [r3, #0]
 379:layer1/prim_fbsb.c **** 	dsp_api.db_w->d_task_md = FB_DSP_TASK;	/* maybe with I/Q swap? */
 603              		.loc 1 379 0
 604 003c 0510A0E3 		mov	r1, #5	@ movhi
 605 0040 B810C2E1 		strh	r1, [r2, #8]	@ movhi
 381:layer1/prim_fbsb.c **** 
 382:layer1/prim_fbsb.c **** 	/* Program TPU */
 383:layer1/prim_fbsb.c **** 	l1s_rx_win_ctrl(fbs.req.band_arfcn, L1_RXWIN_FB, 0);
 606              		.loc 1 383 0
 607 0044 B002D4E1 		ldrh	r0, [r4, #32]
 380:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_mode = fb_mode;
 608              		.loc 1 380 0
 609 0048 BA54C3E1 		strh	r5, [r3, #74]	@ movhi
 610              		.loc 1 383 0
 611 004c 0110A0E3 		mov	r1, #1
 612 0050 0020A0E3 		mov	r2, #0
 613 0054 FEFFFFEB 		bl	l1s_rx_win_ctrl
 384:layer1/prim_fbsb.c **** 
 385:layer1/prim_fbsb.c **** 	return 0;
 386:layer1/prim_fbsb.c **** }
 614              		.loc 1 386 0
 615 0058 0000A0E3 		mov	r0, #0
 616 005c 3080BDE8 		ldmfd	sp!, {r4, r5, pc}
 617              	.L29:
 618              		.align	2
 619              	.L28:
 620 0060 00000000 		.word	l1s
 621 0064 00000000 		.word	.LANCHOR0
 622 0068 00000000 		.word	dsp_api
 623              		.cfi_endproc
 624              	.LFE74:
 626              		.global	__divsi3
 627              		.section	.text.fbinfo2cellinfo.clone.0.clone.1,"ax",%progbits
 628              		.align	2
 630              	fbinfo2cellinfo.clone.0.clone.1:
 631              	.LFB80:
 328:layer1/prim_fbsb.c **** static void fbinfo2cellinfo(struct l1_cell_info *cinfo,
 632              		.loc 1 328 0
 633              		.cfi_startproc
 634              		@ args = 0, pretend = 0, frame = 0
 635              		@ frame_needed = 0, uses_anonymous_args = 0
 636              	.LVL39:
 334:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 637              		.loc 1 334 0
 638 0000 C8309FE5 		ldr	r3, .L34
 328:layer1/prim_fbsb.c **** static void fbinfo2cellinfo(struct l1_cell_info *cinfo,
 639              		.loc 1 328 0
 640 0004 F0452DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 641              	.LCFI4:
 642              		.cfi_def_cfa_offset 28
 334:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 643              		.loc 1 334 0
 644 0008 B870D3E1 		ldrh	r7, [r3, #8]
 645              		.cfi_offset 14, -4
 646              		.cfi_offset 10, -8
 647              		.cfi_offset 8, -12
 648              		.cfi_offset 7, -16
 649              		.cfi_offset 6, -20
 650              		.cfi_offset 5, -24
 651              		.cfi_offset 4, -28
 652 000c 177047E2 		sub	r7, r7, #23
 653 0010 0778A0E1 		mov	r7, r7, asl #16
 654 0014 2778A0E1 		mov	r7, r7, lsr #16
 336:layer1/prim_fbsb.c **** 	if (last_fb->toa < 0) {
 655              		.loc 1 336 0
 656 0018 0748A0E1 		mov	r4, r7, asl #16
 657 001c 4448B0E1 		movs	r4, r4, asr #16
 334:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 658              		.loc 1 334 0
 659 0020 B870C3E1 		strh	r7, [r3, #8]	@ movhi
 336:layer1/prim_fbsb.c **** 	if (last_fb->toa < 0) {
 660              		.loc 1 336 0
 337:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa + BITS_PER_TDMA) * 4;
 661              		.loc 1 337 0
 662 0024 4E4E8442 		addmi	r4, r4, #1248
 663 0028 02408442 		addmi	r4, r4, #2
 664 002c 0441A041 		movmi	r4, r4, asl #2
 665              	.LVL40:
 338:layer1/prim_fbsb.c **** 		ntdma = -1;
 666              		.loc 1 338 0
 667 0030 0050E043 		mvnmi	r5, #0
 668 0034 0700004A 		bmi	.L32
 669              	.LVL41:
 670              	.L31:
 340:layer1/prim_fbsb.c **** 		ntdma = (last_fb->toa) / BITS_PER_TDMA;
 671              		.loc 1 340 0
 672 0038 0400A0E1 		mov	r0, r4
 673 003c 90109FE5 		ldr	r1, .L34+4
 674 0040 FEFFFFEB 		bl	__divsi3
 341:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa - ntdma * BITS_PER_TDMA) * 4;
 675              		.loc 1 341 0
 676 0044 8C309FE5 		ldr	r3, .L34+8
 340:layer1/prim_fbsb.c **** 		ntdma = (last_fb->toa) / BITS_PER_TDMA;
 677              		.loc 1 340 0
 678 0048 0008A0E1 		mov	r0, r0, asl #16
 679 004c 4058A0E1 		mov	r5, r0, asr #16
 680              	.LVL42:
 341:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa - ntdma * BITS_PER_TDMA) * 4;
 681              		.loc 1 341 0
 682 0050 934524E0 		mla	r4, r3, r5, r4
 683 0054 0441A0E1 		mov	r4, r4, asl #2
 684              	.LVL43:
 685              	.L32:
 344:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 686              		.loc 1 344 0
 687 0058 70309FE5 		ldr	r3, .L34
 688 005c 400193E8 		ldmia	r3, {r6, r8}	@ phole ldm
 346:layer1/prim_fbsb.c **** 	bits_delta = fnr_delta * BITS_PER_TDMA;
 689              		.loc 1 346 0
 690 0060 6C109FE5 		ldr	r1, .L34+4
 345:layer1/prim_fbsb.c **** 	fnr_delta = last_fb->fnr_report - last_fb->attempt;
 691              		.loc 1 345 0
 692 0064 066068E0 		rsb	r6, r8, r6
 346:layer1/prim_fbsb.c **** 	bits_delta = fnr_delta * BITS_PER_TDMA;
 693              		.loc 1 346 0
 694 0068 910603E0 		mul	r3, r1, r6
 350:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 695              		.loc 1 350 0
 696 006c 68009FE5 		ldr	r0, .L34+12
 352:layer1/prim_fbsb.c **** 	if (last_fb->toa > bits_delta)
 697              		.loc 1 352 0
 698 0070 0778A0E1 		mov	r7, r7, asl #16
 344:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 699              		.loc 1 344 0
 700 0074 64209FE5 		ldr	r2, .L34+16
 350:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 701              		.loc 1 350 0
 702 0078 B000D0E1 		ldrh	r0, [r0, #0]
 352:layer1/prim_fbsb.c **** 	if (last_fb->toa > bits_delta)
 703              		.loc 1 352 0
 704 007c 4778A0E1 		mov	r7, r7, asr #16
 705 0080 030057E1 		cmp	r7, r3
 344:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 706              		.loc 1 344 0
 707 0084 00A092E5 		ldr	sl, [r2, #0]
 708              	.LVL44:
 348:layer1/prim_fbsb.c **** 	cinfo->fn_offset = fnr_delta;
 709              		.loc 1 348 0
 710 0088 1C6082E5 		str	r6, [r2, #28]
 349:layer1/prim_fbsb.c **** 	cinfo->time_alignment = qbits;
 711              		.loc 1 349 0
 712 008c 204082E5 		str	r4, [r2, #32]
 350:layer1/prim_fbsb.c **** 	cinfo->arfcn = rf_arfcn;
 713              		.loc 1 350 0
 714 0090 B801C2E1 		strh	r0, [r2, #24]	@ movhi
 352:layer1/prim_fbsb.c **** 	if (last_fb->toa > bits_delta)
 715              		.loc 1 352 0
 716 0094 030000DA 		ble	.L33
 353:layer1/prim_fbsb.c **** 		printf("=> DSP reports FB in bit that is %d bits in "
 717              		.loc 1 353 0
 718 0098 44009FE5 		ldr	r0, .L34+20
 719 009c 071063E0 		rsb	r1, r3, r7
 361:layer1/prim_fbsb.c **** }
 720              		.loc 1 361 0
 721 00a0 F045BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 353:layer1/prim_fbsb.c **** 		printf("=> DSP reports FB in bit that is %d bits in "
 722              		.loc 1 353 0
 723 00a4 FEFFFFEA 		b	printf
 724              	.LVL45:
 725              	.L33:
 726              	.LBB63:
 357:layer1/prim_fbsb.c **** 				+ last_fb->toa/BITS_PER_TDMA;
 727              		.loc 1 357 0
 728 00a8 0700A0E1 		mov	r0, r7
 729 00ac FEFFFFEB 		bl	__divsi3
 730              	.LVL46:
 731              	.LBE63:
 344:layer1/prim_fbsb.c **** 	fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 732              		.loc 1 344 0
 733 00b0 0A8068E0 		rsb	r8, r8, sl
 734              	.LVL47:
 735              	.LBB64:
 357:layer1/prim_fbsb.c **** 				+ last_fb->toa/BITS_PER_TDMA;
 736              		.loc 1 357 0
 737 00b4 0018A0E1 		mov	r1, r0, asl #16
 358:layer1/prim_fbsb.c **** 		printf("=>FB @ FNR %u fn_offset=%d qbits=%u\n",
 738              		.loc 1 358 0
 739 00b8 28009FE5 		ldr	r0, .L34+24
 740 00bc 411886E0 		add	r1, r6, r1, asr #16
 741 00c0 052088E0 		add	r2, r8, r5
 742 00c4 0430A0E1 		mov	r3, r4
 743              	.LBE64:
 361:layer1/prim_fbsb.c **** }
 744              		.loc 1 361 0
 745 00c8 F045BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, sl, lr}
 746              	.LBB65:
 358:layer1/prim_fbsb.c **** 		printf("=>FB @ FNR %u fn_offset=%d qbits=%u\n",
 747              		.loc 1 358 0
 748 00cc FEFFFFEA 		b	printf
 749              	.L35:
 750              		.align	2
 751              	.L34:
 752 00d0 00000000 		.word	.LANCHOR0
 753 00d4 E2040000 		.word	1250
 754 00d8 1EFBFFFF 		.word	-1250
 755 00dc 00000000 		.word	rf_arfcn
 756 00e0 00000000 		.word	l1s
 757 00e4 C5000000 		.word	.LC6
 758 00e8 00010000 		.word	.LC7
 759              	.LBE65:
 760              		.cfi_endproc
 761              	.LFE80:
 763              		.section	.text.l1s_fbdet_resp,"ax",%progbits
 764              		.align	2
 766              	l1s_fbdet_resp:
 767              	.LFB75:
 387:layer1/prim_fbsb.c **** 
 388:layer1/prim_fbsb.c **** #if 0
 389:layer1/prim_fbsb.c **** #define FB0_SNR_THRESH	2000
 390:layer1/prim_fbsb.c **** #define FB1_SNR_THRESH	3000
 391:layer1/prim_fbsb.c **** #else
 392:layer1/prim_fbsb.c **** #define FB0_SNR_THRESH	0
 393:layer1/prim_fbsb.c **** #define FB1_SNR_THRESH	0
 394:layer1/prim_fbsb.c **** #endif
 395:layer1/prim_fbsb.c **** 
 396:layer1/prim_fbsb.c **** static const struct tdma_sched_item fb_sched_set[];
 397:layer1/prim_fbsb.c **** 
 398:layer1/prim_fbsb.c **** /* scheduler callback to check for a FB detection response */
 399:layer1/prim_fbsb.c **** static int l1s_fbdet_resp(__unused uint8_t p1, uint8_t attempt,
 400:layer1/prim_fbsb.c **** 			  uint16_t fb_mode)
 401:layer1/prim_fbsb.c **** {
 768              		.loc 1 401 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 0
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772              	.LVL48:
 773 0000 F3472DE9 		stmfd	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 774              	.LCFI5:
 775              		.cfi_def_cfa_offset 40
 402:layer1/prim_fbsb.c **** 	putchart('f');
 403:layer1/prim_fbsb.c **** 
 404:layer1/prim_fbsb.c **** 	if (!dsp_api.ndb->d_fb_det) {
 776              		.loc 1 404 0
 777 0004 E8529FE5 		ldr	r5, .L50
 778              		.cfi_offset 14, -4
 779              		.cfi_offset 10, -8
 780              		.cfi_offset 9, -12
 781              		.cfi_offset 8, -16
 782              		.cfi_offset 7, -20
 783              		.cfi_offset 6, -24
 784              		.cfi_offset 5, -28
 785              		.cfi_offset 4, -32
 786              		.cfi_offset 1, -36
 787              		.cfi_offset 0, -40
 788 0008 003095E5 		ldr	r3, [r5, #0]
 789 000c B884D3E1 		ldrh	r8, [r3, #72]
 401:layer1/prim_fbsb.c **** {
 790              		.loc 1 401 0
 791 0010 0228A0E1 		mov	r2, r2, asl #16
 792              	.LVL49:
 793              		.loc 1 404 0
 794 0014 000058E3 		cmp	r8, #0
 401:layer1/prim_fbsb.c **** {
 795              		.loc 1 401 0
 796 0018 FF7001E2 		and	r7, r1, #255
 797 001c 2268A0E1 		mov	r6, r2, lsr #16
 798              		.loc 1 404 0
 799 0020 1100001A 		bne	.L37
 405:layer1/prim_fbsb.c **** 		/* we did not detect a FB */
 406:layer1/prim_fbsb.c **** 
 407:layer1/prim_fbsb.c **** 		/* attempt < 12, do nothing */
 408:layer1/prim_fbsb.c **** 		if (attempt < 12)
 800              		.loc 1 408 0
 801 0024 0B0057E3 		cmp	r7, #11
 802 0028 AF00009A 		bls	.L38
 409:layer1/prim_fbsb.c **** 			return 0;
 410:layer1/prim_fbsb.c **** 
 411:layer1/prim_fbsb.c **** 		/* attempt >= 12, we simply don't find one */
 412:layer1/prim_fbsb.c **** 
 413:layer1/prim_fbsb.c **** 		/* If we don't reset here, we get DSP DMA errors */
 414:layer1/prim_fbsb.c **** 		tdma_sched_reset();
 415:layer1/prim_fbsb.c **** 
 416:layer1/prim_fbsb.c **** 		if (fbs.fb_retries < FB0_RETRY_COUNT) {
 803              		.loc 1 416 0
 804 002c C4429FE5 		ldr	r4, .L50+4
 414:layer1/prim_fbsb.c **** 		tdma_sched_reset();
 805              		.loc 1 414 0
 806 0030 FEFFFFEB 		bl	tdma_sched_reset
 807              	.LVL50:
 808              		.loc 1 416 0
 809 0034 3030D4E5 		ldrb	r3, [r4, #48]	@ zero_extendqisi2
 810 0038 020053E3 		cmp	r3, #2
 417:layer1/prim_fbsb.c **** 			/* retry once more */
 418:layer1/prim_fbsb.c **** 			tdma_schedule_set(1, fb_sched_set, 0);
 419:layer1/prim_fbsb.c **** 			fbs.fb_retries++;
 420:layer1/prim_fbsb.c **** 		} else {
 421:layer1/prim_fbsb.c **** 			last_fb->attempt = 13;
 811              		.loc 1 421 0
 812 003c 0D30A083 		movhi	r3, #13
 813 0040 04308485 		strhi	r3, [r4, #4]
 422:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 814              		.loc 1 422 0
 815 0044 0800A081 		movhi	r0, r8
 416:layer1/prim_fbsb.c **** 		if (fbs.fb_retries < FB0_RETRY_COUNT) {
 816              		.loc 1 416 0
 817 0048 A600008A 		bhi	.L45
 418:layer1/prim_fbsb.c **** 			tdma_schedule_set(1, fb_sched_set, 0);
 818              		.loc 1 418 0
 819 004c 0100A0E3 		mov	r0, #1
 820 0050 A4129FE5 		ldr	r1, .L50+8
 821 0054 0820A0E1 		mov	r2, r8
 822 0058 FEFFFFEB 		bl	tdma_schedule_set
 419:layer1/prim_fbsb.c **** 			fbs.fb_retries++;
 823              		.loc 1 419 0
 824 005c 3030D4E5 		ldrb	r3, [r4, #48]	@ zero_extendqisi2
 825 0060 013083E2 		add	r3, r3, #1
 826 0064 3030C4E5 		strb	r3, [r4, #48]
 827 0068 9F0000EA 		b	.L38
 828              	.LVL51:
 829              	.L37:
 423:layer1/prim_fbsb.c **** 		}
 424:layer1/prim_fbsb.c **** 
 425:layer1/prim_fbsb.c **** 		return 0;
 426:layer1/prim_fbsb.c **** 	}
 427:layer1/prim_fbsb.c **** 
 428:layer1/prim_fbsb.c **** 	/* We found a frequency burst, reset everything */
 429:layer1/prim_fbsb.c **** 	l1s_reset_hw();
 830              		.loc 1 429 0
 831 006c FEFFFFEB 		bl	l1s_reset_hw
 832              	.LVL52:
 430:layer1/prim_fbsb.c **** 
 431:layer1/prim_fbsb.c **** 	printf("FB%u ", dsp_api.ndb->d_fb_mode);
 833              		.loc 1 431 0
 834 0070 003095E5 		ldr	r3, [r5, #0]
 835 0074 84029FE5 		ldr	r0, .L50+12
 836 0078 BA14D3E1 		ldrh	r1, [r3, #74]
 837 007c FEFFFFEB 		bl	printf
 838              	.LVL53:
 839              	.LBB66:
 840              	.LBB67:
 306:layer1/prim_fbsb.c **** 	st->toa = dsp_api.ndb->a_sync_demod[D_TOA];
 841              		.loc 1 306 0
 842 0080 003095E5 		ldr	r3, [r5, #0]
 843 0084 6C429FE5 		ldr	r4, .L50+4
 308:layer1/prim_fbsb.c **** 	st->angle = dsp_api.ndb->a_sync_demod[D_ANGLE];
 844              		.loc 1 308 0
 845 0088 B025D3E1 		ldrh	r2, [r3, #80]
 306:layer1/prim_fbsb.c **** 	st->toa = dsp_api.ndb->a_sync_demod[D_TOA];
 846              		.loc 1 306 0
 847 008c BC94D3E1 		ldrh	r9, [r3, #76]
 307:layer1/prim_fbsb.c **** 	st->pm = dsp_api.ndb->a_sync_demod[D_PM]>>3;
 848              		.loc 1 307 0
 849 0090 BE04D3E1 		ldrh	r0, [r3, #78]
 309:layer1/prim_fbsb.c **** 	st->snr = dsp_api.ndb->a_sync_demod[D_SNR];
 850              		.loc 1 309 0
 851 0094 B235D3E1 		ldrh	r3, [r3, #82]
 312:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(last_fb->angle);
 852              		.loc 1 312 0
 853 0098 64A29FE5 		ldr	sl, .L50+16
 309:layer1/prim_fbsb.c **** 	st->snr = dsp_api.ndb->a_sync_demod[D_SNR];
 854              		.loc 1 309 0
 855 009c BE30C4E1 		strh	r3, [r4, #14]	@ movhi
 312:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(last_fb->angle);
 856              		.loc 1 312 0
 857 00a0 0238A0E1 		mov	r3, r2, asl #16
 858 00a4 4338A0E1 		mov	r3, r3, asr #16
 859 00a8 9A0303E0 		mul	r3, sl, r3
 308:layer1/prim_fbsb.c **** 	st->angle = dsp_api.ndb->a_sync_demod[D_ANGLE];
 860              		.loc 1 308 0
 861 00ac BC20C4E1 		strh	r2, [r4, #12]	@ movhi
 312:layer1/prim_fbsb.c **** 	st->freq_diff = ANGLE_TO_FREQ(last_fb->angle);
 862              		.loc 1 312 0
 863 00b0 000053E3 		cmp	r3, #0
 864 00b4 FF2C83E2 		add	r2, r3, #65280
 865 00b8 FF3082B2 		addlt	r3, r2, #255
 866 00bc 4338A0E1 		mov	r3, r3, asr #16
 867 00c0 B031C4E1 		strh	r3, [r4, #16]	@ movhi
 313:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 868              		.loc 1 313 0
 869 00c4 3C329FE5 		ldr	r3, .L50+20
 870 00c8 008093E5 		ldr	r8, [r3, #0]
 307:layer1/prim_fbsb.c **** 	st->pm = dsp_api.ndb->a_sync_demod[D_PM]>>3;
 871              		.loc 1 307 0
 872 00cc A001A0E1 		mov	r0, r0, lsr #3
 306:layer1/prim_fbsb.c **** 	st->toa = dsp_api.ndb->a_sync_demod[D_TOA];
 873              		.loc 1 306 0
 874 00d0 B890C4E1 		strh	r9, [r4, #8]	@ movhi
 307:layer1/prim_fbsb.c **** 	st->pm = dsp_api.ndb->a_sync_demod[D_PM]>>3;
 875              		.loc 1 307 0
 876 00d4 BA00C4E1 		strh	r0, [r4, #10]	@ movhi
 313:layer1/prim_fbsb.c **** 	st->fnr_report = l1s.current_time.fn;
 877              		.loc 1 313 0
 878 00d8 008084E5 		str	r8, [r4, #0]
 314:layer1/prim_fbsb.c **** 	st->attempt = attempt;
 879              		.loc 1 314 0
 880 00dc 047084E5 		str	r7, [r4, #4]
 881              	.LVL54:
 882              	.LBB68:
 883              	.LBB69:
 100:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle));
 884              		.loc 1 100 0
 885 00e0 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
  98:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\n",
 886              		.loc 1 98 0
 887 00e4 0008A0E1 		mov	r0, r0, asl #16
 888 00e8 4008A0E1 		mov	r0, r0, asr #16
 889 00ec 072080E2 		add	r2, r0, #7
 890 00f0 000050E3 		cmp	r0, #0
 891 00f4 0200A0B1 		movlt	r0, r2
 892 00f8 C001A0E1 		mov	r0, r0, asr #3
 893 00fc 00008DE5 		str	r0, [sp, #0]
 100:layer1/prim_fbsb.c **** 		agc_inp_dbm8_by_pm(fb->pm)/8, ANGLE_TO_FREQ(fb->angle));
 894              		.loc 1 100 0
 895 0100 FC20D4E1 		ldrsh	r2, [r4, #12]
 896 0104 920A0AE0 		mul	sl, r2, sl
  98:layer1/prim_fbsb.c **** 	printf("(%"PRIu32":%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\n",
 897              		.loc 1 98 0
 898 0108 00005AE3 		cmp	sl, #0
 899 010c FF2C8AE2 		add	r2, sl, #65280
 900 0110 FFA082B2 		addlt	sl, r2, #255
 901 0114 0938A0E1 		mov	r3, r9, asl #16
 902 0118 0810A0E1 		mov	r1, r8
 903 011c 0720A0E1 		mov	r2, r7
 904 0120 4338A0E1 		mov	r3, r3, asr #16
 905 0124 4AA8A0E1 		mov	sl, sl, asr #16
 906 0128 DC019FE5 		ldr	r0, .L50+24
 907 012c 04A08DE5 		str	sl, [sp, #4]
 908 0130 FEFFFFEB 		bl	printf
 909              	.LBE69:
 910              	.LBE68:
 318:layer1/prim_fbsb.c **** 	dsp_api.ndb->d_fb_det = 0;
 911              		.loc 1 318 0
 912 0134 003095E5 		ldr	r3, [r5, #0]
 913 0138 0020A0E3 		mov	r2, #0	@ movhi
 914 013c B824C3E1 		strh	r2, [r3, #72]	@ movhi
 319:layer1/prim_fbsb.c **** 	dsp_api.ndb->a_sync_demod[D_TOA] = 0; /* TSM30 does it (really needed ?) */
 915              		.loc 1 319 0
 916 0140 BC24C3E1 		strh	r2, [r3, #76]	@ movhi
 322:layer1/prim_fbsb.c **** 	afc_correct(st->freq_diff, rf_arfcn);
 917              		.loc 1 322 0
 918 0144 C4319FE5 		ldr	r3, .L50+28
 919 0148 F001D4E1 		ldrsh	r0, [r4, #16]
 920 014c B010D3E1 		ldrh	r1, [r3, #0]
 921 0150 FEFFFFEB 		bl	afc_correct
 922              	.LBE67:
 923              	.LBE66:
 432:layer1/prim_fbsb.c **** 	read_fb_result(last_fb, attempt);
 433:layer1/prim_fbsb.c **** 
 434:layer1/prim_fbsb.c **** 	/* if this is the first success, save freq err */
 435:layer1/prim_fbsb.c **** 	if (!fbs.initial_freq_err)
 924              		.loc 1 435 0
 925 0154 FE32D4E1 		ldrsh	r3, [r4, #46]
 926 0158 000053E3 		cmp	r3, #0
 436:layer1/prim_fbsb.c **** 		fbs.initial_freq_err = last_fb->freq_diff;
 927              		.loc 1 436 0
 928 015c B031D401 		ldreqh	r3, [r4, #16]
 929 0160 BE32C401 		streqh	r3, [r4, #46]	@ movhi
 437:layer1/prim_fbsb.c **** 
 438:layer1/prim_fbsb.c **** 	/* If we don't reset here, we get DSP DMA errors */
 439:layer1/prim_fbsb.c **** 	tdma_sched_reset();
 930              		.loc 1 439 0
 931 0164 FEFFFFEB 		bl	tdma_sched_reset
 440:layer1/prim_fbsb.c **** 
 441:layer1/prim_fbsb.c **** 	/* Immediately schedule further TDMA tasklets, if requested. Doing
 442:layer1/prim_fbsb.c **** 	 * this directly from L1S means we can do this quickly without any
 443:layer1/prim_fbsb.c **** 	 * additional delays */
 444:layer1/prim_fbsb.c **** 	if (fb_mode == 0) {
 932              		.loc 1 444 0
 933 0168 000056E3 		cmp	r6, #0
 934 016c 2100001A 		bne	.L41
 445:layer1/prim_fbsb.c **** 		if (fbs.req.flags & L1CTL_FBSB_F_FB1) {
 935              		.loc 1 445 0
 936 0170 80419FE5 		ldr	r4, .L50+4
 937 0174 2930D4E5 		ldrb	r3, [r4, #41]	@ zero_extendqisi2
 938 0178 020013E3 		tst	r3, #2
 939 017c 1B00000A 		beq	.L42
 446:layer1/prim_fbsb.c **** 			/* If we don't reset here, we get DSP DMA errors */
 447:layer1/prim_fbsb.c **** 			tdma_sched_reset();
 940              		.loc 1 447 0
 941 0180 FEFFFFEB 		bl	tdma_sched_reset
 448:layer1/prim_fbsb.c **** 			/* FIXME: don't only use the last but an average */
 449:layer1/prim_fbsb.c **** 			if (abs(last_fb->freq_diff) < fbs.req.freq_err_thresh1 &&
 942              		.loc 1 449 0
 943 0184 F021D4E1 		ldrsh	r2, [r4, #16]
 944 0188 B432D4E1 		ldrh	r3, [r4, #36]
 945 018c 000052E3 		cmp	r2, #0
 946 0190 002062B2 		rsblt	r2, r2, #0
 947 0194 030052E1 		cmp	r2, r3
 948 0198 050000AA 		bge	.L43
 949              		.loc 1 449 0 is_stmt 0 discriminator 1
 950 019c BE30D4E1 		ldrh	r3, [r4, #14]
 951 01a0 000053E3 		cmp	r3, #0
 450:layer1/prim_fbsb.c **** 			    last_fb->snr > FB0_SNR_THRESH) {
 451:layer1/prim_fbsb.c **** 				/* continue with FB1 task in DSP */
 452:layer1/prim_fbsb.c **** 				tdma_schedule_set(1, fb_sched_set, 1);
 952              		.loc 1 452 0 is_stmt 1
 953 01a4 0100A013 		movne	r0, #1
 954 01a8 4C119F15 		ldrne	r1, .L50+8
 955 01ac 0020A011 		movne	r2, r0
 956 01b0 4A00001A 		bne	.L49
 957              	.L43:
 453:layer1/prim_fbsb.c **** 			} else {
 454:layer1/prim_fbsb.c **** 				if (fbs.afc_retries < AFC_RETRY_COUNT) {
 958              		.loc 1 454 0
 959 01b4 3C419FE5 		ldr	r4, .L50+4
 960 01b8 3130D4E5 		ldrb	r3, [r4, #49]	@ zero_extendqisi2
 961 01bc 1D0053E3 		cmp	r3, #29
 455:layer1/prim_fbsb.c **** 					tdma_schedule_set(1, fb_sched_set, 0);
 456:layer1/prim_fbsb.c **** 					fbs.afc_retries++;
 457:layer1/prim_fbsb.c **** 				} else {
 458:layer1/prim_fbsb.c **** 					/* Abort */
 459:layer1/prim_fbsb.c **** 					last_fb->attempt = 13;
 962              		.loc 1 459 0
 963 01c0 0D30A083 		movhi	r3, #13
 964 01c4 04308485 		strhi	r3, [r4, #4]
 460:layer1/prim_fbsb.c **** 					l1s_compl_sched(L1_COMPL_FB);
 965              		.loc 1 460 0
 966 01c8 0000A083 		movhi	r0, #0
 454:layer1/prim_fbsb.c **** 				if (fbs.afc_retries < AFC_RETRY_COUNT) {
 967              		.loc 1 454 0
 968 01cc 4500008A 		bhi	.L45
 455:layer1/prim_fbsb.c **** 					tdma_schedule_set(1, fb_sched_set, 0);
 969              		.loc 1 455 0
 970 01d0 0100A0E3 		mov	r0, #1
 971 01d4 20119FE5 		ldr	r1, .L50+8
 972 01d8 0020A0E3 		mov	r2, #0
 973 01dc FEFFFFEB 		bl	tdma_schedule_set
 456:layer1/prim_fbsb.c **** 					fbs.afc_retries++;
 974              		.loc 1 456 0
 975 01e0 3130D4E5 		ldrb	r3, [r4, #49]	@ zero_extendqisi2
 976 01e4 013083E2 		add	r3, r3, #1
 977 01e8 3130C4E5 		strb	r3, [r4, #49]
 978 01ec 3E0000EA 		b	.L38
 979              	.L42:
 461:layer1/prim_fbsb.c **** 				}
 462:layer1/prim_fbsb.c **** 			}
 463:layer1/prim_fbsb.c **** 		} else
 464:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 980              		.loc 1 464 0
 981 01f0 0600A0E1 		mov	r0, r6
 982 01f4 3B0000EA 		b	.L45
 983              	.L41:
 465:layer1/prim_fbsb.c **** 	} else if (fb_mode == 1) {
 984              		.loc 1 465 0
 985 01f8 010056E3 		cmp	r6, #1
 986 01fc 3A00001A 		bne	.L38
 466:layer1/prim_fbsb.c **** 		if (fbs.req.flags & L1CTL_FBSB_F_SB) {
 987              		.loc 1 466 0
 988 0200 F0309FE5 		ldr	r3, .L50+4
 989 0204 2900D3E5 		ldrb	r0, [r3, #41]	@ zero_extendqisi2
 990 0208 040010E2 		ands	r0, r0, #4
 991 020c 3500000A 		beq	.L45
 992              	.LBB70:
 467:layer1/prim_fbsb.c **** 
 468:layer1/prim_fbsb.c **** 	int ntdma, qbits;
 469:layer1/prim_fbsb.c **** 	/* FIXME: where did this magic 23 come from? */
 470:layer1/prim_fbsb.c **** 	last_fb->toa -= 23;
 993              		.loc 1 470 0
 994 0210 B800D3E1 		ldrh	r0, [r3, #8]
 995 0214 170040E2 		sub	r0, r0, #23
 996 0218 0008A0E1 		mov	r0, r0, asl #16
 997 021c 2008A0E1 		mov	r0, r0, lsr #16
 998 0220 B800C3E1 		strh	r0, [r3, #8]	@ movhi
 471:layer1/prim_fbsb.c **** 
 472:layer1/prim_fbsb.c **** 	if (last_fb->toa < 0) {
 999              		.loc 1 472 0
 1000 0224 0008A0E1 		mov	r0, r0, asl #16
 1001 0228 4008B0E1 		movs	r0, r0, asr #16
 473:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa + BITS_PER_TDMA) * 4;
 474:layer1/prim_fbsb.c **** 		ntdma = -1;
 1002              		.loc 1 474 0
 1003 022c 0000E043 		mvnmi	r0, #0
 472:layer1/prim_fbsb.c **** 	if (last_fb->toa < 0) {
 1004              		.loc 1 472 0
 1005 0230 0300004A 		bmi	.L46
 475:layer1/prim_fbsb.c **** 	} else {
 476:layer1/prim_fbsb.c **** 		ntdma = (last_fb->toa) / BITS_PER_TDMA;
 1006              		.loc 1 476 0
 1007 0234 D8109FE5 		ldr	r1, .L50+32
 1008 0238 FEFFFFEB 		bl	__divsi3
 1009 023c 0008A0E1 		mov	r0, r0, asl #16
 1010 0240 4008A0E1 		mov	r0, r0, asr #16
 1011              	.LVL55:
 1012              	.L46:
 477:layer1/prim_fbsb.c **** 		qbits = (last_fb->toa - ntdma * BITS_PER_TDMA) * 4;
 478:layer1/prim_fbsb.c **** 	}
 479:layer1/prim_fbsb.c **** 
 480:layer1/prim_fbsb.c **** 
 481:layer1/prim_fbsb.c **** 			int fn_offset = l1s.current_time.fn - last_fb->attempt + ntdma;
 1013              		.loc 1 481 0
 1014 0244 AC509FE5 		ldr	r5, .L50+4
 1015 0248 B8609FE5 		ldr	r6, .L50+20
 1016 024c 043095E5 		ldr	r3, [r5, #4]
 1017 0250 002096E5 		ldr	r2, [r6, #0]
 1018 0254 027063E0 		rsb	r7, r3, r2
 1019              	.LVL56:
 1020 0258 007087E0 		add	r7, r7, r0
 1021              	.LVL57:
 482:layer1/prim_fbsb.c **** 			int delay = fn_offset + 11 - l1s.current_time.fn - 1;
 1022              		.loc 1 482 0
 1023 025c 0A4062E2 		rsb	r4, r2, #10
 1024 0260 074084E0 		add	r4, r4, r7
 1025              	.LVL58:
 483:layer1/prim_fbsb.c **** 			printf("  fn_offset=%d (fn=%"PRIu32" + attempt=%u + ntdma = %d)\n",
 1026              		.loc 1 483 0
 1027 0264 00008DE5 		str	r0, [sp, #0]
 1028 0268 0710A0E1 		mov	r1, r7
 1029 026c A4009FE5 		ldr	r0, .L50+36
 1030              	.LVL59:
 1031 0270 FEFFFFEB 		bl	printf
 1032              	.LVL60:
 484:layer1/prim_fbsb.c **** 				fn_offset, l1s.current_time.fn, last_fb->attempt, ntdma);
 485:layer1/prim_fbsb.c **** 			printf("  delay=%d (fn_offset=%d + 11 - fn=%"PRIu32" - 1\n", delay,
 1033              		.loc 1 485 0
 1034 0274 0720A0E1 		mov	r2, r7
 1035 0278 003096E5 		ldr	r3, [r6, #0]
 1036 027c 0410A0E1 		mov	r1, r4
 1037 0280 94009FE5 		ldr	r0, .L50+40
 1038 0284 FEFFFFEB 		bl	printf
 486:layer1/prim_fbsb.c **** 				fn_offset, l1s.current_time.fn);
 487:layer1/prim_fbsb.c **** 			printf("  scheduling next FB/SB detection task with delay %u\n", delay);
 1039              		.loc 1 487 0
 1040 0288 90009FE5 		ldr	r0, .L50+44
 1041 028c 0410A0E1 		mov	r1, r4
 1042 0290 FEFFFFEB 		bl	printf
 488:layer1/prim_fbsb.c **** 			if (abs(last_fb->freq_diff) < fbs.req.freq_err_thresh2 &&
 1043              		.loc 1 488 0
 1044 0294 F021D5E1 		ldrsh	r2, [r5, #16]
 1045 0298 B632D5E1 		ldrh	r3, [r5, #38]
 1046 029c 000052E3 		cmp	r2, #0
 1047 02a0 002062B2 		rsblt	r2, r2, #0
 1048 02a4 030052E1 		cmp	r2, r3
 1049 02a8 090000AA 		bge	.L47
 1050              		.loc 1 488 0 is_stmt 0 discriminator 1
 1051 02ac BE30D5E1 		ldrh	r3, [r5, #14]
 1052 02b0 000053E3 		cmp	r3, #0
 1053 02b4 0600000A 		beq	.L47
 489:layer1/prim_fbsb.c **** 			    last_fb->snr > FB1_SNR_THRESH) {
 490:layer1/prim_fbsb.c **** 				/* synchronize before reading SB */
 491:layer1/prim_fbsb.c **** 				fbinfo2cellinfo(&l1s.serving_cell, last_fb);
 1054              		.loc 1 491 0 is_stmt 1
 1055 02b8 FEFFFFEB 		bl	fbinfo2cellinfo.clone.0.clone.1
 492:layer1/prim_fbsb.c **** 				synchronize_tdma(&l1s.serving_cell);
 1056              		.loc 1 492 0
 1057 02bc 180086E2 		add	r0, r6, #24
 1058 02c0 FEFFFFEB 		bl	synchronize_tdma
 493:layer1/prim_fbsb.c **** 				tdma_schedule_set(delay, sb_sched_set, 0);
 1059              		.loc 1 493 0
 1060 02c4 FF0004E2 		and	r0, r4, #255
 1061 02c8 54109FE5 		ldr	r1, .L50+48
 1062 02cc 0020A0E3 		mov	r2, #0
 1063 02d0 020000EA 		b	.L49
 1064              	.L47:
 494:layer1/prim_fbsb.c **** 			} else
 495:layer1/prim_fbsb.c **** 				tdma_schedule_set(delay, fb_sched_set, 1);
 1065              		.loc 1 495 0
 1066 02d4 20109FE5 		ldr	r1, .L50+8
 1067 02d8 FF0004E2 		and	r0, r4, #255
 1068 02dc 0120A0E3 		mov	r2, #1
 1069              	.LVL61:
 1070              	.L49:
 1071 02e0 FEFFFFEB 		bl	tdma_schedule_set
 1072 02e4 000000EA 		b	.L38
 1073              	.LVL62:
 1074              	.L45:
 1075              	.LBE70:
 496:layer1/prim_fbsb.c **** 		} else
 497:layer1/prim_fbsb.c **** 			l1s_compl_sched(L1_COMPL_FB);
 1076              		.loc 1 497 0
 1077 02e8 FEFFFFEB 		bl	l1s_compl_sched
 1078              	.L38:
 498:layer1/prim_fbsb.c **** 	}
 499:layer1/prim_fbsb.c **** 
 500:layer1/prim_fbsb.c **** 	return 0;
 501:layer1/prim_fbsb.c **** }
 1079              		.loc 1 501 0
 1080 02ec 0000A0E3 		mov	r0, #0
 1081 02f0 FC87BDE8 		ldmfd	sp!, {r2, r3, r4, r5, r6, r7, r8, r9, sl, pc}
 1082              	.L51:
 1083              		.align	2
 1084              	.L50:
 1085 02f4 00000000 		.word	dsp_api
 1086 02f8 00000000 		.word	.LANCHOR0
 1087 02fc 00000000 		.word	.LANCHOR1
 1088 0300 25010000 		.word	.LC8
 1089 0304 C0500100 		.word	86208
 1090 0308 00000000 		.word	l1s
 1091 030c 39000000 		.word	.LC2
 1092 0310 00000000 		.word	rf_arfcn
 1093 0314 E2040000 		.word	1250
 1094 0318 2B010000 		.word	.LC9
 1095 031c 5E010000 		.word	.LC10
 1096 0320 8A010000 		.word	.LC11
 1097 0324 50010000 		.word	.LANCHOR1+336
 1098              		.cfi_endproc
 1099              	.LFE75:
 1101              		.section	.text.l1a_fb_compl,"ax",%progbits
 1102              		.align	2
 1104              	l1a_fb_compl:
 1105              	.LFB76:
 502:layer1/prim_fbsb.c **** 
 503:layer1/prim_fbsb.c **** /* FB detection */
 504:layer1/prim_fbsb.c **** static const struct tdma_sched_item fb_sched_set[] = {
 505:layer1/prim_fbsb.c **** 	SCHED_ITEM_DT(l1s_fbdet_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 506:layer1/prim_fbsb.c **** 						SCHED_END_FRAME(),
 507:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 1),	SCHED_END_FRAME(),
 508:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 2),	SCHED_END_FRAME(),
 509:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 3),	SCHED_END_FRAME(),
 510:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 4),	SCHED_END_FRAME(),
 511:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 5),	SCHED_END_FRAME(),
 512:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 6),	SCHED_END_FRAME(),
 513:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 7),	SCHED_END_FRAME(),
 514:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 8),	SCHED_END_FRAME(),
 515:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 9),	SCHED_END_FRAME(),
 516:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 10),	SCHED_END_FRAME(),
 517:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 11),	SCHED_END_FRAME(),
 518:layer1/prim_fbsb.c **** 	SCHED_ITEM(l1s_fbdet_resp, -4, 0, 12),	SCHED_END_FRAME(),
 519:layer1/prim_fbsb.c **** 	SCHED_END_SET()
 520:layer1/prim_fbsb.c **** };
 521:layer1/prim_fbsb.c **** 
 522:layer1/prim_fbsb.c **** /* Asynchronous completion handler for FB detection */
 523:layer1/prim_fbsb.c **** static void l1a_fb_compl(__unused enum l1_compl c)
 524:layer1/prim_fbsb.c **** {
 1106              		.loc 1 524 0
 1107              		.cfi_startproc
 1108              		@ args = 0, pretend = 0, frame = 0
 1109              		@ frame_needed = 0, uses_anonymous_args = 0
 1110              	.LVL63:
 525:layer1/prim_fbsb.c **** 	if (last_fb->attempt >= 13) {
 1111              		.loc 1 525 0
 1112 0000 20309FE5 		ldr	r3, .L55
 1113 0004 043093E5 		ldr	r3, [r3, #4]
 1114 0008 0C0053E3 		cmp	r3, #12
 524:layer1/prim_fbsb.c **** {
 1115              		.loc 1 524 0
 1116 000c 04E02DE5 		str	lr, [sp, #-4]!
 1117              	.LCFI6:
 1118              		.cfi_def_cfa_offset 4
 526:layer1/prim_fbsb.c **** 		/* FB detection failed, signal this via L1CTL */
 527:layer1/prim_fbsb.c **** 		l1ctl_fbsb_resp(255);
 1119              		.loc 1 527 0
 1120 0010 FF00A0C3 		movgt	r0, #255
 1121              	.LVL64:
 525:layer1/prim_fbsb.c **** 	if (last_fb->attempt >= 13) {
 1122              		.loc 1 525 0
 1123 0014 010000CA 		bgt	.L54
 1124              		.cfi_offset 14, -4
 528:layer1/prim_fbsb.c **** 		return;
 529:layer1/prim_fbsb.c **** 	}
 530:layer1/prim_fbsb.c **** 
 531:layer1/prim_fbsb.c **** 	/* FIME: use l1s.neigh_cell[fbs.cinfo_idx] */
 532:layer1/prim_fbsb.c **** 	fbinfo2cellinfo(&l1s.serving_cell, last_fb);
 1125              		.loc 1 532 0
 1126 0018 FEFFFFEB 		bl	fbinfo2cellinfo.clone.0.clone.1
 533:layer1/prim_fbsb.c **** 
 534:layer1/prim_fbsb.c **** 	/* send FBSB_CONF success message via L1CTL */
 535:layer1/prim_fbsb.c **** 	l1ctl_fbsb_resp(0);
 1127              		.loc 1 535 0
 1128 001c 0000A0E3 		mov	r0, #0
 1129              	.L54:
 536:layer1/prim_fbsb.c **** }
 1130              		.loc 1 536 0
 1131 0020 04E09DE4 		ldr	lr, [sp], #4
 535:layer1/prim_fbsb.c **** 	l1ctl_fbsb_resp(0);
 1132              		.loc 1 535 0
 1133 0024 FEFFFFEA 		b	l1ctl_fbsb_resp
 1134              	.L56:
 1135              		.align	2
 1136              	.L55:
 1137 0028 00000000 		.word	.LANCHOR0
 1138              		.cfi_endproc
 1139              	.LFE76:
 1141              		.section	.text.l1s_sb_test,"ax",%progbits
 1142              		.align	2
 1143              		.global	l1s_sb_test
 1145              	l1s_sb_test:
 1146              	.LFB71:
 299:layer1/prim_fbsb.c **** {
 1147              		.loc 1 299 0
 1148              		.cfi_startproc
 1149              		@ args = 0, pretend = 0, frame = 0
 1150              		@ frame_needed = 0, uses_anonymous_args = 0
 1151              		@ link register save eliminated.
 1152              	.LVL65:
 300:layer1/prim_fbsb.c **** 	tdma_schedule_set(base_fn, sb_sched_set, 0);
 1153              		.loc 1 300 0
 1154 0000 08109FE5 		ldr	r1, .L58
 299:layer1/prim_fbsb.c **** {
 1155              		.loc 1 299 0
 1156 0004 FF0000E2 		and	r0, r0, #255
 1157              	.LVL66:
 300:layer1/prim_fbsb.c **** 	tdma_schedule_set(base_fn, sb_sched_set, 0);
 1158              		.loc 1 300 0
 1159 0008 0020A0E3 		mov	r2, #0
 301:layer1/prim_fbsb.c **** }
 1160              		.loc 1 301 0
 300:layer1/prim_fbsb.c **** 	tdma_schedule_set(base_fn, sb_sched_set, 0);
 1161              		.loc 1 300 0
 1162 000c FEFFFFEA 		b	tdma_schedule_set
 1163              	.L59:
 1164              		.align	2
 1165              	.L58:
 1166 0010 50010000 		.word	.LANCHOR1+336
 1167              		.cfi_endproc
 1168              	.LFE71:
 1170              		.section	.text.l1s_fbsb_req,"ax",%progbits
 1171              		.align	2
 1172              		.global	l1s_fbsb_req
 1174              	l1s_fbsb_req:
 1175              	.LFB77:
 537:layer1/prim_fbsb.c **** 
 538:layer1/prim_fbsb.c **** void l1s_fbsb_req(uint8_t base_fn, struct l1ctl_fbsb_req *req)
 539:layer1/prim_fbsb.c **** {
 1176              		.loc 1 539 0
 1177              		.cfi_startproc
 1178              		@ args = 0, pretend = 0, frame = 0
 1179              		@ frame_needed = 0, uses_anonymous_args = 0
 1180              	.LVL67:
 1181 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1182              	.LCFI7:
 1183              		.cfi_def_cfa_offset 16
 540:layer1/prim_fbsb.c **** 	/* copy + endian convert request data */
 541:layer1/prim_fbsb.c **** 	fbs.req.band_arfcn = ntohs(req->band_arfcn);
 1184              		.loc 1 541 0
 1185 0004 0120D1E5 		ldrb	r2, [r1, #1]	@ zero_extendqisi2
 1186 0008 0030D1E5 		ldrb	r3, [r1, #0]	@ zero_extendqisi2
 1187 000c 023483E1 		orr	r3, r3, r2, asl #8
 1188              	.LVL68:
 1189 0010 D0509FE5 		ldr	r5, .L65
 1190              		.cfi_offset 14, -4
 1191              		.cfi_offset 6, -8
 1192              		.cfi_offset 5, -12
 1193              		.cfi_offset 4, -16
 1194              	.LBB71:
 1195              	.LBB72:
 1196              		.loc 3 51 0
 1197 0014 2324A0E1 		mov	r2, r3, lsr #8
 1198 0018 033482E1 		orr	r3, r2, r3, asl #8
 1199              	.LVL69:
 1200              	.LBE72:
 1201              	.LBE71:
 1202              		.loc 1 541 0
 1203 001c B032C5E1 		strh	r3, [r5, #32]	@ movhi
 542:layer1/prim_fbsb.c **** 	fbs.req.timeout = ntohs(req->timeout);
 1204              		.loc 1 542 0
 1205 0020 0320D1E5 		ldrb	r2, [r1, #3]	@ zero_extendqisi2
 1206 0024 0230D1E5 		ldrb	r3, [r1, #2]	@ zero_extendqisi2
 1207 0028 023483E1 		orr	r3, r3, r2, asl #8
 1208              	.LVL70:
 1209              	.LBB73:
 1210              	.LBB74:
 1211              		.loc 3 51 0
 1212 002c 2324A0E1 		mov	r2, r3, lsr #8
 1213 0030 033482E1 		orr	r3, r2, r3, asl #8
 1214              	.LVL71:
 1215              	.LBE74:
 1216              	.LBE73:
 1217              		.loc 1 542 0
 1218 0034 B232C5E1 		strh	r3, [r5, #34]	@ movhi
 543:layer1/prim_fbsb.c **** 	fbs.req.freq_err_thresh1 = ntohs(req->freq_err_thresh1);
 1219              		.loc 1 543 0
 1220 0038 0520D1E5 		ldrb	r2, [r1, #5]	@ zero_extendqisi2
 1221 003c 0430D1E5 		ldrb	r3, [r1, #4]	@ zero_extendqisi2
 1222 0040 023483E1 		orr	r3, r3, r2, asl #8
 1223              	.LVL72:
 1224              	.LBB75:
 1225              	.LBB76:
 1226              		.loc 3 51 0
 1227 0044 2324A0E1 		mov	r2, r3, lsr #8
 1228 0048 033482E1 		orr	r3, r2, r3, asl #8
 1229              	.LVL73:
 1230              	.LBE76:
 1231              	.LBE75:
 1232              		.loc 1 543 0
 1233 004c B432C5E1 		strh	r3, [r5, #36]	@ movhi
 544:layer1/prim_fbsb.c **** 	fbs.req.freq_err_thresh2 = ntohs(req->freq_err_thresh2);
 1234              		.loc 1 544 0
 1235 0050 0720D1E5 		ldrb	r2, [r1, #7]	@ zero_extendqisi2
 1236 0054 0630D1E5 		ldrb	r3, [r1, #6]	@ zero_extendqisi2
 1237 0058 023483E1 		orr	r3, r3, r2, asl #8
 1238              	.LVL74:
 1239              	.LBB77:
 1240              	.LBB78:
 1241              		.loc 3 51 0
 1242 005c 2324A0E1 		mov	r2, r3, lsr #8
 1243 0060 033482E1 		orr	r3, r2, r3, asl #8
 1244              	.LVL75:
 1245              	.LBE78:
 1246              	.LBE77:
 1247              		.loc 1 544 0
 1248 0064 B632C5E1 		strh	r3, [r5, #38]	@ movhi
 545:layer1/prim_fbsb.c **** 	fbs.req.num_freqerr_avg = req->num_freqerr_avg;
 1249              		.loc 1 545 0
 1250 0068 0830D1E5 		ldrb	r3, [r1, #8]	@ zero_extendqisi2
 1251 006c 2830C5E5 		strb	r3, [r5, #40]
 546:layer1/prim_fbsb.c **** 	fbs.req.flags = req->flags;
 1252              		.loc 1 546 0
 1253 0070 0930D1E5 		ldrb	r3, [r1, #9]	@ zero_extendqisi2
 1254 0074 2930C5E5 		strb	r3, [r5, #41]
 547:layer1/prim_fbsb.c **** 	fbs.req.sync_info_idx = req->sync_info_idx;
 1255              		.loc 1 547 0
 1256 0078 0A30D1E5 		ldrb	r3, [r1, #10]	@ zero_extendqisi2
 1257 007c 2A30C5E5 		strb	r3, [r5, #42]
 548:layer1/prim_fbsb.c **** 	fbs.req.rxlev_exp = req->rxlev_exp;
 1258              		.loc 1 548 0
 1259 0080 0C30D1E5 		ldrb	r3, [r1, #12]	@ zero_extendqisi2
 549:layer1/prim_fbsb.c **** 
 550:layer1/prim_fbsb.c **** 	/* clear initial frequency error */
 551:layer1/prim_fbsb.c **** 	fbs.initial_freq_err = 0;
 1260              		.loc 1 551 0
 1261 0084 0040A0E3 		mov	r4, #0
 539:layer1/prim_fbsb.c **** {
 1262              		.loc 1 539 0
 1263 0088 FF6000E2 		and	r6, r0, #255
 548:layer1/prim_fbsb.c **** 	fbs.req.rxlev_exp = req->rxlev_exp;
 1264              		.loc 1 548 0
 1265 008c 2C30C5E5 		strb	r3, [r5, #44]
 1266              		.loc 1 551 0
 1267 0090 BE42C5E1 		strh	r4, [r5, #46]	@ movhi
 552:layer1/prim_fbsb.c **** 	fbs.fb_retries = 0;
 1268              		.loc 1 552 0
 1269 0094 3040C5E5 		strb	r4, [r5, #48]
 553:layer1/prim_fbsb.c **** 	fbs.afc_retries = 0;
 1270              		.loc 1 553 0
 1271 0098 3140C5E5 		strb	r4, [r5, #49]
 554:layer1/prim_fbsb.c **** 
 555:layer1/prim_fbsb.c **** 	/* Make sure we start at a 'center' AFCDAC output value */
 556:layer1/prim_fbsb.c **** 	afc_reset();
 1272              		.loc 1 556 0
 1273 009c FEFFFFEB 		bl	afc_reset
 1274              	.LVL76:
 557:layer1/prim_fbsb.c **** 
 558:layer1/prim_fbsb.c **** 	/* Reset the TOA loop counters */
 559:layer1/prim_fbsb.c **** 	toa_reset();
 1275              		.loc 1 559 0
 1276 00a0 FEFFFFEB 		bl	toa_reset
 560:layer1/prim_fbsb.c **** 
 561:layer1/prim_fbsb.c **** 	if (fbs.req.flags & L1CTL_FBSB_F_FB0)
 1277              		.loc 1 561 0
 1278 00a4 2910D5E5 		ldrb	r1, [r5, #41]	@ zero_extendqisi2
 1279 00a8 012011E2 		ands	r2, r1, #1
 562:layer1/prim_fbsb.c **** 		tdma_schedule_set(base_fn, fb_sched_set, 0);
 1280              		.loc 1 562 0
 1281 00ac 0600A011 		movne	r0, r6
 1282 00b0 34109F15 		ldrne	r1, .L65+4
 1283 00b4 0420A011 		movne	r2, r4
 1284 00b8 0800001A 		bne	.L64
 1285              	.L61:
 563:layer1/prim_fbsb.c **** 	else if (fbs.req.flags & L1CTL_FBSB_F_FB1)
 1286              		.loc 1 563 0
 1287 00bc 023011E2 		ands	r3, r1, #2
 564:layer1/prim_fbsb.c **** 		tdma_schedule_set(base_fn, fb_sched_set, 0);
 1288              		.loc 1 564 0
 1289 00c0 0600A011 		movne	r0, r6
 1290 00c4 20109F15 		ldrne	r1, .L65+4
 563:layer1/prim_fbsb.c **** 	else if (fbs.req.flags & L1CTL_FBSB_F_FB1)
 1291              		.loc 1 563 0
 1292 00c8 0400001A 		bne	.L64
 565:layer1/prim_fbsb.c **** 	else if (fbs.req.flags & L1CTL_FBSB_F_SB)
 1293              		.loc 1 565 0
 1294 00cc 040011E3 		tst	r1, #4
 1295 00d0 7080BD08 		ldmeqfd	sp!, {r4, r5, r6, pc}
 566:layer1/prim_fbsb.c **** 		tdma_schedule_set(base_fn, sb_sched_set, 0);
 1296              		.loc 1 566 0
 1297 00d4 14109FE5 		ldr	r1, .L65+8
 1298 00d8 0600A0E1 		mov	r0, r6
 1299 00dc 0320A0E1 		mov	r2, r3
 1300              	.L64:
 567:layer1/prim_fbsb.c **** 
 568:layer1/prim_fbsb.c **** }
 1301              		.loc 1 568 0
 1302 00e0 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 566:layer1/prim_fbsb.c **** 		tdma_schedule_set(base_fn, sb_sched_set, 0);
 1303              		.loc 1 566 0
 1304 00e4 FEFFFFEA 		b	tdma_schedule_set
 1305              	.L66:
 1306              		.align	2
 1307              	.L65:
 1308 00e8 00000000 		.word	.LANCHOR0
 1309 00ec 00000000 		.word	.LANCHOR1
 1310 00f0 50010000 		.word	.LANCHOR1+336
 1311              		.cfi_endproc
 1312              	.LFE77:
 1314              		.section	.text.l1s_prim_fbsb_init,"ax",%progbits
 1315              		.align	2
 1317              	l1s_prim_fbsb_init:
 1318              	.LFB78:
 569:layer1/prim_fbsb.c **** 
 570:layer1/prim_fbsb.c **** static __attribute__ ((constructor)) void l1s_prim_fbsb_init(void)
 571:layer1/prim_fbsb.c **** {
 1319              		.loc 1 571 0
 1320              		.cfi_startproc
 1321              		@ args = 0, pretend = 0, frame = 0
 1322              		@ frame_needed = 0, uses_anonymous_args = 0
 1323              		@ link register save eliminated.
 572:layer1/prim_fbsb.c **** 	l1s.completion[L1_COMPL_FB] = &l1a_fb_compl;
 1324              		.loc 1 572 0
 1325 0000 08209FE5 		ldr	r2, .L68
 1326 0004 08309FE5 		ldr	r3, .L68+4
 1327 0008 702A83E5 		str	r2, [r3, #2672]
 573:layer1/prim_fbsb.c **** }
 1328              		.loc 1 573 0
 1329 000c 1EFF2FE1 		bx	lr
 1330              	.L69:
 1331              		.align	2
 1332              	.L68:
 1333 0010 00000000 		.word	l1a_fb_compl
 1334 0014 00000000 		.word	l1s
 1335              		.cfi_endproc
 1336              	.LFE78:
 1338              		.section	.ctors,"aw",%progbits
 1339              		.align	2
 1340 0000 00000000 		.word	l1s_prim_fbsb_init
 1341              		.section	.rodata
 1342              		.align	2
 1343              		.set	.LANCHOR1,. + 0
 1346              	fb_sched_set:
 1347 0000 00000000 		.word	l1s_fbdet_cmd
 1348 0004 00       		.byte	0
 1349 0005 00       		.byte	0
 1350 0006 0000     		.space	2
 1351 0008 0000     		.short	0
 1352 000a 0300     		.short	3
 1353 000c 00000000 		.word	0
 1354 0010 00       		.byte	0
 1355 0011 00       		.byte	0
 1356 0012 00000000 		.space	6
 1356      0000
 1357 0018 00000000 		.word	0
 1358 001c 00       		.byte	0
 1359 001d 00       		.byte	0
 1360 001e 00000000 		.space	6
 1360      0000
 1361 0024 00000000 		.word	l1s_fbdet_resp
 1362 0028 00       		.byte	0
 1363 0029 01       		.byte	1
 1364 002a 0000     		.space	2
 1365 002c FCFF     		.short	-4
 1366 002e 0000     		.short	0
 1367 0030 00000000 		.word	0
 1368 0034 00       		.byte	0
 1369 0035 00       		.byte	0
 1370 0036 00000000 		.space	6
 1370      0000
 1371 003c 00000000 		.word	l1s_fbdet_resp
 1372 0040 00       		.byte	0
 1373 0041 02       		.byte	2
 1374 0042 0000     		.space	2
 1375 0044 FCFF     		.short	-4
 1376 0046 0000     		.short	0
 1377 0048 00000000 		.word	0
 1378 004c 00       		.byte	0
 1379 004d 00       		.byte	0
 1380 004e 00000000 		.space	6
 1380      0000
 1381 0054 00000000 		.word	l1s_fbdet_resp
 1382 0058 00       		.byte	0
 1383 0059 03       		.byte	3
 1384 005a 0000     		.space	2
 1385 005c FCFF     		.short	-4
 1386 005e 0000     		.short	0
 1387 0060 00000000 		.word	0
 1388 0064 00       		.byte	0
 1389 0065 00       		.byte	0
 1390 0066 00000000 		.space	6
 1390      0000
 1391 006c 00000000 		.word	l1s_fbdet_resp
 1392 0070 00       		.byte	0
 1393 0071 04       		.byte	4
 1394 0072 0000     		.space	2
 1395 0074 FCFF     		.short	-4
 1396 0076 0000     		.short	0
 1397 0078 00000000 		.word	0
 1398 007c 00       		.byte	0
 1399 007d 00       		.byte	0
 1400 007e 00000000 		.space	6
 1400      0000
 1401 0084 00000000 		.word	l1s_fbdet_resp
 1402 0088 00       		.byte	0
 1403 0089 05       		.byte	5
 1404 008a 0000     		.space	2
 1405 008c FCFF     		.short	-4
 1406 008e 0000     		.short	0
 1407 0090 00000000 		.word	0
 1408 0094 00       		.byte	0
 1409 0095 00       		.byte	0
 1410 0096 00000000 		.space	6
 1410      0000
 1411 009c 00000000 		.word	l1s_fbdet_resp
 1412 00a0 00       		.byte	0
 1413 00a1 06       		.byte	6
 1414 00a2 0000     		.space	2
 1415 00a4 FCFF     		.short	-4
 1416 00a6 0000     		.short	0
 1417 00a8 00000000 		.word	0
 1418 00ac 00       		.byte	0
 1419 00ad 00       		.byte	0
 1420 00ae 00000000 		.space	6
 1420      0000
 1421 00b4 00000000 		.word	l1s_fbdet_resp
 1422 00b8 00       		.byte	0
 1423 00b9 07       		.byte	7
 1424 00ba 0000     		.space	2
 1425 00bc FCFF     		.short	-4
 1426 00be 0000     		.short	0
 1427 00c0 00000000 		.word	0
 1428 00c4 00       		.byte	0
 1429 00c5 00       		.byte	0
 1430 00c6 00000000 		.space	6
 1430      0000
 1431 00cc 00000000 		.word	l1s_fbdet_resp
 1432 00d0 00       		.byte	0
 1433 00d1 08       		.byte	8
 1434 00d2 0000     		.space	2
 1435 00d4 FCFF     		.short	-4
 1436 00d6 0000     		.short	0
 1437 00d8 00000000 		.word	0
 1438 00dc 00       		.byte	0
 1439 00dd 00       		.byte	0
 1440 00de 00000000 		.space	6
 1440      0000
 1441 00e4 00000000 		.word	l1s_fbdet_resp
 1442 00e8 00       		.byte	0
 1443 00e9 09       		.byte	9
 1444 00ea 0000     		.space	2
 1445 00ec FCFF     		.short	-4
 1446 00ee 0000     		.short	0
 1447 00f0 00000000 		.word	0
 1448 00f4 00       		.byte	0
 1449 00f5 00       		.byte	0
 1450 00f6 00000000 		.space	6
 1450      0000
 1451 00fc 00000000 		.word	l1s_fbdet_resp
 1452 0100 00       		.byte	0
 1453 0101 0A       		.byte	10
 1454 0102 0000     		.space	2
 1455 0104 FCFF     		.short	-4
 1456 0106 0000     		.short	0
 1457 0108 00000000 		.word	0
 1458 010c 00       		.byte	0
 1459 010d 00       		.byte	0
 1460 010e 00000000 		.space	6
 1460      0000
 1461 0114 00000000 		.word	l1s_fbdet_resp
 1462 0118 00       		.byte	0
 1463 0119 0B       		.byte	11
 1464 011a 0000     		.space	2
 1465 011c FCFF     		.short	-4
 1466 011e 0000     		.short	0
 1467 0120 00000000 		.word	0
 1468 0124 00       		.byte	0
 1469 0125 00       		.byte	0
 1470 0126 00000000 		.space	6
 1470      0000
 1471 012c 00000000 		.word	l1s_fbdet_resp
 1472 0130 00       		.byte	0
 1473 0131 0C       		.byte	12
 1474 0132 0000     		.space	2
 1475 0134 FCFF     		.short	-4
 1476 0136 0000     		.short	0
 1477 0138 00000000 		.word	0
 1478 013c 00       		.byte	0
 1479 013d 00       		.byte	0
 1480 013e 00000000 		.space	6
 1480      0000
 1481 0144 00000000 		.word	tdma_end_set
 1482 0148 00       		.byte	0
 1483 0149 00       		.byte	0
 1484 014a 00000000 		.space	6
 1484      0000
 1487              	sb_sched_set:
 1488 0150 00000000 		.word	l1s_sbdet_cmd
 1489 0154 00       		.byte	0
 1490 0155 01       		.byte	1
 1491 0156 0000     		.space	2
 1492 0158 0000     		.short	0
 1493 015a 0300     		.short	3
 1494 015c 00000000 		.word	0
 1495 0160 00       		.byte	0
 1496 0161 00       		.byte	0
 1497 0162 00000000 		.space	6
 1497      0000
 1498 0168 00000000 		.word	l1s_sbdet_cmd
 1499 016c 00       		.byte	0
 1500 016d 02       		.byte	2
 1501 016e 0000     		.space	2
 1502 0170 0000     		.short	0
 1503 0172 0300     		.short	3
 1504 0174 00000000 		.word	0
 1505 0178 00       		.byte	0
 1506 0179 00       		.byte	0
 1507 017a 00000000 		.space	6
 1507      0000
 1508 0180 00000000 		.word	0
 1509 0184 00       		.byte	0
 1510 0185 00       		.byte	0
 1511 0186 00000000 		.space	6
 1511      0000
 1512 018c 00000000 		.word	l1s_sbdet_resp
 1513 0190 00       		.byte	0
 1514 0191 01       		.byte	1
 1515 0192 0000     		.space	2
 1516 0194 FCFF     		.short	-4
 1517 0196 0000     		.short	0
 1518 0198 00000000 		.word	0
 1519 019c 00       		.byte	0
 1520 019d 00       		.byte	0
 1521 019e 00000000 		.space	6
 1521      0000
 1522 01a4 00000000 		.word	l1s_sbdet_resp
 1523 01a8 00       		.byte	0
 1524 01a9 02       		.byte	2
 1525 01aa 0000     		.space	2
 1526 01ac FCFF     		.short	-4
 1527 01ae 0000     		.short	0
 1528 01b0 00000000 		.word	0
 1529 01b4 00       		.byte	0
 1530 01b5 00       		.byte	0
 1531 01b6 00000000 		.space	6
 1531      0000
 1532 01bc 00000000 		.word	tdma_end_set
 1533 01c0 00       		.byte	0
 1534 01c1 00       		.byte	0
 1535 01c2 00000000 		.space	6
 1535      0000
 1536              		.section	.rodata.str1.1,"aMS",%progbits,1
 1537              	.LC0:
 1538 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 1538      28257029 
 1538      3A204E6F 
 1538      7420656E 
 1538      6F756768 
 1539 0032 00       		.ascii	"\000"
 1540              	.LC1:
 1541 0033 53422564 		.ascii	"SB%d \000"
 1541      2000
 1542              	.LC2:
 1543 0039 28256C75 		.ascii	"(%lu:%u): TOA=%5u, Power=%4ddBm, Angle=%5dHz\012\000"
 1543      3A257529 
 1543      3A20544F 
 1543      413D2535 
 1543      752C2050 
 1544              	.LC3:
 1545 0067 3D3E2053 		.ascii	"=> SB 0x%08lx: BSIC=%u \000"
 1545      42203078 
 1545      2530386C 
 1545      783A2042 
 1545      5349433D 
 1546              	.LC4:
 1547 007f 3D3E2044 		.ascii	"=> DSP reports SB in bit that is %d bits in the fut"
 1547      53502072 
 1547      65706F72 
 1547      74732053 
 1547      4220696E 
 1548 00b2 7572653F 		.ascii	"ure?!?\012\000"
 1548      213F0A00 
 1549              	.LC5:
 1550 00ba 20716269 		.ascii	" qbits=%u\012\000"
 1550      74733D25 
 1550      750A00
 1551              	.LC6:
 1552 00c5 3D3E2044 		.ascii	"=> DSP reports FB in bit that is %d bits in the fut"
 1552      53502072 
 1552      65706F72 
 1552      74732046 
 1552      4220696E 
 1553 00f8 7572653F 		.ascii	"ure?!?\012\000"
 1553      213F0A00 
 1554              	.LC7:
 1555 0100 3D3E4642 		.ascii	"=>FB @ FNR %u fn_offset=%d qbits=%u\012\000"
 1555      20402046 
 1555      4E522025 
 1555      7520666E 
 1555      5F6F6666 
 1556              	.LC8:
 1557 0125 46422575 		.ascii	"FB%u \000"
 1557      2000
 1558              	.LC9:
 1559 012b 2020666E 		.ascii	"  fn_offset=%d (fn=%lu + attempt=%u + ntdma = %d)\012"
 1559      5F6F6666 
 1559      7365743D 
 1559      25642028 
 1559      666E3D25 
 1560 015d 00       		.ascii	"\000"
 1561              	.LC10:
 1562 015e 20206465 		.ascii	"  delay=%d (fn_offset=%d + 11 - fn=%lu - 1\012\000"
 1562      6C61793D 
 1562      25642028 
 1562      666E5F6F 
 1562      66667365 
 1563              	.LC11:
 1564 018a 20207363 		.ascii	"  scheduling next FB/SB detection task with delay %"
 1564      68656475 
 1564      6C696E67 
 1564      206E6578 
 1564      74204642 
 1565 01bd 750A00   		.ascii	"u\012\000"
 1566              		.bss
 1567              		.align	2
 1568              		.set	.LANCHOR0,. + 0
 1571              	fbs:
 1572 0000 00000000 		.space	52
 1572      00000000 
 1572      00000000 
 1572      00000000 
 1572      00000000 
 1573              		.text
 1574              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_fbsb.c
     /tmp/ccyfpol7.s:12     .text.l1ctl_fbsb_resp:0000000000000000 $a
     /tmp/ccyfpol7.s:14     .text.l1ctl_fbsb_resp:0000000000000000 l1ctl_fbsb_resp
     /tmp/ccyfpol7.s:131    .text.l1ctl_fbsb_resp:00000000000000b8 $d
     /tmp/ccyfpol7.s:138    .text.l1s_sbdet_resp:0000000000000000 $a
     /tmp/ccyfpol7.s:140    .text.l1s_sbdet_resp:0000000000000000 l1s_sbdet_resp
     /tmp/ccyfpol7.s:491    .text.l1s_sbdet_resp:00000000000002f4 $d
     /tmp/ccyfpol7.s:509    .text.l1s_sbdet_cmd:0000000000000000 $a
     /tmp/ccyfpol7.s:511    .text.l1s_sbdet_cmd:0000000000000000 l1s_sbdet_cmd
     /tmp/ccyfpol7.s:556    .text.l1s_sbdet_cmd:0000000000000048 $d
     /tmp/ccyfpol7.s:563    .text.l1s_fbdet_cmd:0000000000000000 $a
     /tmp/ccyfpol7.s:565    .text.l1s_fbdet_cmd:0000000000000000 l1s_fbdet_cmd
     /tmp/ccyfpol7.s:620    .text.l1s_fbdet_cmd:0000000000000060 $d
     /tmp/ccyfpol7.s:628    .text.fbinfo2cellinfo.clone.0.clone.1:0000000000000000 $a
     /tmp/ccyfpol7.s:630    .text.fbinfo2cellinfo.clone.0.clone.1:0000000000000000 fbinfo2cellinfo.clone.0.clone.1
     /tmp/ccyfpol7.s:752    .text.fbinfo2cellinfo.clone.0.clone.1:00000000000000d0 $d
     /tmp/ccyfpol7.s:764    .text.l1s_fbdet_resp:0000000000000000 $a
     /tmp/ccyfpol7.s:766    .text.l1s_fbdet_resp:0000000000000000 l1s_fbdet_resp
     /tmp/ccyfpol7.s:1085   .text.l1s_fbdet_resp:00000000000002f4 $d
     /tmp/ccyfpol7.s:1102   .text.l1a_fb_compl:0000000000000000 $a
     /tmp/ccyfpol7.s:1104   .text.l1a_fb_compl:0000000000000000 l1a_fb_compl
     /tmp/ccyfpol7.s:1137   .text.l1a_fb_compl:0000000000000028 $d
     /tmp/ccyfpol7.s:1142   .text.l1s_sb_test:0000000000000000 $a
     /tmp/ccyfpol7.s:1145   .text.l1s_sb_test:0000000000000000 l1s_sb_test
     /tmp/ccyfpol7.s:1166   .text.l1s_sb_test:0000000000000010 $d
     /tmp/ccyfpol7.s:1171   .text.l1s_fbsb_req:0000000000000000 $a
     /tmp/ccyfpol7.s:1174   .text.l1s_fbsb_req:0000000000000000 l1s_fbsb_req
     /tmp/ccyfpol7.s:1308   .text.l1s_fbsb_req:00000000000000e8 $d
     /tmp/ccyfpol7.s:1315   .text.l1s_prim_fbsb_init:0000000000000000 $a
     /tmp/ccyfpol7.s:1317   .text.l1s_prim_fbsb_init:0000000000000000 l1s_prim_fbsb_init
     /tmp/ccyfpol7.s:1333   .text.l1s_prim_fbsb_init:0000000000000010 $d
     /tmp/ccyfpol7.s:1339   .ctors:0000000000000000 $d
     /tmp/ccyfpol7.s:1342   .rodata:0000000000000000 $d
     /tmp/ccyfpol7.s:1346   .rodata:0000000000000000 fb_sched_set
     /tmp/ccyfpol7.s:1487   .rodata:0000000000000150 sb_sched_set
     /tmp/ccyfpol7.s:1567   .bss:0000000000000000 $d
     /tmp/ccyfpol7.s:1571   .bss:0000000000000000 fbs
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
l1s_snr_int
l1_create_l2_msg
osmo_panic
l1_queue_for_l2
__udivsi3
printf
agc_inp_dbm8_by_pm
afc_input
memset
gsm_gsmtime2fn
l1s_time_dump
synchronize_tdma
gsm_fn2gsmtime
l1s_time_inc
tdma_sched_reset
l1s_dsp_abort
l1s_reset_hw
mframe_enable
l1s_compl_sched
dsp_api
l1s
rf_arfcn
l1s_rx_win_ctrl
rxlev2dbm
rffe_compute_gain
__divsi3
tdma_schedule_set
afc_correct
afc_reset
toa_reset
tdma_end_set
