   1              		.file	"prim_tch.c"
   9              	.Ltext0:
  10              		.cfi_sections	.debug_frame
  11              		.section	.text.l1s_tch_d_resp,"ax",%progbits
  12              		.align	2
  14              	l1s_tch_d_resp:
  15              	.LFB70:
  16              		.file 1 "layer1/prim_tch.c"
   1:layer1/prim_tch.c **** /* Layer 1 - TCH */
   2:layer1/prim_tch.c **** 
   3:layer1/prim_tch.c **** /* (C) 2010 by Dieter Spaar <spaar@mirider.augusta.de>
   4:layer1/prim_tch.c ****  * (C) 2010 by Sylvain Munaut <tnt@246tnt.com>
   5:layer1/prim_tch.c ****  *
   6:layer1/prim_tch.c ****  * All Rights Reserved
   7:layer1/prim_tch.c ****  *
   8:layer1/prim_tch.c ****  * This program is free software; you can redistribute it and/or modify
   9:layer1/prim_tch.c ****  * it under the terms of the GNU General Public License as published by
  10:layer1/prim_tch.c ****  * the Free Software Foundation; either version 2 of the License, or
  11:layer1/prim_tch.c ****  * (at your option) any later version.
  12:layer1/prim_tch.c ****  *
  13:layer1/prim_tch.c ****  * This program is distributed in the hope that it will be useful,
  14:layer1/prim_tch.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:layer1/prim_tch.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:layer1/prim_tch.c ****  * GNU General Public License for more details.
  17:layer1/prim_tch.c ****  *
  18:layer1/prim_tch.c ****  * You should have received a copy of the GNU General Public License along
  19:layer1/prim_tch.c ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  20:layer1/prim_tch.c ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  21:layer1/prim_tch.c ****  *
  22:layer1/prim_tch.c ****  */
  23:layer1/prim_tch.c **** 
  24:layer1/prim_tch.c **** #include <stdint.h>
  25:layer1/prim_tch.c **** #include <stdio.h>
  26:layer1/prim_tch.c **** #include <string.h>
  27:layer1/prim_tch.c **** #include <stdlib.h>
  28:layer1/prim_tch.c **** 
  29:layer1/prim_tch.c **** #include <defines.h>
  30:layer1/prim_tch.c **** #include <debug.h>
  31:layer1/prim_tch.c **** #include <memory.h>
  32:layer1/prim_tch.c **** #include <byteorder.h>
  33:layer1/prim_tch.c **** #include <osmocom/gsm/gsm_utils.h>
  34:layer1/prim_tch.c **** #include <osmocom/gsm/protocol/gsm_04_08.h>
  35:layer1/prim_tch.c **** #include <osmocom/core/msgb.h>
  36:layer1/prim_tch.c **** #include <calypso/dsp_api.h>
  37:layer1/prim_tch.c **** #include <calypso/irq.h>
  38:layer1/prim_tch.c **** #include <calypso/tpu.h>
  39:layer1/prim_tch.c **** #include <calypso/tsp.h>
  40:layer1/prim_tch.c **** #include <calypso/dsp.h>
  41:layer1/prim_tch.c **** #include <calypso/timer.h>
  42:layer1/prim_tch.c **** #include <comm/sercomm.h>
  43:layer1/prim_tch.c **** 
  44:layer1/prim_tch.c **** #include <rffe.h>
  45:layer1/prim_tch.c **** #include <layer1/sync.h>
  46:layer1/prim_tch.c **** #include <layer1/afc.h>
  47:layer1/prim_tch.c **** #include <layer1/agc.h>
  48:layer1/prim_tch.c **** #include <layer1/toa.h>
  49:layer1/prim_tch.c **** #include <layer1/tdma_sched.h>
  50:layer1/prim_tch.c **** #include <layer1/mframe_sched.h>
  51:layer1/prim_tch.c **** #include <layer1/tpu_window.h>
  52:layer1/prim_tch.c **** #include <layer1/l23_api.h>
  53:layer1/prim_tch.c **** #include <layer1/rfch.h>
  54:layer1/prim_tch.c **** #include <layer1/prim.h>
  55:layer1/prim_tch.c **** 
  56:layer1/prim_tch.c **** #include <l1ctl_proto.h>
  57:layer1/prim_tch.c **** 
  58:layer1/prim_tch.c **** 
  59:layer1/prim_tch.c **** /* This computes various parameters both for the DSP and for
  60:layer1/prim_tch.c ****  * our logic. Not all are used all the time, but it's easier
  61:layer1/prim_tch.c ****  * to build all in one place */
  62:layer1/prim_tch.c **** static void tch_get_params(struct gsm_time *time, uint8_t chan_nr,
  63:layer1/prim_tch.c ****                            uint32_t *fn_report, uint8_t *tch_f_hn,
  64:layer1/prim_tch.c ****                            uint8_t *tch_sub, uint8_t *tch_mode)
  65:layer1/prim_tch.c **** {
  66:layer1/prim_tch.c **** 	uint8_t tn = chan_nr & 0x07;
  67:layer1/prim_tch.c **** 	uint8_t cbits = chan_nr >> 3;
  68:layer1/prim_tch.c **** 
  69:layer1/prim_tch.c **** 	*tch_f_hn = (cbits & 2) ? 0 : 1;
  70:layer1/prim_tch.c **** 
  71:layer1/prim_tch.c **** 	if (*tch_f_hn) {
  72:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn * 13) + 104) % 104;
  73:layer1/prim_tch.c **** 		*tch_sub = 0;
  74:layer1/prim_tch.c **** 	} else {
  75:layer1/prim_tch.c **** 		uint8_t chan_sub = cbits & 1;
  76:layer1/prim_tch.c **** 		uint8_t tn_report = (tn & ~1) | chan_sub;
  77:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn_report * 13) + 104) % 104;
  78:layer1/prim_tch.c **** 		*tch_sub = chan_sub;
  79:layer1/prim_tch.c **** 	}
  80:layer1/prim_tch.c **** 
  81:layer1/prim_tch.c **** 	if (tch_mode) {
  82:layer1/prim_tch.c **** 		switch (l1s.tch_mode) {
  83:layer1/prim_tch.c **** 		case GSM48_CMODE_SPEECH_V1:
  84:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_FS_MODE : TCH_HS_MODE;
  85:layer1/prim_tch.c **** 			break;
  86:layer1/prim_tch.c **** 		case GSM48_CMODE_SPEECH_EFR:
  87:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_EFR_MODE : SIG_ONLY_MODE;
  88:layer1/prim_tch.c **** 			break;
  89:layer1/prim_tch.c **** 		default:
  90:layer1/prim_tch.c **** 			*tch_mode = SIG_ONLY_MODE;
  91:layer1/prim_tch.c **** 		}
  92:layer1/prim_tch.c **** 	}
  93:layer1/prim_tch.c **** }
  94:layer1/prim_tch.c **** 
  95:layer1/prim_tch.c **** 
  96:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
  97:layer1/prim_tch.c ****  * Shared completion handler
  98:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
  99:layer1/prim_tch.c **** 
 100:layer1/prim_tch.c **** /*
 101:layer1/prim_tch.c ****  * FIXME We really need a better way to handle completion, where we can
 102:layer1/prim_tch.c ****  *       pass arguments and such ...
 103:layer1/prim_tch.c ****  *
 104:layer1/prim_tch.c ****  *       Right now, we just 'hope' it gets processed before the next one ...
 105:layer1/prim_tch.c ****  */
 106:layer1/prim_tch.c **** 
 107:layer1/prim_tch.c **** #define TX_TYPE_SACCH	(1<<0)
 108:layer1/prim_tch.c **** #define TX_TYPE_FACCH	(1<<1)
 109:layer1/prim_tch.c **** #define TX_TYPE_TRAFFIC	(1<<2)
 110:layer1/prim_tch.c **** 
 111:layer1/prim_tch.c **** static uint16_t last_tx_tch_fn;
 112:layer1/prim_tch.c **** static uint16_t last_tx_tch_type;
 113:layer1/prim_tch.c **** 
 114:layer1/prim_tch.c **** static void l1a_tx_tch_compl(__unused enum l1_compl c)
 115:layer1/prim_tch.c **** {
 116:layer1/prim_tch.c **** 	struct msgb *msg;
 117:layer1/prim_tch.c **** 
 118:layer1/prim_tch.c **** 	if (last_tx_tch_type & (TX_TYPE_SACCH | TX_TYPE_FACCH)) {
 119:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_DATA_CONF, last_tx_tch_fn, 0, 0);
 120:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 121:layer1/prim_tch.c **** 	}
 122:layer1/prim_tch.c **** 
 123:layer1/prim_tch.c **** 	if (last_tx_tch_type & TX_TYPE_TRAFFIC) {
 124:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_TRAFFIC_CONF, last_tx_tch_fn, 0, 0);
 125:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 126:layer1/prim_tch.c **** 	}
 127:layer1/prim_tch.c **** 
 128:layer1/prim_tch.c **** 	last_tx_tch_type = 0;
 129:layer1/prim_tch.c **** }
 130:layer1/prim_tch.c **** 
 131:layer1/prim_tch.c **** static __attribute__ ((constructor)) void prim_tch_init(void)
 132:layer1/prim_tch.c **** {
 133:layer1/prim_tch.c **** 	l1s.completion[L1_COMPL_TX_TCH]  = &l1a_tx_tch_compl;
 134:layer1/prim_tch.c **** }
 135:layer1/prim_tch.c **** 
 136:layer1/prim_tch.c **** 
 137:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 138:layer1/prim_tch.c ****  * TCH: Voice & FACCH
 139:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 140:layer1/prim_tch.c **** 
 141:layer1/prim_tch.c **** /*
 142:layer1/prim_tch.c ****  * Voice and FACCH data are spread in various ways depending on a lot of
 143:layer1/prim_tch.c ****  * factors. Trying to handle that with the mframe scheduler is just a mess,
 144:layer1/prim_tch.c ****  * so we schedule it burst by burst and handle the complex logic inside the
 145:layer1/prim_tch.c ****  * primitive task code itself.
 146:layer1/prim_tch.c ****  */
 147:layer1/prim_tch.c **** 
 148:layer1/prim_tch.c **** 
 149:layer1/prim_tch.c **** #define FACCH_MEAS_HIST	8	/* Up to 8 bursts history */
 150:layer1/prim_tch.c **** struct l1s_rx_tch_state {
 151:layer1/prim_tch.c **** 	struct l1s_meas_hdr meas[FACCH_MEAS_HIST];
 152:layer1/prim_tch.c **** };
 153:layer1/prim_tch.c **** 
 154:layer1/prim_tch.c **** static struct l1s_rx_tch_state rx_tch;
 155:layer1/prim_tch.c **** 
 156:layer1/prim_tch.c **** 
 157:layer1/prim_tch.c **** static int l1s_tch_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 158:layer1/prim_tch.c **** {
 159:layer1/prim_tch.c **** 	static uint8_t meas_id = 0;
 160:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 161:layer1/prim_tch.c **** 	struct gsm_time rx_time;
 162:layer1/prim_tch.c **** 	uint8_t chan_nr;
 163:layer1/prim_tch.c **** 	uint16_t arfcn;
 164:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 165:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub;
 166:layer1/prim_tch.c **** 	uint32_t fn_report;
 167:layer1/prim_tch.c **** 	int facch_rx_now, traffic_rx_now;
 168:layer1/prim_tch.c **** 
 169:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 170:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 171:layer1/prim_tch.c **** 	rfch_get_params(&rx_time, &arfcn, &tsc, &tn);
 172:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 173:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 174:layer1/prim_tch.c **** 
 175:layer1/prim_tch.c **** 	meas_id = (meas_id + 1) % FACCH_MEAS_HIST; /* absolute value doesn't matter */
 176:layer1/prim_tch.c **** 
 177:layer1/prim_tch.c **** 	/* Collect measurements */
 178:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 179:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].pm_dbm8 =
 180:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 181:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].freq_err =
 182:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 183:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 184:layer1/prim_tch.c **** 
 185:layer1/prim_tch.c **** 	/* feed computed frequency error into AFC loop */
 186:layer1/prim_tch.c **** 	if (rx_tch.meas[meas_id].snr > AFC_SNR_THRESHOLD)
 187:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 1);
 188:layer1/prim_tch.c **** 	else
 189:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 0);
 190:layer1/prim_tch.c **** 
 191:layer1/prim_tch.c **** 	/* feed computed TOA into TA loop */
 192:layer1/prim_tch.c **** 	toa_input(rx_tch.meas[meas_id].toa_qbit << 2, rx_tch.meas[meas_id].snr);
 193:layer1/prim_tch.c **** 
 194:layer1/prim_tch.c **** 	/* Tell the RF frontend to set the gain appropriately */
 195:layer1/prim_tch.c **** 	rffe_compute_gain(rx_tch.meas[meas_id].pm_dbm8 / 8,
 196:layer1/prim_tch.c **** 		CAL_DSP_TGT_BB_LVL);
 197:layer1/prim_tch.c **** 
 198:layer1/prim_tch.c **** 	/* FACCH Block end ? */
 199:layer1/prim_tch.c **** 	if (tch_f_hn) {
 200:layer1/prim_tch.c **** 		/* FACCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13) */
 201:layer1/prim_tch.c **** 		facch_rx_now = ((rx_time.fn % 13) % 4) == 3;
 202:layer1/prim_tch.c **** 	} else {
 203:layer1/prim_tch.c **** 		/* FAACH/H: See GSM 05.02 Clause 7 Table 1of9 */
 204:layer1/prim_tch.c **** 		uint8_t t2_norm = rx_time.t2 - tch_sub;
 205:layer1/prim_tch.c **** 		facch_rx_now = (t2_norm == 15) ||
 206:layer1/prim_tch.c **** 		               (t2_norm == 23) ||
 207:layer1/prim_tch.c **** 		               (t2_norm ==  6);
 208:layer1/prim_tch.c **** 	}
 209:layer1/prim_tch.c **** 
 210:layer1/prim_tch.c **** 	if (facch_rx_now && (dsp_api.ndb->a_fd[0] & (1<<B_BLUD))) {
 211:layer1/prim_tch.c **** 		struct msgb *msg;
 212:layer1/prim_tch.c **** 		struct l1ctl_info_dl *dl;
 213:layer1/prim_tch.c **** 		struct l1ctl_data_ind *di;
 214:layer1/prim_tch.c **** 		uint16_t num_biterr;
 215:layer1/prim_tch.c **** 		uint32_t avg_snr = 0;
 216:layer1/prim_tch.c **** 		int32_t avg_dbm8 = 0;
 217:layer1/prim_tch.c **** 		int i, n;
 218:layer1/prim_tch.c **** 
 219:layer1/prim_tch.c **** 		/* Allocate msgb */
 220:layer1/prim_tch.c **** 			/* FIXME: we actually want all allocation out of L1S! */
 221:layer1/prim_tch.c **** 		msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 222:layer1/prim_tch.c **** 		if(!msg) {
 223:layer1/prim_tch.c **** 			printf("TCH FACCH: unable to allocate msgb\n");
 224:layer1/prim_tch.c **** 			goto skip_rx_facch;
 225:layer1/prim_tch.c **** 		}
 226:layer1/prim_tch.c **** 
 227:layer1/prim_tch.c **** 		dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 228:layer1/prim_tch.c **** 		di = (struct l1ctl_data_ind *) msgb_put(msg, sizeof(*di));
 229:layer1/prim_tch.c **** 
 230:layer1/prim_tch.c **** 		/* Fill DL header (should be about the first burst ... here is the last) */
 231:layer1/prim_tch.c **** 		dl->chan_nr = chan_nr;
 232:layer1/prim_tch.c **** 		dl->link_id = 0x00;	/* FACCH */
 233:layer1/prim_tch.c **** 		dl->band_arfcn = htons(arfcn);
 234:layer1/prim_tch.c **** 		dl->frame_nr = htonl(rx_time.fn);
 235:layer1/prim_tch.c **** 
 236:layer1/prim_tch.c **** 		/* Average SNR & RX level */
 237:layer1/prim_tch.c **** 		n = tch_f_hn ? 8 : 6;
 238:layer1/prim_tch.c **** 		for (i=0; i<n; i++) {
 239:layer1/prim_tch.c **** 			int j = (meas_id + FACCH_MEAS_HIST - i) % FACCH_MEAS_HIST;
 240:layer1/prim_tch.c **** 			avg_snr += rx_tch.meas[j].snr;
 241:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch.meas[j].pm_dbm8;
 242:layer1/prim_tch.c **** 		}
 243:layer1/prim_tch.c **** 
 244:layer1/prim_tch.c **** 		dl->snr = avg_snr / n;
 245:layer1/prim_tch.c **** 		dl->rx_level = dbm2rxlev(avg_dbm8 / (8*n));
 246:layer1/prim_tch.c **** 
 247:layer1/prim_tch.c **** 		/* Errors & CRC status */
 248:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_fd[2] & 0xffff;
 249:layer1/prim_tch.c **** 		if (num_biterr > 0xff)
 250:layer1/prim_tch.c **** 			dl->num_biterr = 0xff;
 251:layer1/prim_tch.c **** 		else
 252:layer1/prim_tch.c **** 			dl->num_biterr = num_biterr;
 253:layer1/prim_tch.c **** 
 254:layer1/prim_tch.c **** 		dl->fire_crc = ((dsp_api.ndb->a_fd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> B_FIRE0;
 255:layer1/prim_tch.c **** 
 256:layer1/prim_tch.c **** 		/* Update rx level for pm report */
 257:layer1/prim_tch.c **** 		pu_update_rx_level(dl->rx_level);
 258:layer1/prim_tch.c **** 
 259:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 260:layer1/prim_tch.c **** 		dsp_memcpy_from_api(di->data, &dsp_api.ndb->a_fd[3], 23, 0);
 261:layer1/prim_tch.c **** 
 262:layer1/prim_tch.c **** 		/* Give message to up layer */
 263:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 264:layer1/prim_tch.c **** 
 265:layer1/prim_tch.c **** 	skip_rx_facch:
 266:layer1/prim_tch.c **** 		/* Reset A_FD header (needed by DSP) */
 267:layer1/prim_tch.c **** 		/* B_FIRE1 =1, B_FIRE0 =0 , BLUD =0 */
 268:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[0] = (1<<B_FIRE1);
 269:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[2] = 0xffff;
 270:layer1/prim_tch.c **** 
 271:layer1/prim_tch.c **** 		/* Reset A_DD_0 header in NDB (needed by DSP) */
 272:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[0] = 0;
 273:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[2] = 0xffff;
 274:layer1/prim_tch.c **** 
 275:layer1/prim_tch.c **** 		/* Reset A_DD_1 header in NDB (needed by DSP) */
 276:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[0] = 0;
 277:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[2] = 0xffff;
 278:layer1/prim_tch.c **** 	}
 279:layer1/prim_tch.c **** 
 280:layer1/prim_tch.c **** 	/* Traffic now ? */
 281:layer1/prim_tch.c **** 	if (tch_f_hn) {
 282:layer1/prim_tch.c **** 		/* TCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13)*/
 283:layer1/prim_tch.c **** 		traffic_rx_now = ((rx_time.fn % 13) % 4) == 3;
 284:layer1/prim_tch.c **** 	} else {
 285:layer1/prim_tch.c **** 		/* TCH/H0: B0(0,2,4,6),B1(4,6,8,10),B2(8,10,0,2) (mod 13) */
 286:layer1/prim_tch.c **** 		/*     H1: B0(1,3,5,7),B1(5,7,9,11),B2(9,11,1,3) (mod 13) */
 287:layer1/prim_tch.c **** 		traffic_rx_now = (((rx_time.fn - tch_sub + 13) % 13) % 4) == 2;
 288:layer1/prim_tch.c **** 	}
 289:layer1/prim_tch.c **** 
 290:layer1/prim_tch.c **** 	if (traffic_rx_now) {
 291:layer1/prim_tch.c **** 		volatile uint16_t *traffic_buf;
 292:layer1/prim_tch.c **** 
 293:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_dd_1 : dsp_api.ndb->a_dd_0;
 294:layer1/prim_tch.c **** 
 295:layer1/prim_tch.c **** 		if (traffic_buf[0] & (1<<B_BLUD)) {
 296:layer1/prim_tch.c **** 			/* Send the data to upper layers (if interested and good frame) */
 297:layer1/prim_tch.c **** 			if ((l1s.audio_mode & AUDIO_RX_TRAFFIC_IND) &&
 298:layer1/prim_tch.c **** 			    !(dsp_api.ndb->a_dd_0[0] & (1<<B_BFI))) {
 299:layer1/prim_tch.c **** 				struct msgb *msg;
 300:layer1/prim_tch.c **** 				struct l1ctl_info_dl *dl;
 301:layer1/prim_tch.c **** 				struct l1ctl_traffic_ind *ti;
 302:layer1/prim_tch.c **** 
 303:layer1/prim_tch.c **** 				/* Allocate msgb */
 304:layer1/prim_tch.c **** 				/* FIXME: we actually want all allocation out of L1S! */
 305:layer1/prim_tch.c **** 				msg = l1ctl_msgb_alloc(L1CTL_TRAFFIC_IND);
 306:layer1/prim_tch.c **** 				if(!msg) {
 307:layer1/prim_tch.c **** 					printf("TCH traffic: unable to allocate msgb\n");
 308:layer1/prim_tch.c **** 					goto skip_rx_traffic;
 309:layer1/prim_tch.c **** 				}
 310:layer1/prim_tch.c **** 
 311:layer1/prim_tch.c **** 				dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 312:layer1/prim_tch.c **** 				ti = (struct l1ctl_traffic_ind *) msgb_put(msg, sizeof(*ti));
 313:layer1/prim_tch.c **** 
 314:layer1/prim_tch.c **** 				/* Copy actual data, skipping the information block [0,1,2] */
 315:layer1/prim_tch.c **** 				dsp_memcpy_from_api(ti->data, &traffic_buf[3], 33, 1);
 316:layer1/prim_tch.c **** 
 317:layer1/prim_tch.c **** 				/* Give message to up layer */
 318:layer1/prim_tch.c **** 				l1_queue_for_l2(msg);
 319:layer1/prim_tch.c **** 			}
 320:layer1/prim_tch.c **** 
 321:layer1/prim_tch.c **** 	skip_rx_traffic:
 322:layer1/prim_tch.c **** 			/* Reset traffic buffer header in NDB (needed by DSP) */
 323:layer1/prim_tch.c **** 			traffic_buf[0] = 0;
 324:layer1/prim_tch.c **** 			traffic_buf[2] = 0xffff;
 325:layer1/prim_tch.c **** 		}
 326:layer1/prim_tch.c **** 	}
 327:layer1/prim_tch.c **** 
 328:layer1/prim_tch.c **** 	/* mark READ page as being used */
 329:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 330:layer1/prim_tch.c **** 
 331:layer1/prim_tch.c **** 	return 0;
 332:layer1/prim_tch.c **** }
 333:layer1/prim_tch.c **** 
 334:layer1/prim_tch.c **** static int l1s_tch_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 335:layer1/prim_tch.c **** {
 336:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 337:layer1/prim_tch.c **** 	uint8_t chan_nr;
 338:layer1/prim_tch.c **** 	uint16_t arfcn;
 339:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 340:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 341:layer1/prim_tch.c **** 	uint32_t fn_report;
 342:layer1/prim_tch.c **** 	uint8_t sync = 0;
 343:layer1/prim_tch.c **** 	static int icnt;
 344:layer1/prim_tch.c **** 	int facch_tx_now, traffic_tx_now;
 345:layer1/prim_tch.c **** 
 346:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 347:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 348:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 349:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 350:layer1/prim_tch.c **** 
 351:layer1/prim_tch.c **** 	/* Sync & FACCH delay */
 352:layer1/prim_tch.c **** 	if (l1s.tch_sync) {
 353:layer1/prim_tch.c **** 		l1s.tch_sync = 0;
 354:layer1/prim_tch.c **** 		sync = 1;
 355:layer1/prim_tch.c **** 		icnt = 0;
 356:layer1/prim_tch.c **** 	} else if (icnt <= 26)
 357:layer1/prim_tch.c **** 		icnt++;
 358:layer1/prim_tch.c **** 
 359:layer1/prim_tch.c **** 	/* Load FACCH data if we start a new burst */
 360:layer1/prim_tch.c **** 	/* (the DSP wants the data on the CMD of the burst _preceding_ the
 361:layer1/prim_tch.c **** 	 * first burst) */
 362:layer1/prim_tch.c **** 	if (tch_f_hn) {
 363:layer1/prim_tch.c **** 		/* FACCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) */
 364:layer1/prim_tch.c **** 		facch_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 365:layer1/prim_tch.c **** 	} else {
 366:layer1/prim_tch.c **** 		/* FAACH/H: See GSM 05.02 Clause 7 Table 1of9 */
 367:layer1/prim_tch.c **** 		uint8_t t2_norm = l1s.next_time.t2 - tch_sub;
 368:layer1/prim_tch.c **** 		facch_tx_now = (t2_norm == 23) ||
 369:layer1/prim_tch.c **** 		               (t2_norm ==  6) ||
 370:layer1/prim_tch.c **** 		               (t2_norm == 15);
 371:layer1/prim_tch.c **** 	}
 372:layer1/prim_tch.c **** 
 373:layer1/prim_tch.c **** 	if (facch_tx_now) {
 374:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_fu;
 375:layer1/prim_tch.c **** 		struct msgb *msg;
 376:layer1/prim_tch.c **** 		const uint8_t *data;
 377:layer1/prim_tch.c **** 
 378:layer1/prim_tch.c **** 		/* Pull FACCH data (if ready) */
 379:layer1/prim_tch.c **** 		if (icnt > 26)
 380:layer1/prim_tch.c **** 			msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_MAIN]);
 381:layer1/prim_tch.c **** 		else
 382:layer1/prim_tch.c **** 			msg = NULL;
 383:layer1/prim_tch.c **** 
 384:layer1/prim_tch.c **** 		/* If TX is empty and we're signalling only, use dummy frame */
 385:layer1/prim_tch.c **** 		if (msg)
 386:layer1/prim_tch.c **** 			data = msg->l3h;
 387:layer1/prim_tch.c **** 		else if (tch_mode == SIG_ONLY_MODE)
 388:layer1/prim_tch.c **** 			data = pu_get_idle_frame();
 389:layer1/prim_tch.c **** 		else
 390:layer1/prim_tch.c **** 			data = NULL;
 391:layer1/prim_tch.c **** 
 392:layer1/prim_tch.c **** 		/* Do we really send something ? */
 393:layer1/prim_tch.c **** 		if (data) {
 394:layer1/prim_tch.c **** 			/* Fill data block header */
 395:layer1/prim_tch.c **** 			info_ptr[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 396:layer1/prim_tch.c **** 			info_ptr[1] = 0;		/* 2nd word: cleared. */
 397:layer1/prim_tch.c **** 			info_ptr[2] = 0;		/* 3nd word: cleared. */
 398:layer1/prim_tch.c **** 
 399:layer1/prim_tch.c **** 			/* Copy the actual data after the header */
 400:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&info_ptr[3], data, 23, 0);
 401:layer1/prim_tch.c **** 		}
 402:layer1/prim_tch.c **** 
 403:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 404:layer1/prim_tch.c **** 		if (msg) {
 405:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 406:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_FACCH;
 407:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 408:layer1/prim_tch.c **** 		}
 409:layer1/prim_tch.c **** 
 410:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 411:layer1/prim_tch.c **** 		if (msg)
 412:layer1/prim_tch.c **** 			msgb_free(msg);
 413:layer1/prim_tch.c **** 	}
 414:layer1/prim_tch.c **** 
 415:layer1/prim_tch.c **** 	/* Traffic now ? */
 416:layer1/prim_tch.c **** 	if (tch_f_hn) {
 417:layer1/prim_tch.c **** 		/* TCH/F: B0(0...7),B1(4...11),B2(8...11,0...3) (mod 13)*/
 418:layer1/prim_tch.c **** 		traffic_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 419:layer1/prim_tch.c **** 	} else {
 420:layer1/prim_tch.c **** 		/* TCH/H0: B0(0,2,4,6),B1(4,6,8,10),B2(8,10,0,2) (mod 13) */
 421:layer1/prim_tch.c **** 		/*     H1: B0(1,3,5,7),B1(5,7,9,11),B2(9,11,1,3) (mod 13) */
 422:layer1/prim_tch.c **** 		traffic_tx_now = (((l1s.next_time.fn - tch_sub + 13) % 13) % 4) == 2;
 423:layer1/prim_tch.c **** 	}
 424:layer1/prim_tch.c **** 
 425:layer1/prim_tch.c **** 	if (traffic_tx_now) {
 426:layer1/prim_tch.c **** 		volatile uint16_t *traffic_buf;
 427:layer1/prim_tch.c **** 		struct msgb *msg;
 428:layer1/prim_tch.c **** 		const uint8_t *data;
 429:layer1/prim_tch.c **** 
 430:layer1/prim_tch.c **** 		/* Reset play mode */
 431:layer1/prim_tch.c **** 		dsp_api.ndb->d_tch_mode &= ~B_PLAY_UL;
 432:layer1/prim_tch.c **** 
 433:layer1/prim_tch.c **** 		/* Check l1s audio mode */
 434:layer1/prim_tch.c **** 		if (!(l1s.audio_mode & AUDIO_TX_TRAFFIC_REQ))
 435:layer1/prim_tch.c **** 			goto skip_tx_traffic;
 436:layer1/prim_tch.c **** 
 437:layer1/prim_tch.c **** 		/* Traffic buffer = !tch_sub */
 438:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_du_0 : dsp_api.ndb->a_du_1;
 439:layer1/prim_tch.c **** 
 440:layer1/prim_tch.c **** 		/* Pull Traffic data (if any) */
 441:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 442:layer1/prim_tch.c **** 
 443:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 444:layer1/prim_tch.c **** 		if (msg) {
 445:layer1/prim_tch.c **** 			data = msg->l2h;
 446:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&traffic_buf[3], data, 33, 1);
 447:layer1/prim_tch.c **** 
 448:layer1/prim_tch.c **** 			traffic_buf[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 449:layer1/prim_tch.c **** 			traffic_buf[1] = 0;		/* 2nd word: cleared. */
 450:layer1/prim_tch.c **** 			traffic_buf[2] = 0;		/* 3nd word: cleared. */
 451:layer1/prim_tch.c **** 		}
 452:layer1/prim_tch.c **** 
 453:layer1/prim_tch.c **** 		if (msg)
 454:layer1/prim_tch.c **** 			dsp_api.ndb->d_tch_mode |= B_PLAY_UL;
 455:layer1/prim_tch.c **** 
 456:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 457:layer1/prim_tch.c **** 		if (msg) {
 458:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 459:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_TRAFFIC;
 460:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 461:layer1/prim_tch.c **** 		}
 462:layer1/prim_tch.c **** 
 463:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 464:layer1/prim_tch.c **** 		if (msg)
 465:layer1/prim_tch.c **** 			msgb_free(msg);
 466:layer1/prim_tch.c **** 	}
 467:layer1/prim_tch.c **** skip_tx_traffic:
 468:layer1/prim_tch.c **** 
 469:layer1/prim_tch.c **** 	/* Configure DSP for TX/RX */
 470:layer1/prim_tch.c **** 	l1s_tx_apc_helper(arfcn);
 471:layer1/prim_tch.c **** 
 472:layer1/prim_tch.c **** 	dsp_load_tch_param(
 473:layer1/prim_tch.c **** 		&l1s.next_time,
 474:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 475:layer1/prim_tch.c **** 		0, sync, tn
 476:layer1/prim_tch.c **** 	);
 477:layer1/prim_tch.c **** 
 478:layer1/prim_tch.c **** 	dsp_load_rx_task(
 479:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 0),
 480:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCH */
 481:layer1/prim_tch.c **** 	);
 482:layer1/prim_tch.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 483:layer1/prim_tch.c **** 
 484:layer1/prim_tch.c **** 	dsp_load_tx_task(
 485:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 1),
 486:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCH */
 487:layer1/prim_tch.c **** 	);
 488:layer1/prim_tch.c **** 	l1s_tx_win_ctrl(arfcn | ARFCN_UPLINK, L1_TXWIN_NB, 0, 3);
 489:layer1/prim_tch.c **** 
 490:layer1/prim_tch.c **** 	return 0;
 491:layer1/prim_tch.c **** }
 492:layer1/prim_tch.c **** 
 493:layer1/prim_tch.c **** 
 494:layer1/prim_tch.c **** const struct tdma_sched_item tch_sched_set[] = {
 495:layer1/prim_tch.c **** 	SCHED_ITEM_DT(l1s_tch_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 496:layer1/prim_tch.c **** 						SCHED_END_FRAME(),
 497:layer1/prim_tch.c **** 	SCHED_ITEM(l1s_tch_resp, 0, 0, -4),	SCHED_END_FRAME(),
 498:layer1/prim_tch.c **** 	SCHED_END_SET()
 499:layer1/prim_tch.c **** };
 500:layer1/prim_tch.c **** 
 501:layer1/prim_tch.c **** 
 502:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 503:layer1/prim_tch.c ****  * TCH/H: Dummy
 504:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 505:layer1/prim_tch.c **** 
 506:layer1/prim_tch.c **** /* This task is needed to perform some operation in the DSP when there is
 507:layer1/prim_tch.c ****  * no data to be exchanged */
 508:layer1/prim_tch.c **** 
 509:layer1/prim_tch.c **** static int l1s_tch_d_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 510:layer1/prim_tch.c **** {
  17              		.loc 1 510 0
  18              		.cfi_startproc
  19              		@ args = 0, pretend = 0, frame = 0
  20              		@ frame_needed = 0, uses_anonymous_args = 0
  21              		@ link register save eliminated.
  22              	.LVL0:
 511:layer1/prim_tch.c **** 	/* mark READ page as being used */
 512:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
  23              		.loc 1 512 0
  24 0000 0C309FE5 		ldr	r3, .L2
  25 0004 0120A0E3 		mov	r2, #1
  26              	.LVL1:
  27 0008 182083E5 		str	r2, [r3, #24]
 513:layer1/prim_tch.c **** 
 514:layer1/prim_tch.c **** 	return 0;
 515:layer1/prim_tch.c **** }
  28              		.loc 1 515 0
  29 000c 0000A0E3 		mov	r0, #0
  30              	.LVL2:
  31 0010 1EFF2FE1 		bx	lr
  32              	.L3:
  33              		.align	2
  34              	.L2:
  35 0014 00000000 		.word	dsp_api
  36              		.cfi_endproc
  37              	.LFE70:
  39              		.section	.text.__fswab32,"ax",%progbits
  40              		.align	2
  42              	__fswab32:
  43              	.LFB2:
  44              		.file 2 "include/swab.h"
   1:include/swab.h **** #ifndef _LINUX_SWAB_H
   2:include/swab.h **** #define _LINUX_SWAB_H
   3:include/swab.h **** 
   4:include/swab.h **** #include <stdint.h>
   5:include/swab.h **** #include <defines.h>
   6:include/swab.h **** #include <asm/swab.h>
   7:include/swab.h **** 
   8:include/swab.h **** /*
   9:include/swab.h ****  * casts are necessary for constants, because we never know how for sure
  10:include/swab.h ****  * how U/UL/ULL map to uint16_t, uint32_t, uint64_t. At least not in a portable way.
  11:include/swab.h ****  */
  12:include/swab.h **** #define ___constant_swab16(x) ((uint16_t)(				\
  13:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0x00ffU) << 8) |			\
  14:include/swab.h **** 	(((uint16_t)(x) & (uint16_t)0xff00U) >> 8)))
  15:include/swab.h **** 
  16:include/swab.h **** #define ___constant_swab32(x) ((uint32_t)(				\
  17:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x000000ffUL) << 24) |		\
  18:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ff00UL) <<  8) |		\
  19:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff0000UL) >>  8) |		\
  20:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff000000UL) >> 24)))
  21:include/swab.h **** 
  22:include/swab.h **** #define ___constant_swab64(x) ((uint64_t)(				\
  23:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000000000ffULL) << 56) |	\
  24:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000000000ff00ULL) << 40) |	\
  25:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000000000ff0000ULL) << 24) |	\
  26:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00000000ff000000ULL) <<  8) |	\
  27:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x000000ff00000000ULL) >>  8) |	\
  28:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x0000ff0000000000ULL) >> 24) |	\
  29:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0x00ff000000000000ULL) >> 40) |	\
  30:include/swab.h **** 	(((uint64_t)(x) & (uint64_t)0xff00000000000000ULL) >> 56)))
  31:include/swab.h **** 
  32:include/swab.h **** #define ___constant_swahw32(x) ((uint32_t)(			\
  33:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x0000ffffUL) << 16) |		\
  34:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xffff0000UL) >> 16)))
  35:include/swab.h **** 
  36:include/swab.h **** #define ___constant_swahb32(x) ((uint32_t)(			\
  37:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0x00ff00ffUL) << 8) |		\
  38:include/swab.h **** 	(((uint32_t)(x) & (uint32_t)0xff00ff00UL) >> 8)))
  39:include/swab.h **** 
  40:include/swab.h **** /*
  41:include/swab.h ****  * Implement the following as inlines, but define the interface using
  42:include/swab.h ****  * macros to allow constant folding when possible:
  43:include/swab.h ****  * ___swab16, ___swab32, ___swab64, ___swahw32, ___swahb32
  44:include/swab.h ****  */
  45:include/swab.h **** 
  46:include/swab.h **** static inline __attribute_const__ uint16_t __fswab16(uint16_t val)
  47:include/swab.h **** {
  48:include/swab.h **** #ifdef __arch_swab16
  49:include/swab.h **** 	return __arch_swab16(val);
  50:include/swab.h **** #else
  51:include/swab.h **** 	return ___constant_swab16(val);
  52:include/swab.h **** #endif
  53:include/swab.h **** }
  54:include/swab.h **** 
  55:include/swab.h **** static inline __attribute_const__ uint32_t __fswab32(uint32_t val)
  56:include/swab.h **** {
  45              		.loc 2 56 0
  46              		.cfi_startproc
  47              		@ args = 0, pretend = 0, frame = 0
  48              		@ frame_needed = 0, uses_anonymous_args = 0
  49              		@ link register save eliminated.
  50              	.LVL3:
  51              	.LBB20:
  52              	.LBB21:
  53              		.file 3 "include/asm/swab.h"
   1:include/asm/swab.h **** /*
   2:include/asm/swab.h ****  *  arch/arm/include/asm/byteorder.h
   3:include/asm/swab.h ****  *
   4:include/asm/swab.h ****  * ARM Endian-ness.  In little endian mode, the data bus is connected such
   5:include/asm/swab.h ****  * that byte accesses appear as:
   6:include/asm/swab.h ****  *  0 = d0...d7, 1 = d8...d15, 2 = d16...d23, 3 = d24...d31
   7:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
   8:include/asm/swab.h ****  *  d0...d31
   9:include/asm/swab.h ****  *
  10:include/asm/swab.h ****  * When in big endian mode, byte accesses appear as:
  11:include/asm/swab.h ****  *  0 = d24...d31, 1 = d16...d23, 2 = d8...d15, 3 = d0...d7
  12:include/asm/swab.h ****  * and word accesses (data or instruction) appear as:
  13:include/asm/swab.h ****  *  d0...d31
  14:include/asm/swab.h ****  */
  15:include/asm/swab.h **** #ifndef __ASM_ARM_SWAB_H
  16:include/asm/swab.h **** #define __ASM_ARM_SWAB_H
  17:include/asm/swab.h **** 
  18:include/asm/swab.h **** #include <stdint.h>
  19:include/asm/swab.h **** #include <defines.h>
  20:include/asm/swab.h **** 
  21:include/asm/swab.h **** static inline uint32_t __arch_swab32(uint32_t x)
  22:include/asm/swab.h **** {
  23:include/asm/swab.h **** 	uint32_t t;
  24:include/asm/swab.h **** 
  25:include/asm/swab.h **** #ifndef __thumb__
  26:include/asm/swab.h **** 	if (!__builtin_constant_p(x)) {
  27:include/asm/swab.h **** 		/*
  28:include/asm/swab.h **** 		 * The compiler needs a bit of a hint here to always do the
  29:include/asm/swab.h **** 		 * right thing and not screw it up to different degrees
  30:include/asm/swab.h **** 		 * depending on the gcc version.
  31:include/asm/swab.h **** 		 */
  32:include/asm/swab.h **** 		asm ("eor\t%0, %1, %1, ror #16" : "=r" (t) : "r" (x));
  54              		.loc 3 32 0
  55              	@ 32 "include/asm/swab.h" 1
  56 0000 603820E0 		eor	r3, r0, r0, ror #16
  57              	@ 0 "" 2
  58              	.LVL4:
  33:include/asm/swab.h **** 	} else
  34:include/asm/swab.h **** #endif
  35:include/asm/swab.h **** 		t = x ^ ((x << 16) | (x >> 16)); /* eor r1,r0,r0,ror #16 */
  36:include/asm/swab.h **** 
  37:include/asm/swab.h **** 	x = (x << 24) | (x >> 8);		/* mov r0,r0,ror #8      */
  38:include/asm/swab.h **** 	t &= ~0x00FF0000;			/* bic r1,r1,#0x00FF0000 */
  59              		.loc 3 38 0
  60 0004 FF38C3E3 		bic	r3, r3, #16711680
  61              	.LVL5:
  39:include/asm/swab.h **** 	x ^= (t >> 8);				/* eor r0,r0,r1,lsr #8   */
  62              		.loc 3 39 0
  63 0008 2334A0E1 		mov	r3, r3, lsr #8
  64              	.LVL6:
  65              	.LBE21:
  66              	.LBE20:
  57:include/swab.h **** #ifdef __arch_swab32
  58:include/swab.h **** 	return __arch_swab32(val);
  59:include/swab.h **** #else
  60:include/swab.h **** 	return ___constant_swab32(val);
  61:include/swab.h **** #endif
  62:include/swab.h **** }
  67              		.loc 2 62 0
  68 000c 600423E0 		eor	r0, r3, r0, ror #8
  69              	.LVL7:
  70 0010 1EFF2FE1 		bx	lr
  71              		.cfi_endproc
  72              	.LFE2:
  74              		.section	.text.msgb_put,"ax",%progbits
  75              		.align	2
  77              	msgb_put:
  78              	.LFB38:
  79              		.file 4 "../../shared/libosmocore/include/osmocom/core/msgb.h"
   1:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifndef _MSGB_H
   2:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define _MSGB_H
   3:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
   4:../../shared/libosmocore/include/osmocom/core/msgb.h **** /* (C) 2008 by Harald Welte <laforge@gnumonks.org>
   5:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * All Rights Reserved
   6:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
   7:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is free software; you can redistribute it and/or modify
   8:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * it under the terms of the GNU General Public License as published by
   9:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the Free Software Foundation; either version 2 of the License, or
  10:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * (at your option) any later version.
  11:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  12:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This program is distributed in the hope that it will be useful,
  13:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  14:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * GNU General Public License for more details.
  16:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  17:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * You should have received a copy of the GNU General Public License along
  18:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * with this program; if not, write to the Free Software Foundation, Inc.,
  19:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
  20:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  21:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  22:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  23:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <stdint.h>
  24:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/linuxlist.h>
  25:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/utils.h>
  26:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  27:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \defgroup msgb Message buffers
  28:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  @{
  29:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  30:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  31:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \file msgb.h
  32:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \brief Osmocom message buffers
  33:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The Osmocom message buffers are modelled after the 'struct skb'
  34:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * inside the Linux kernel network stack.  As they exist in userspace,
  35:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * they are much simplified.  However, terminology such as headroom,
  36:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * tailroom, push/pull/put etc. remains the same.
  37:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
  38:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  39:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_DEBUG
  40:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  41:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief Osmocom message buffer */
  42:../../shared/libosmocore/include/osmocom/core/msgb.h **** struct msgb {
  43:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct llist_head list; /*!< \brief linked list header */
  44:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  45:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  46:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* Part of which TRX logical channel we were received / transmitted */
  47:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	/* FIXME: move them into the control buffer */
  48:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	union {
  49:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		void *dst; /*!< \brief reference of origin/destination */
  50:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		struct gsm_bts_trx *trx;
  51:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	};
  52:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	struct gsm_lchan *lchan; /*!< \brief logical channel */
  53:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  54:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l1h; /*!< \brief pointer to Layer1 header (if any) */
  55:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l2h; /*!< \brief pointer to A-bis layer 2 header: OML, RSL(RLL), NS */
  56:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l3h; /*!< \brief pointer to Layer 3 header. For OML: FOM; RSL: 04.08; GPRS: BSSGP *
  57:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *l4h; /*!< \brief pointer to layer 4 header */
  58:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  59:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned long cb[5]; /*!< \brief control buffer */
  60:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  61:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t data_len;   /*!< \brief length of underlying data array */
  62:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	uint16_t len;	     /*!< \brief length of bytes used in msgb */
  63:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  64:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *head;	/*!< \brief start of underlying memory buffer */
  65:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tail;	/*!< \brief end of message in buffer */
  66:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *data;	/*!< \brief start of message in buffer */
  67:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char _data[0]; /*!< \brief optional immediate data array */
  68:../../shared/libosmocore/include/osmocom/core/msgb.h **** };
  69:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  70:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_alloc(uint16_t size, const char *name);
  71:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_free(struct msgb *m);
  72:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_enqueue(struct llist_head *queue, struct msgb *msg);
  73:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern struct msgb *msgb_dequeue(struct llist_head *queue);
  74:../../shared/libosmocore/include/osmocom/core/msgb.h **** extern void msgb_reset(struct msgb *m);
  75:../../shared/libosmocore/include/osmocom/core/msgb.h **** uint16_t msgb_length(const struct msgb *msg);
  76:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  77:../../shared/libosmocore/include/osmocom/core/msgb.h **** #ifdef MSGB_DEBUG
  78:../../shared/libosmocore/include/osmocom/core/msgb.h **** #include <osmocom/core/panic.h>
  79:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...) do {		\
  80:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	osmo_panic("msgb(%p): " fmt, msg, ## args);	\
  81:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	} while(0)
  82:../../shared/libosmocore/include/osmocom/core/msgb.h **** #else
  83:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define MSGB_ABORT(msg, fmt, args ...)
  84:../../shared/libosmocore/include/osmocom/core/msgb.h **** #endif
  85:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  86:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L1 header of msgb */
  87:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l1(m)	((void *)(m->l1h))
  88:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L2 header of msgb */
  89:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l2(m)	((void *)(m->l2h))
  90:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain L3 header of msgb */
  91:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_l3(m)	((void *)(m->l3h))
  92:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief obtain SMS header of msgb */
  93:../../shared/libosmocore/include/osmocom/core/msgb.h **** #define msgb_sms(m)	((void *)(m->l4h))
  94:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
  95:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L1 message
  96:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
  97:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L1 message in bytes
  98:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
  99:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 100:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 1 header.
 101:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 102:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l1len(const struct msgb *msgb)
 103:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 104:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l1(msgb);
 105:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 106:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 107:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L2 message
 108:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 109:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L2 message in bytes
 110:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 111:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 112:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 2 header.
 113:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 114:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l2len(const struct msgb *msgb)
 115:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 116:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l2(msgb);
 117:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 118:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 119:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine length of L3 message
 120:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 121:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns size of L3 message in bytes
 122:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 123:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the number of bytes between the tail of the
 124:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * message and the layer 3 header.
 125:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 126:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_l3len(const struct msgb *msgb)
 127:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 128:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->tail - (uint8_t *)msgb_l3(msgb);
 129:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 130:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 131:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the length of the header
 132:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 133:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes between start of buffer and start of msg
 134:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 135:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the length difference between the underlying
 136:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer and the used section of the \a msgb.
 137:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 138:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned int msgb_headlen(const struct msgb *msgb)
 139:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 140:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return msgb->len - msgb->data_len;
 141:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 142:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 143:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine how much tail room is left in msgb
 144:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 145:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes remaining at end of msgb
 146:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 147:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of octets left in the underlying
 148:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer after the end of the message.
 149:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 150:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_tailroom(const struct msgb *msgb)
 151:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 153:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 154:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 155:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief determine the amount of headroom in msgb
 156:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 157:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns number of bytes left ahead of message start in msgb
 158:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 159:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function computes the amount of bytes left in the underlying
 160:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data buffer before the start of the actual message.
 161:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 162:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline int msgb_headroom(const struct msgb *msgb)
 163:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 164:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->data - msgb->head);
 165:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 166:../../shared/libosmocore/include/osmocom/core/msgb.h **** 
 167:../../shared/libosmocore/include/osmocom/core/msgb.h **** /*! \brief append data to end of message buffer
 168:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] msgb message buffer
 169:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \param[in] len number of bytes to append to message
 170:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *  \returns pointer to start of newly-appended data
 171:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 172:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * This function will move the \a tail pointer of the message buffer \a
 173:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * len bytes further, thus enlarging the message by \a len bytes.
 174:../../shared/libosmocore/include/osmocom/core/msgb.h ****  *
 175:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * The return value is a pointer to start of the newly added section at
 176:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * the end of the message and can be used for actually filling/copying
 177:../../shared/libosmocore/include/osmocom/core/msgb.h ****  * data into it.
 178:../../shared/libosmocore/include/osmocom/core/msgb.h ****  */
 179:../../shared/libosmocore/include/osmocom/core/msgb.h **** static inline unsigned char *msgb_put(struct msgb *msgb, unsigned int len)
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
  80              		.loc 4 180 0
  81              		.cfi_startproc
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  84              	.LVL8:
  85              	.LBB22:
  86              	.LBB23:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
  87              		.loc 4 152 0
  88 0000 B433D0E1 		ldrh	r3, [r0, #52]
  89 0004 382090E5 		ldr	r2, [r0, #56]
  90              	.LBE23:
  91              	.LBE22:
  92              		.loc 4 180 0
  93 0008 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  94              	.LCFI0:
  95              		.cfi_def_cfa_offset 16
 181:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	unsigned char *tmp = msgb->tail;
  96              		.loc 4 181 0
  97 000c 3C6090E5 		ldr	r6, [r0, #60]
  98              		.cfi_offset 14, -4
  99              		.cfi_offset 6, -8
 100              		.cfi_offset 5, -12
 101              		.cfi_offset 4, -16
 102              	.LVL9:
 103              	.LBB25:
 104              	.LBB24:
 152:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return (msgb->head + msgb->data_len) - msgb->tail;
 105              		.loc 4 152 0
 106 0010 032082E0 		add	r2, r2, r3
 107 0014 022066E0 		rsb	r2, r6, r2
 108              	.LBE24:
 109              	.LBE25:
 182:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	if (msgb_tailroom(msgb) < (int) len)
 110              		.loc 4 182 0
 111 0018 010052E1 		cmp	r2, r1
 180:../../shared/libosmocore/include/osmocom/core/msgb.h **** {
 112              		.loc 4 180 0
 113 001c 0040A0E1 		mov	r4, r0
 114              	.LVL10:
 115 0020 0150A0E1 		mov	r5, r1
 116              		.loc 4 182 0
 117              	.LVL11:
 183:../../shared/libosmocore/include/osmocom/core/msgb.h **** 		MSGB_ABORT(msgb, "Not enough tailroom msgb_push (%u < %u)\n",
 118              		.loc 4 183 0
 119 0024 28009FB5 		ldrlt	r0, .L7
 120              	.LVL12:
 121 0028 0410A0B1 		movlt	r1, r4
 122              	.LVL13:
 123 002c 0530A0B1 		movlt	r3, r5
 124 0030 FEFFFFBB 		bllt	osmo_panic
 125              	.LVL14:
 126              	.L6:
 184:../../shared/libosmocore/include/osmocom/core/msgb.h **** 			   msgb_tailroom(msgb), len);
 185:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->tail += len;
 127              		.loc 4 185 0
 128 0034 3C3094E5 		ldr	r3, [r4, #60]
 129 0038 053083E0 		add	r3, r3, r5
 130 003c 3C3084E5 		str	r3, [r4, #60]
 186:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	msgb->len += len;
 131              		.loc 4 186 0
 132 0040 B633D4E1 		ldrh	r3, [r4, #54]
 133 0044 035085E0 		add	r5, r5, r3
 134              	.LVL15:
 135 0048 B653C4E1 		strh	r5, [r4, #54]	@ movhi
 187:../../shared/libosmocore/include/osmocom/core/msgb.h **** 	return tmp;
 188:../../shared/libosmocore/include/osmocom/core/msgb.h **** }
 136              		.loc 4 188 0
 137 004c 0600A0E1 		mov	r0, r6
 138 0050 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 139              	.L8:
 140              		.align	2
 141              	.L7:
 142 0054 00000000 		.word	.LC0
 143              		.cfi_endproc
 144              	.LFE38:
 146              		.section	.text.dsp_task_iq_swap,"ax",%progbits
 147              		.align	2
 149              	dsp_task_iq_swap:
 150              	.LFB63:
 151              		.file 5 "include/calypso/dsp.h"
   1:include/calypso/dsp.h **** #ifndef _CALYPSO_DSP_H
   2:include/calypso/dsp.h **** #define _CALYPSO_DSP_H
   3:include/calypso/dsp.h **** 
   4:include/calypso/dsp.h **** #include <calypso/dsp_api.h>
   5:include/calypso/dsp.h **** #include <rffe.h>
   6:include/calypso/dsp.h **** 
   7:include/calypso/dsp.h **** #define CAL_DSP_TGT_BB_LVL	80
   8:include/calypso/dsp.h **** 
   9:include/calypso/dsp.h **** struct gsm_time;
  10:include/calypso/dsp.h **** 
  11:include/calypso/dsp.h **** struct dsp_api {
  12:include/calypso/dsp.h **** 	T_NDB_MCU_DSP *ndb;
  13:include/calypso/dsp.h **** 	T_DB_DSP_TO_MCU *db_r;
  14:include/calypso/dsp.h **** 	T_DB_MCU_TO_DSP *db_w;
  15:include/calypso/dsp.h **** 	T_PARAM_MCU_DSP *param;
  16:include/calypso/dsp.h **** 	int r_page;
  17:include/calypso/dsp.h **** 	int w_page;
  18:include/calypso/dsp.h **** 	int r_page_used;
  19:include/calypso/dsp.h **** 	int frame_ctr;
  20:include/calypso/dsp.h **** };
  21:include/calypso/dsp.h **** 
  22:include/calypso/dsp.h **** extern struct dsp_api dsp_api;
  23:include/calypso/dsp.h **** 
  24:include/calypso/dsp.h **** void dsp_power_on(void);
  25:include/calypso/dsp.h **** void dsp_dump_version(void);
  26:include/calypso/dsp.h **** void dsp_dump(void);
  27:include/calypso/dsp.h **** void dsp_checksum_task(void);
  28:include/calypso/dsp.h **** void dsp_api_memset(uint16_t *ptr, int octets);
  29:include/calypso/dsp.h **** void dsp_memcpy_to_api(volatile uint16_t *dsp_buf, const uint8_t *mcu_buf, int n, int be);
  30:include/calypso/dsp.h **** void dsp_memcpy_from_api(uint8_t *mcu_buf, const volatile uint16_t *dsp_buf, int n, int be);
  31:include/calypso/dsp.h **** void dsp_load_afc_dac(uint16_t afc);
  32:include/calypso/dsp.h **** void dsp_load_apc_dac(uint16_t apc);
  33:include/calypso/dsp.h **** void dsp_load_tch_param(struct gsm_time *next_time,
  34:include/calypso/dsp.h ****                         uint8_t chan_mode, uint8_t chan_type, uint8_t chan_sub,
  35:include/calypso/dsp.h ****                         uint8_t tch_loop, uint8_t sync_tch, uint8_t tn);
  36:include/calypso/dsp.h **** void dsp_load_ciph_param(int mode, uint8_t *key);
  37:include/calypso/dsp.h **** void dsp_end_scenario(void);
  38:include/calypso/dsp.h **** 
  39:include/calypso/dsp.h **** void dsp_load_rx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  40:include/calypso/dsp.h **** void dsp_load_tx_task(uint16_t task, uint8_t burst_id, uint8_t tsc);
  41:include/calypso/dsp.h **** 
  42:include/calypso/dsp.h **** static inline uint16_t
  43:include/calypso/dsp.h **** dsp_task_iq_swap(uint16_t dsp_task, uint16_t band_arfcn, int tx)
  44:include/calypso/dsp.h **** {
 152              		.loc 5 44 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 0
 155              		@ frame_needed = 0, uses_anonymous_args = 0
 156              	.LVL16:
 157 0000 10402DE9 		stmfd	sp!, {r4, lr}
 158              	.LCFI1:
 159              		.cfi_def_cfa_offset 8
 160              		.loc 5 44 0
 161 0004 0040A0E1 		mov	r4, r0
 162              		.cfi_offset 14, -4
 163              		.cfi_offset 4, -8
  45:include/calypso/dsp.h **** 	if (rffe_iq_swapped(band_arfcn, tx))
 164              		.loc 5 45 0
 165 0008 0100A0E1 		mov	r0, r1
 166              	.LVL17:
 167 000c 0210A0E1 		mov	r1, r2
 168              	.LVL18:
 169 0010 FEFFFFEB 		bl	rffe_iq_swapped
 170              	.LVL19:
 171 0014 000050E3 		cmp	r0, #0
  46:include/calypso/dsp.h **** 		dsp_task |= 0x8000;
 172              		.loc 5 46 0
 173 0018 02498413 		orrne	r4, r4, #32768
 174              	.LVL20:
  47:include/calypso/dsp.h **** 	return dsp_task;
  48:include/calypso/dsp.h **** }
 175              		.loc 5 48 0
 176 001c 0400A0E1 		mov	r0, r4
 177 0020 1080BDE8 		ldmfd	sp!, {r4, pc}
 178              		.cfi_endproc
 179              	.LFE63:
 181              		.section	.text.l1a_tx_tch_compl,"ax",%progbits
 182              		.align	2
 184              	l1a_tx_tch_compl:
 185              	.LFB66:
 115:layer1/prim_tch.c **** {
 186              		.loc 1 115 0
 187              		.cfi_startproc
 188              		@ args = 0, pretend = 0, frame = 0
 189              		@ frame_needed = 0, uses_anonymous_args = 0
 190              	.LVL21:
 118:layer1/prim_tch.c **** 	if (last_tx_tch_type & (TX_TYPE_SACCH | TX_TYPE_FACCH)) {
 191              		.loc 1 118 0
 192 0000 5C309FE5 		ldr	r3, .L14
 193 0004 B020D3E1 		ldrh	r2, [r3, #0]
 194 0008 030012E3 		tst	r2, #3
 115:layer1/prim_tch.c **** {
 195              		.loc 1 115 0
 196 000c 04E02DE5 		str	lr, [sp, #-4]!
 197              	.LCFI2:
 198              		.cfi_def_cfa_offset 4
 118:layer1/prim_tch.c **** 	if (last_tx_tch_type & (TX_TYPE_SACCH | TX_TYPE_FACCH)) {
 199              		.loc 1 118 0
 200 0010 0500000A 		beq	.L12
 201              		.cfi_offset 14, -4
 119:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_DATA_CONF, last_tx_tch_fn, 0, 0);
 202              		.loc 1 119 0
 203 0014 0020A0E3 		mov	r2, #0
 204 0018 B210D3E1 		ldrh	r1, [r3, #2]
 205 001c 0F00A0E3 		mov	r0, #15
 206              	.LVL22:
 207 0020 0230A0E1 		mov	r3, r2
 208 0024 FEFFFFEB 		bl	l1_create_l2_msg
 120:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 209              		.loc 1 120 0
 210 0028 FEFFFFEB 		bl	l1_queue_for_l2
 211              	.L12:
 123:layer1/prim_tch.c **** 	if (last_tx_tch_type & TX_TYPE_TRAFFIC) {
 212              		.loc 1 123 0
 213 002c 30309FE5 		ldr	r3, .L14
 214 0030 B020D3E1 		ldrh	r2, [r3, #0]
 215 0034 040012E3 		tst	r2, #4
 216 0038 0500000A 		beq	.L13
 124:layer1/prim_tch.c **** 		msg = l1_create_l2_msg(L1CTL_TRAFFIC_CONF, last_tx_tch_fn, 0, 0);
 217              		.loc 1 124 0
 218 003c 0020A0E3 		mov	r2, #0
 219 0040 B210D3E1 		ldrh	r1, [r3, #2]
 220 0044 1D00A0E3 		mov	r0, #29
 221 0048 0230A0E1 		mov	r3, r2
 222 004c FEFFFFEB 		bl	l1_create_l2_msg
 125:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 223              		.loc 1 125 0
 224 0050 FEFFFFEB 		bl	l1_queue_for_l2
 225              	.L13:
 128:layer1/prim_tch.c **** 	last_tx_tch_type = 0;
 226              		.loc 1 128 0
 227 0054 08309FE5 		ldr	r3, .L14
 228 0058 0020A0E3 		mov	r2, #0	@ movhi
 229 005c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 129:layer1/prim_tch.c **** }
 230              		.loc 1 129 0
 231 0060 04F09DE4 		ldr	pc, [sp], #4
 232              	.L15:
 233              		.align	2
 234              	.L14:
 235 0064 00000000 		.word	.LANCHOR0
 236              		.cfi_endproc
 237              	.LFE66:
 239              		.global	__umodsi3
 240              		.section	.text.tch_get_params.clone.0,"ax",%progbits
 241              		.align	2
 243              	tch_get_params.clone.0:
 244              	.LFB74:
  62:layer1/prim_tch.c **** static void tch_get_params(struct gsm_time *time, uint8_t chan_nr,
 245              		.loc 1 62 0
 246              		.cfi_startproc
 247              		@ args = 8, pretend = 0, frame = 0
 248              		@ frame_needed = 0, uses_anonymous_args = 0
 249              	.LVL23:
 250 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 251              	.LCFI3:
 252              		.cfi_def_cfa_offset 24
  67:layer1/prim_tch.c **** 	uint8_t cbits = chan_nr >> 3;
 253              		.loc 1 67 0
 254 0004 A181A0E1 		mov	r8, r1, lsr #3
 255              		.cfi_offset 14, -4
 256              		.cfi_offset 8, -8
 257              		.cfi_offset 7, -12
 258              		.cfi_offset 6, -16
 259              		.cfi_offset 5, -20
 260              		.cfi_offset 4, -24
  69:layer1/prim_tch.c **** 	*tch_f_hn = (cbits & 2) ? 0 : 1;
 261              		.loc 1 69 0
 262 0008 020018E3 		tst	r8, #2
  62:layer1/prim_tch.c **** static void tch_get_params(struct gsm_time *time, uint8_t chan_nr,
 263              		.loc 1 62 0
 264 000c 0360A0E1 		mov	r6, r3
  69:layer1/prim_tch.c **** 	*tch_f_hn = (cbits & 2) ? 0 : 1;
 265              		.loc 1 69 0
 266 0010 0030A013 		movne	r3, #0
 267 0014 0130A003 		moveq	r3, #1
 268              	.LVL24:
 269 0018 0030C6E5 		strb	r3, [r6, #0]
  71:layer1/prim_tch.c **** 	if (*tch_f_hn) {
 270              		.loc 1 71 0
 271 001c 000053E3 		cmp	r3, #0
  62:layer1/prim_tch.c **** static void tch_get_params(struct gsm_time *time, uint8_t chan_nr,
 272              		.loc 1 62 0
 273 0020 0240A0E1 		mov	r4, r2
 274 0024 18709DE5 		ldr	r7, [sp, #24]
 275 0028 1C509DE5 		ldr	r5, [sp, #28]
  66:layer1/prim_tch.c **** 	uint8_t tn = chan_nr & 0x07;
 276              		.loc 1 66 0
 277 002c 072001E2 		and	r2, r1, #7
 278              	.LVL25:
 279 0030 000090E5 		ldr	r0, [r0, #0]
  71:layer1/prim_tch.c **** 	if (*tch_f_hn) {
 280              		.loc 1 71 0
 281 0034 0800000A 		beq	.L17
  72:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn * 13) + 104) % 104;
 282              		.loc 1 72 0
 283 0038 0C30E0E3 		mvn	r3, #12
 284 003c 680080E2 		add	r0, r0, #104
 285 0040 930220E0 		mla	r0, r3, r2, r0
 286 0044 6810A0E3 		mov	r1, #104
 287              	.LVL26:
 288 0048 FEFFFFEB 		bl	__umodsi3
 289              	.LVL27:
  73:layer1/prim_tch.c **** 		*tch_sub = 0;
 290              		.loc 1 73 0
 291 004c 0030A0E3 		mov	r3, #0
  72:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn * 13) + 104) % 104;
 292              		.loc 1 72 0
 293 0050 000084E5 		str	r0, [r4, #0]
  73:layer1/prim_tch.c **** 		*tch_sub = 0;
 294              		.loc 1 73 0
 295 0054 0030C7E5 		strb	r3, [r7, #0]
 296 0058 090000EA 		b	.L18
 297              	.LVL28:
 298              	.L17:
 299              	.LBB26:
  75:layer1/prim_tch.c **** 		uint8_t chan_sub = cbits & 1;
 300              		.loc 1 75 0
 301 005c 018008E2 		and	r8, r8, #1
 302              	.LVL29:
  76:layer1/prim_tch.c **** 		uint8_t tn_report = (tn & ~1) | chan_sub;
 303              		.loc 1 76 0
 304 0060 061001E2 		and	r1, r1, #6
 305              	.LVL30:
  77:layer1/prim_tch.c **** 		*fn_report = (time->fn - (tn_report * 13) + 104) % 104;
 306              		.loc 1 77 0
 307 0064 683080E2 		add	r3, r0, #104
 308 0068 011088E1 		orr	r1, r8, r1
 309 006c 0C00E0E3 		mvn	r0, #12
 310 0070 913020E0 		mla	r0, r1, r0, r3
 311 0074 6810A0E3 		mov	r1, #104
 312 0078 FEFFFFEB 		bl	__umodsi3
 313              	.LVL31:
 314 007c 000084E5 		str	r0, [r4, #0]
  78:layer1/prim_tch.c **** 		*tch_sub = chan_sub;
 315              		.loc 1 78 0
 316 0080 0080C7E5 		strb	r8, [r7, #0]
 317              	.LVL32:
 318              	.L18:
 319              	.LBE26:
  81:layer1/prim_tch.c **** 	if (tch_mode) {
 320              		.loc 1 81 0
 321 0084 000055E3 		cmp	r5, #0
 322 0088 F081BD08 		ldmeqfd	sp!, {r4, r5, r6, r7, r8, pc}
  82:layer1/prim_tch.c **** 		switch (l1s.tch_mode) {
 323              		.loc 1 82 0
 324 008c 44309FE5 		ldr	r3, .L30
 325 0090 4A3AD3E5 		ldrb	r3, [r3, #2634]	@ zero_extendqisi2
 326 0094 010053E3 		cmp	r3, #1
 327 0098 0300000A 		beq	.L21
 328 009c 210053E3 		cmp	r3, #33
  90:layer1/prim_tch.c **** 			*tch_mode = SIG_ONLY_MODE;
 329              		.loc 1 90 0
 330 00a0 0030A013 		movne	r3, #0
  82:layer1/prim_tch.c **** 		switch (l1s.tch_mode) {
 331              		.loc 1 82 0
 332 00a4 0900001A 		bne	.L28
 333 00a8 040000EA 		b	.L29
 334              	.L21:
  84:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_FS_MODE : TCH_HS_MODE;
 335              		.loc 1 84 0
 336 00ac 0030D6E5 		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 337 00b0 000053E3 		cmp	r3, #0
 338 00b4 0230A003 		moveq	r3, #2
 339 00b8 0130A013 		movne	r3, #1
 340 00bc 030000EA 		b	.L28
 341              	.L29:
  87:layer1/prim_tch.c **** 			*tch_mode = *tch_f_hn ? TCH_EFR_MODE : SIG_ONLY_MODE;
 342              		.loc 1 87 0
 343 00c0 0030D6E5 		ldrb	r3, [r6, #0]	@ zero_extendqisi2
 344 00c4 000053E3 		cmp	r3, #0
 345 00c8 0830A013 		movne	r3, #8
 346 00cc 0030A003 		moveq	r3, #0
 347              	.L28:
  90:layer1/prim_tch.c **** 			*tch_mode = SIG_ONLY_MODE;
 348              		.loc 1 90 0
 349 00d0 0030C5E5 		strb	r3, [r5, #0]
 350 00d4 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 351              	.L31:
 352              		.align	2
 353              	.L30:
 354 00d8 00000000 		.word	l1s
 355              		.cfi_endproc
 356              	.LFE74:
 358              		.global	__udivsi3
 359              		.section	.text.l1s_tch_a_resp,"ax",%progbits
 360              		.align	2
 362              	l1s_tch_a_resp:
 363              	.LFB72:
 516:layer1/prim_tch.c **** 
 517:layer1/prim_tch.c **** static int l1s_tch_d_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 518:layer1/prim_tch.c **** {
 519:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 520:layer1/prim_tch.c **** 	uint8_t chan_nr;
 521:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 522:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 523:layer1/prim_tch.c **** 	uint32_t fn_report;
 524:layer1/prim_tch.c **** 
 525:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 526:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, NULL, &tsc, &tn);
 527:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 528:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 529:layer1/prim_tch.c **** 
 530:layer1/prim_tch.c **** 	/* Configure DSP */
 531:layer1/prim_tch.c **** 	dsp_load_tch_param(
 532:layer1/prim_tch.c **** 		&l1s.next_time,
 533:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 534:layer1/prim_tch.c **** 		0, 0, tn
 535:layer1/prim_tch.c **** 	);
 536:layer1/prim_tch.c **** 
 537:layer1/prim_tch.c **** 	dsp_load_rx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 538:layer1/prim_tch.c **** 	dsp_load_tx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 539:layer1/prim_tch.c **** 
 540:layer1/prim_tch.c **** 	return 0;
 541:layer1/prim_tch.c **** }
 542:layer1/prim_tch.c **** 
 543:layer1/prim_tch.c **** const struct tdma_sched_item tch_d_sched_set[] = {
 544:layer1/prim_tch.c **** 	SCHED_ITEM_DT(l1s_tch_d_cmd, 0, 0, 0),	SCHED_END_FRAME(),
 545:layer1/prim_tch.c **** 						SCHED_END_FRAME(),
 546:layer1/prim_tch.c **** 	SCHED_ITEM(l1s_tch_d_resp, 0, 0, -4),	SCHED_END_FRAME(),
 547:layer1/prim_tch.c **** 	SCHED_END_SET()
 548:layer1/prim_tch.c **** };
 549:layer1/prim_tch.c **** 
 550:layer1/prim_tch.c **** 
 551:layer1/prim_tch.c **** /* -------------------------------------------------------------------------
 552:layer1/prim_tch.c ****  * TCH: SACCH
 553:layer1/prim_tch.c ****  * ------------------------------------------------------------------------- */
 554:layer1/prim_tch.c **** 
 555:layer1/prim_tch.c **** /*
 556:layer1/prim_tch.c ****  * SACCH data are spread over 4 bursts, however they are so far appart that
 557:layer1/prim_tch.c ****  * we can't use the normal scheduler to schedule all them at once in a single
 558:layer1/prim_tch.c ****  * set.
 559:layer1/prim_tch.c ****  * Therefore, the task code itself decides in which burst it is, if it's the
 560:layer1/prim_tch.c ****  * start/end, and act appropriately.
 561:layer1/prim_tch.c ****  */
 562:layer1/prim_tch.c **** 
 563:layer1/prim_tch.c **** 
 564:layer1/prim_tch.c **** struct l1s_rx_tch_a_state {
 565:layer1/prim_tch.c **** 	struct l1s_meas_hdr meas[4];
 566:layer1/prim_tch.c **** 
 567:layer1/prim_tch.c **** 	struct msgb *msg;
 568:layer1/prim_tch.c **** 	struct l1ctl_info_dl *dl;
 569:layer1/prim_tch.c **** 	struct l1ctl_data_ind *di;
 570:layer1/prim_tch.c **** };
 571:layer1/prim_tch.c **** 
 572:layer1/prim_tch.c **** static struct l1s_rx_tch_a_state rx_tch_a;
 573:layer1/prim_tch.c **** 
 574:layer1/prim_tch.c **** 
 575:layer1/prim_tch.c **** static int l1s_tch_a_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 576:layer1/prim_tch.c **** {
 364              		.loc 1 576 0
 365              		.cfi_startproc
 366              		@ args = 0, pretend = 0, frame = 24
 367              		@ frame_needed = 0, uses_anonymous_args = 0
 368              	.LVL33:
 369 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 370              	.LCFI4:
 371              		.cfi_def_cfa_offset 20
 577:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 578:layer1/prim_tch.c **** 	struct gsm_time rx_time;
 579:layer1/prim_tch.c **** 	uint8_t chan_nr;
 580:layer1/prim_tch.c **** 	uint16_t arfcn;
 581:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 582:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub;
 583:layer1/prim_tch.c **** 	uint32_t fn_report;
 584:layer1/prim_tch.c **** 	uint8_t burst_id;
 585:layer1/prim_tch.c **** 
 586:layer1/prim_tch.c **** 	/* It may happen we've never gone through cmd(0) yet, skip until then */
 587:layer1/prim_tch.c **** 	if (!rx_tch_a.msg)
 372              		.loc 1 587 0
 373 0004 5C629FE5 		ldr	r6, .L41
 374              		.cfi_offset 14, -4
 375              		.cfi_offset 7, -8
 376              		.cfi_offset 6, -12
 377              		.cfi_offset 5, -16
 378              		.cfi_offset 4, -20
 379 0008 243096E5 		ldr	r3, [r6, #36]
 576:layer1/prim_tch.c **** {
 380              		.loc 1 576 0
 381 000c 0228A0E1 		mov	r2, r2, asl #16
 382              	.LVL34:
 383              		.loc 1 587 0
 384 0010 000053E3 		cmp	r3, #0
 576:layer1/prim_tch.c **** {
 385              		.loc 1 576 0
 386 0014 20D04DE2 		sub	sp, sp, #32
 387              	.LCFI5:
 388              		.cfi_def_cfa_offset 52
 576:layer1/prim_tch.c **** {
 389              		.loc 1 576 0
 390 0018 2258A0E1 		mov	r5, r2, lsr #16
 391              	.LVL35:
 392              		.loc 1 587 0
 393 001c 8B00000A 		beq	.L33
 588:layer1/prim_tch.c **** 		goto skip;
 589:layer1/prim_tch.c **** 
 590:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 591:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 394              		.loc 1 591 0
 395 0020 44329FE5 		ldr	r3, .L41+4
 396 0024 44029FE5 		ldr	r0, .L41+8
 397              	.LVL36:
 398 0028 003093E5 		ldr	r3, [r3, #0]
 399 002c 40129FE5 		ldr	r1, .L41+12
 400              	.LVL37:
 401 0030 000083E0 		add	r0, r3, r0
 402 0034 FEFFFFEB 		bl	__umodsi3
 403 0038 08408DE2 		add	r4, sp, #8
 404 003c 0010A0E1 		mov	r1, r0
 405 0040 0400A0E1 		mov	r0, r4
 406 0044 FEFFFFEB 		bl	gsm_fn2gsmtime
 592:layer1/prim_tch.c **** 	rfch_get_params(&rx_time, &arfcn, &tsc, &tn);
 407              		.loc 1 592 0
 408 0048 0400A0E1 		mov	r0, r4
 409 004c 1F208DE2 		add	r2, sp, #31
 410 0050 1E308DE2 		add	r3, sp, #30
 411 0054 1A108DE2 		add	r1, sp, #26
 412 0058 FEFFFFEB 		bl	rfch_get_params
 593:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 413              		.loc 1 593 0
 414 005c FF0005E2 		and	r0, r5, #255
 415              	.LVL38:
 416 0060 1E10DDE5 		ldrb	r1, [sp, #30]	@ zero_extendqisi2
 417 0064 FEFFFFEB 		bl	mframe_task2chan_nr
 594:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 418              		.loc 1 594 0
 419 0068 1C308DE2 		add	r3, sp, #28
 420 006c 0050A0E3 		mov	r5, #0
 421              	.LVL39:
 422 0070 14208DE2 		add	r2, sp, #20
 593:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 423              		.loc 1 593 0
 424 0074 0010A0E1 		mov	r1, r0
 425              	.LVL40:
 426              		.loc 1 594 0
 427 0078 00308DE5 		str	r3, [sp, #0]
 428 007c 0400A0E1 		mov	r0, r4
 429              	.LVL41:
 430 0080 1D308DE2 		add	r3, sp, #29
 431 0084 04508DE5 		str	r5, [sp, #4]
 432 0088 FEFFFFEB 		bl	tch_get_params.clone.0
 433              	.LVL42:
 595:layer1/prim_tch.c **** 	burst_id = (fn_report - 12) / 26;
 434              		.loc 1 595 0
 435 008c 14009DE5 		ldr	r0, [sp, #20]
 436 0090 1A10A0E3 		mov	r1, #26
 437 0094 0C0040E2 		sub	r0, r0, #12
 438 0098 FEFFFFEB 		bl	__udivsi3
 596:layer1/prim_tch.c **** 
 597:layer1/prim_tch.c **** 	/* Collect measurements */
 598:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 439              		.loc 1 598 0
 440 009c D4719FE5 		ldr	r7, .L41+16
 441 00a0 043097E5 		ldr	r3, [r7, #4]
 595:layer1/prim_tch.c **** 	burst_id = (fn_report - 12) / 26;
 442              		.loc 1 595 0
 443 00a4 FF4000E2 		and	r4, r0, #255
 444              	.LVL43:
 445              		.loc 1 598 0
 446 00a8 B011D3E1 		ldrh	r1, [r3, #16]
 599:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].pm_dbm8 =
 600:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 447              		.loc 1 600 0
 448 00ac B201D3E1 		ldrh	r0, [r3, #18]
 598:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 449              		.loc 1 598 0
 450 00b0 846186E0 		add	r6, r6, r4, asl #3
 451 00b4 B610C6E1 		strh	r1, [r6, #6]	@ movhi
 452              		.loc 1 600 0
 453 00b8 A001A0E1 		mov	r0, r0, lsr #3
 454 00bc FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 601:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].freq_err =
 602:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 455              		.loc 1 602 0
 456 00c0 041097E5 		ldr	r1, [r7, #4]
 599:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].pm_dbm8 =
 457              		.loc 1 599 0
 458 00c4 B800C6E1 		strh	r0, [r6, #8]	@ movhi
 459              		.loc 1 602 0
 460 00c8 F421D1E1 		ldrsh	r2, [r1, #20]
 461 00cc A8019FE5 		ldr	r0, .L41+20
 462 00d0 900202E0 		mul	r2, r0, r2
 463 00d4 050052E1 		cmp	r2, r5
 464 00d8 FF0C82E2 		add	r0, r2, #65280
 465 00dc FF2080B2 		addlt	r2, r0, #255
 599:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].pm_dbm8 =
 466              		.loc 1 599 0
 467 00e0 083086E2 		add	r3, r6, #8
 468              		.loc 1 602 0
 469 00e4 4228A0E1 		mov	r2, r2, asr #16
 601:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].freq_err =
 470              		.loc 1 601 0
 471 00e8 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 603:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 472              		.loc 1 603 0
 473 00ec B621D1E1 		ldrh	r2, [r1, #22]
 604:layer1/prim_tch.c **** 
 605:layer1/prim_tch.c **** 	/* feed computed frequency error into AFC loop */
 606:layer1/prim_tch.c **** 	if (rx_tch_a.meas[burst_id].snr > AFC_SNR_THRESHOLD)
 474              		.loc 1 606 0
 475 00f0 0A0C52E3 		cmp	r2, #2560
 603:layer1/prim_tch.c **** 	rx_tch_a.meas[burst_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 476              		.loc 1 603 0
 477 00f4 B420C6E1 		strh	r2, [r6, #4]	@ movhi
 607:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 1);
 608:layer1/prim_tch.c **** 	else
 609:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 0);
 478              		.loc 1 609 0
 479 00f8 0520A091 		movls	r2, r5
 610:layer1/prim_tch.c **** 
 611:layer1/prim_tch.c **** 	/* feed computed TOA into TA loop */
 612:layer1/prim_tch.c **** 	toa_input(rx_tch_a.meas[burst_id].toa_qbit << 2, rx_tch_a.meas[burst_id].snr);
 480              		.loc 1 612 0
 481 00fc 64519FE5 		ldr	r5, .L41
 482 0100 F200D3E1 		ldrsh	r0, [r3, #2]
 607:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 1);
 483              		.loc 1 607 0
 484 0104 0120A083 		movhi	r2, #1
 485              		.loc 1 612 0
 486 0108 846185E0 		add	r6, r5, r4, asl #3
 487              	.LVL44:
 488 010c BA11DDE1 		ldrh	r1, [sp, #26]
 489              	.LVL45:
 609:layer1/prim_tch.c **** 		afc_input(rx_tch_a.meas[burst_id].freq_err, arfcn, 0);
 490              		.loc 1 609 0
 491 0110 FEFFFFEB 		bl	afc_input
 492              		.loc 1 612 0
 493 0114 F600D6E1 		ldrsh	r0, [r6, #6]
 494 0118 B410D6E1 		ldrh	r1, [r6, #4]
 495 011c 0001A0E1 		mov	r0, r0, asl #2
 496 0120 FEFFFFEB 		bl	toa_input
 613:layer1/prim_tch.c **** 
 614:layer1/prim_tch.c **** 	/* Tell the RF frontend to set the gain appropriately */
 615:layer1/prim_tch.c **** 	rffe_compute_gain(rx_tch_a.meas[burst_id].pm_dbm8 / 8,
 497              		.loc 1 615 0
 498 0124 F800D6E1 		ldrsh	r0, [r6, #8]
 499 0128 000050E3 		cmp	r0, #0
 500 012c 073080E2 		add	r3, r0, #7
 501 0130 0300A0B1 		movlt	r0, r3
 502 0134 C001A0E1 		mov	r0, r0, asr #3
 503 0138 5010A0E3 		mov	r1, #80
 504 013c FEFFFFEB 		bl	rffe_compute_gain
 616:layer1/prim_tch.c **** 		CAL_DSP_TGT_BB_LVL);
 617:layer1/prim_tch.c **** 
 618:layer1/prim_tch.c **** 	/* Last burst, read data & send to the up layer */
 619:layer1/prim_tch.c **** 	if ((burst_id == 3) && (dsp_api.ndb->a_cd[0] & (1<<B_BLUD))) {
 505              		.loc 1 619 0
 506 0140 030054E3 		cmp	r4, #3
 507 0144 4100001A 		bne	.L33
 508              		.loc 1 619 0 is_stmt 0 discriminator 1
 509 0148 28319FE5 		ldr	r3, .L41+16
 510 014c 002093E5 		ldr	r2, [r3, #0]
 511 0150 7F3FA0E3 		mov	r3, #508
 512 0154 F33092E1 		ldrsh	r3, [r2, r3]
 513 0158 000053E3 		cmp	r3, #0
 514 015c 3B0000AA 		bge	.L33
 575:layer1/prim_tch.c **** static int l1s_tch_a_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 515              		.loc 1 575 0 is_stmt 1
 516 0160 0000A0E3 		mov	r0, #0
 517              		.loc 1 619 0
 518 0164 043085E2 		add	r3, r5, #4
 575:layer1/prim_tch.c **** static int l1s_tch_a_resp(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 519              		.loc 1 575 0
 520 0168 0020A0E1 		mov	r2, r0
 521 016c 245085E2 		add	r5, r5, #36
 522              	.L36:
 523              	.LBB27:
 620:layer1/prim_tch.c **** 		unsigned int i;
 621:layer1/prim_tch.c **** 		uint16_t num_biterr;
 622:layer1/prim_tch.c **** 		uint32_t avg_snr = 0;
 623:layer1/prim_tch.c **** 		int32_t avg_dbm8 = 0;
 624:layer1/prim_tch.c **** 
 625:layer1/prim_tch.c **** 		/* Average SNR & RX level + error & crc status */
 626:layer1/prim_tch.c **** 		for (i=0; i<4; i++) {
 627:layer1/prim_tch.c **** 			avg_snr += rx_tch_a.meas[i].snr;
 524              		.loc 1 627 0 discriminator 2
 525 0170 B010D3E1 		ldrh	r1, [r3, #0]
 526 0174 012082E0 		add	r2, r2, r1
 527              	.LVL46:
 628:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch_a.meas[i].pm_dbm8;
 528              		.loc 1 628 0 discriminator 2
 529 0178 F410D3E1 		ldrsh	r1, [r3, #4]
 530 017c 083083E2 		add	r3, r3, #8
 626:layer1/prim_tch.c **** 		for (i=0; i<4; i++) {
 531              		.loc 1 626 0 discriminator 2
 532 0180 050053E1 		cmp	r3, r5
 533              		.loc 1 628 0 discriminator 2
 534 0184 010080E0 		add	r0, r0, r1
 535              	.LVL47:
 626:layer1/prim_tch.c **** 		for (i=0; i<4; i++) {
 536              		.loc 1 626 0 discriminator 2
 537 0188 F8FFFF1A 		bne	.L36
 629:layer1/prim_tch.c **** 		}
 630:layer1/prim_tch.c **** 		rx_tch_a.dl->snr = avg_snr / 4;
 538              		.loc 1 630 0
 539 018c D4409FE5 		ldr	r4, .L41
 540              	.LVL48:
 631:layer1/prim_tch.c **** 		rx_tch_a.dl->rx_level = dbm2rxlev(avg_dbm8 / (8*4));
 541              		.loc 1 631 0
 542 0190 1F3080E2 		add	r3, r0, #31
 630:layer1/prim_tch.c **** 		rx_tch_a.dl->snr = avg_snr / 4;
 543              		.loc 1 630 0
 544 0194 285094E5 		ldr	r5, [r4, #40]
 545              		.loc 1 631 0
 546 0198 000050E3 		cmp	r0, #0
 547 019c 0300A0B1 		movlt	r0, r3
 548              	.LVL49:
 630:layer1/prim_tch.c **** 		rx_tch_a.dl->snr = avg_snr / 4;
 549              		.loc 1 630 0
 550 01a0 2221A0E1 		mov	r2, r2, lsr #2
 551              	.LVL50:
 552 01a4 0920C5E5 		strb	r2, [r5, #9]
 553              		.loc 1 631 0
 554 01a8 C002A0E1 		mov	r0, r0, asr #5
 555 01ac FEFFFFEB 		bl	dbm2rxlev
 556              	.LVL51:
 632:layer1/prim_tch.c **** 
 633:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_cd[2];
 557              		.loc 1 633 0
 558 01b0 C0309FE5 		ldr	r3, .L41+16
 631:layer1/prim_tch.c **** 		rx_tch_a.dl->rx_level = dbm2rxlev(avg_dbm8 / (8*4));
 559              		.loc 1 631 0
 560 01b4 0800C5E5 		strb	r0, [r5, #8]
 561              		.loc 1 633 0
 562 01b8 002093E5 		ldr	r2, [r3, #0]
 563 01bc 023CA0E3 		mov	r3, #512
 564 01c0 B33092E1 		ldrh	r3, [r2, r3]
 565              	.LVL52:
 634:layer1/prim_tch.c **** 		if (num_biterr > 0xff)
 566              		.loc 1 634 0
 567 01c4 FF0053E3 		cmp	r3, #255
 635:layer1/prim_tch.c **** 			rx_tch_a.dl->num_biterr = 0xff;
 568              		.loc 1 635 0
 569 01c8 28309485 		ldrhi	r3, [r4, #40]
 570              	.LVL53:
 636:layer1/prim_tch.c **** 		else
 637:layer1/prim_tch.c **** 			rx_tch_a.dl->num_biterr = num_biterr;
 571              		.loc 1 637 0
 572 01cc 28109495 		ldrls	r1, [r4, #40]
 635:layer1/prim_tch.c **** 			rx_tch_a.dl->num_biterr = 0xff;
 573              		.loc 1 635 0
 574 01d0 0010E083 		mvnhi	r1, #0
 575 01d4 0A10C385 		strhib	r1, [r3, #10]
 576              		.loc 1 637 0
 577 01d8 0A30C195 		strlsb	r3, [r1, #10]
 638:layer1/prim_tch.c **** 
 639:layer1/prim_tch.c **** 		rx_tch_a.dl->fire_crc = ((dsp_api.ndb->a_cd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> 
 578              		.loc 1 639 0
 579 01dc 7F5FA0E3 		mov	r5, #508
 580 01e0 80409FE5 		ldr	r4, .L41
 581 01e4 B52092E1 		ldrh	r2, [r2, r5]
 582 01e8 283094E5 		ldr	r3, [r4, #40]
 583 01ec 602002E2 		and	r2, r2, #96
 584 01f0 C222A0E1 		mov	r2, r2, asr #5
 640:layer1/prim_tch.c **** 
 641:layer1/prim_tch.c **** 		/* Update rx level for pm report */
 642:layer1/prim_tch.c **** 		pu_update_rx_level(rx_tch_a.dl->rx_level);
 643:layer1/prim_tch.c **** 
 644:layer1/prim_tch.c **** 		/* Copy actual data, skipping the information block [0,1,2] */
 645:layer1/prim_tch.c **** 		dsp_memcpy_from_api(rx_tch_a.di->data, &dsp_api.ndb->a_cd[3], 23, 0);
 585              		.loc 1 645 0
 586 01f4 7C609FE5 		ldr	r6, .L41+16
 639:layer1/prim_tch.c **** 		rx_tch_a.dl->fire_crc = ((dsp_api.ndb->a_cd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> 
 587              		.loc 1 639 0
 588 01f8 0B20C3E5 		strb	r2, [r3, #11]
 642:layer1/prim_tch.c **** 		pu_update_rx_level(rx_tch_a.dl->rx_level);
 589              		.loc 1 642 0
 590 01fc 0800D3E5 		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 591 0200 FEFFFFEB 		bl	pu_update_rx_level
 592              		.loc 1 645 0
 593 0204 001096E5 		ldr	r1, [r6, #0]
 594 0208 051081E0 		add	r1, r1, r5
 595 020c 061081E2 		add	r1, r1, #6
 596 0210 1720A0E3 		mov	r2, #23
 597 0214 0030A0E3 		mov	r3, #0
 598 0218 2C0094E5 		ldr	r0, [r4, #44]
 599 021c FEFFFFEB 		bl	dsp_memcpy_from_api
 646:layer1/prim_tch.c **** 
 647:layer1/prim_tch.c **** 		/* Give message to up layer */
 648:layer1/prim_tch.c **** 		l1_queue_for_l2(rx_tch_a.msg);
 600              		.loc 1 648 0
 601 0220 240094E5 		ldr	r0, [r4, #36]
 602 0224 FEFFFFEB 		bl	l1_queue_for_l2
 649:layer1/prim_tch.c **** 		rx_tch_a.msg = NULL; rx_tch_a.dl = NULL; rx_tch_a.di = NULL;
 603              		.loc 1 649 0
 604 0228 0030A0E3 		mov	r3, #0
 605 022c 243084E5 		str	r3, [r4, #36]
 606 0230 283084E5 		str	r3, [r4, #40]
 607 0234 2C3084E5 		str	r3, [r4, #44]
 650:layer1/prim_tch.c **** 
 651:layer1/prim_tch.c **** 		/* Reset header */
 652:layer1/prim_tch.c **** 		dsp_api.ndb->a_cd[0] = (1<<B_FIRE1);
 608              		.loc 1 652 0
 609 0238 003096E5 		ldr	r3, [r6, #0]
 610 023c 4020A0E3 		mov	r2, #64	@ movhi
 611 0240 B52083E1 		strh	r2, [r3, r5]	@ movhi
 653:layer1/prim_tch.c **** 		dsp_api.ndb->a_cd[2] = 0xffff;
 612              		.loc 1 653 0
 613 0244 0010E0E3 		mvn	r1, #0	@ movhi
 614 0248 022CA0E3 		mov	r2, #512
 615 024c B21083E1 		strh	r1, [r3, r2]	@ movhi
 616              	.LVL54:
 617              	.L33:
 618              	.LBE27:
 654:layer1/prim_tch.c **** 	}
 655:layer1/prim_tch.c **** 
 656:layer1/prim_tch.c **** skip:
 657:layer1/prim_tch.c **** 	/* mark READ page as being used */
 658:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 619              		.loc 1 658 0
 620 0250 20309FE5 		ldr	r3, .L41+16
 621 0254 0120A0E3 		mov	r2, #1
 622 0258 182083E5 		str	r2, [r3, #24]
 659:layer1/prim_tch.c **** 
 660:layer1/prim_tch.c **** 	return 0;
 661:layer1/prim_tch.c **** }
 623              		.loc 1 661 0
 624 025c 0000A0E3 		mov	r0, #0
 625 0260 20D08DE2 		add	sp, sp, #32
 626 0264 F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 627              	.L42:
 628              		.align	2
 629              	.L41:
 630 0268 00000000 		.word	.LANCHOR0
 631 026c 00000000 		.word	l1s
 632 0270 FF6F2900 		.word	2715647
 633 0274 00702900 		.word	2715648
 634 0278 00000000 		.word	dsp_api
 635 027c C0500100 		.word	86208
 636              		.cfi_endproc
 637              	.LFE72:
 639              		.section	.text.l1s_tch_d_cmd,"ax",%progbits
 640              		.align	2
 642              	l1s_tch_d_cmd:
 643              	.LFB71:
 518:layer1/prim_tch.c **** {
 644              		.loc 1 518 0
 645              		.cfi_startproc
 646              		@ args = 0, pretend = 0, frame = 12
 647              		@ frame_needed = 0, uses_anonymous_args = 0
 648              	.LVL55:
 649 0000 10402DE9 		stmfd	sp!, {r4, lr}
 650              	.LCFI6:
 651              		.cfi_def_cfa_offset 8
 652 0004 0228A0E1 		mov	r2, r2, asl #16
 653              	.LVL56:
 654 0008 18D04DE2 		sub	sp, sp, #24
 655              	.LCFI7:
 656              		.cfi_def_cfa_offset 32
 526:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, NULL, &tsc, &tn);
 657              		.loc 1 526 0
 658 000c 16308DE2 		add	r3, sp, #22
 518:layer1/prim_tch.c **** {
 659              		.loc 1 518 0
 660 0010 2248A0E1 		mov	r4, r2, lsr #16
 661              		.cfi_offset 14, -4
 662              		.cfi_offset 4, -8
 663              	.LVL57:
 526:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, NULL, &tsc, &tn);
 664              		.loc 1 526 0
 665 0014 98009FE5 		ldr	r0, .L46
 666              	.LVL58:
 667 0018 17208DE2 		add	r2, sp, #23
 668 001c 0010A0E3 		mov	r1, #0
 669              	.LVL59:
 670 0020 FEFFFFEB 		bl	rfch_get_params
 671              	.LVL60:
 527:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 672              		.loc 1 527 0
 673 0024 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 674 0028 FF0004E2 		and	r0, r4, #255
 675 002c FEFFFFEB 		bl	mframe_task2chan_nr
 528:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 676              		.loc 1 528 0
 677 0030 14308DE2 		add	r3, sp, #20
 678 0034 00308DE5 		str	r3, [sp, #0]
 679 0038 13308DE2 		add	r3, sp, #19
 527:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 680              		.loc 1 527 0
 681 003c 0010A0E1 		mov	r1, r0
 682              	.LVL61:
 528:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 683              		.loc 1 528 0
 684 0040 04308DE5 		str	r3, [sp, #4]
 685 0044 0C208DE2 		add	r2, sp, #12
 686 0048 15308DE2 		add	r3, sp, #21
 687 004c 60009FE5 		ldr	r0, .L46
 688              	.LVL62:
 689 0050 FEFFFFEB 		bl	tch_get_params.clone.0
 690              	.LVL63:
 531:layer1/prim_tch.c **** 	dsp_load_tch_param(
 691              		.loc 1 531 0
 692 0054 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 693              	.LVL64:
 694 0058 0040A0E3 		mov	r4, #0
 695              	.LVL65:
 696 005c 1600DDE5 		ldrb	r0, [sp, #22]	@ zero_extendqisi2
 697              	.LVL66:
 698 0060 040052E1 		cmp	r2, r4
 699              	.LVL67:
 700 0064 0220A003 		moveq	r2, #2
 701              	.LVL68:
 702 0068 0120A013 		movne	r2, #1
 703              	.LVL69:
 704 006c 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 705              	.LVL70:
 706 0070 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 707 0074 08008DE5 		str	r0, [sp, #8]
 708              	.LVL71:
 709 0078 34009FE5 		ldr	r0, .L46
 710              	.LVL72:
 711 007c 00408DE5 		str	r4, [sp, #0]
 712 0080 04408DE5 		str	r4, [sp, #4]
 713 0084 FEFFFFEB 		bl	dsp_load_tch_param
 537:layer1/prim_tch.c **** 	dsp_load_rx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 714              		.loc 1 537 0
 715 0088 0410A0E1 		mov	r1, r4
 716              	.LVL73:
 717 008c 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 718 0090 1C00A0E3 		mov	r0, #28
 719 0094 FEFFFFEB 		bl	dsp_load_rx_task
 538:layer1/prim_tch.c **** 	dsp_load_tx_task(TCHD_DSP_TASK, 0, tsc); /* burst_id unused for TCH */
 720              		.loc 1 538 0
 721 0098 1C00A0E3 		mov	r0, #28
 722 009c 0410A0E1 		mov	r1, r4
 723 00a0 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 724 00a4 FEFFFFEB 		bl	dsp_load_tx_task
 541:layer1/prim_tch.c **** }
 725              		.loc 1 541 0
 726 00a8 0400A0E1 		mov	r0, r4
 727 00ac 18D08DE2 		add	sp, sp, #24
 728 00b0 1080BDE8 		ldmfd	sp!, {r4, pc}
 729              	.L47:
 730              		.align	2
 731              	.L46:
 732 00b4 0C000000 		.word	l1s+12
 733              		.cfi_endproc
 734              	.LFE71:
 736              		.global	__divsi3
 737              		.section	.text.l1s_tch_resp,"ax",%progbits
 738              		.align	2
 740              	l1s_tch_resp:
 741              	.LFB68:
 158:layer1/prim_tch.c **** {
 742              		.loc 1 158 0
 743              		.cfi_startproc
 744              		@ args = 0, pretend = 0, frame = 24
 745              		@ frame_needed = 0, uses_anonymous_args = 0
 746              	.LVL74:
 747 0000 F0412DE9 		stmfd	sp!, {r4, r5, r6, r7, r8, lr}
 748              	.LCFI8:
 749              		.cfi_def_cfa_offset 24
 170:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 750              		.loc 1 170 0
 751 0004 48349FE5 		ldr	r3, .L72
 752 0008 48049FE5 		ldr	r0, .L72+4
 753              	.LVL75:
 754 000c 003093E5 		ldr	r3, [r3, #0]
 158:layer1/prim_tch.c **** {
 755              		.loc 1 158 0
 756 0010 20D04DE2 		sub	sp, sp, #32
 757              	.LCFI9:
 758              		.cfi_def_cfa_offset 56
 158:layer1/prim_tch.c **** {
 759              		.loc 1 158 0
 760 0014 0228A0E1 		mov	r2, r2, asl #16
 761              	.LVL76:
 170:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 762              		.loc 1 170 0
 763 0018 000083E0 		add	r0, r3, r0
 764 001c 38149FE5 		ldr	r1, .L72+8
 765              	.LVL77:
 158:layer1/prim_tch.c **** {
 766              		.loc 1 158 0
 767 0020 2258A0E1 		mov	r5, r2, lsr #16
 768              		.cfi_offset 14, -4
 769              		.cfi_offset 8, -8
 770              		.cfi_offset 7, -12
 771              		.cfi_offset 6, -16
 772              		.cfi_offset 5, -20
 773              		.cfi_offset 4, -24
 774              	.LVL78:
 170:layer1/prim_tch.c **** 	gsm_fn2gsmtime(&rx_time, (l1s.current_time.fn - 1 + GSM_MAX_FN) % GSM_MAX_FN);
 775              		.loc 1 170 0
 776 0024 FEFFFFEB 		bl	__umodsi3
 777 0028 08408DE2 		add	r4, sp, #8
 778 002c 0010A0E1 		mov	r1, r0
 779 0030 0400A0E1 		mov	r0, r4
 780 0034 FEFFFFEB 		bl	gsm_fn2gsmtime
 171:layer1/prim_tch.c **** 	rfch_get_params(&rx_time, &arfcn, &tsc, &tn);
 781              		.loc 1 171 0
 782 0038 0400A0E1 		mov	r0, r4
 783 003c 1F208DE2 		add	r2, sp, #31
 784 0040 1E308DE2 		add	r3, sp, #30
 785 0044 1A108DE2 		add	r1, sp, #26
 786 0048 FEFFFFEB 		bl	rfch_get_params
 172:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 787              		.loc 1 172 0
 788 004c FF0005E2 		and	r0, r5, #255
 789              	.LVL79:
 790 0050 1E10DDE5 		ldrb	r1, [sp, #30]	@ zero_extendqisi2
 791 0054 FEFFFFEB 		bl	mframe_task2chan_nr
 173:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 792              		.loc 1 173 0
 793 0058 1C308DE2 		add	r3, sp, #28
 172:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 794              		.loc 1 172 0
 795 005c 0050A0E1 		mov	r5, r0
 796              	.LVL80:
 173:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 797              		.loc 1 173 0
 798 0060 0400A0E1 		mov	r0, r4
 799              	.LVL81:
 175:layer1/prim_tch.c **** 	meas_id = (meas_id + 1) % FACCH_MEAS_HIST; /* absolute value doesn't matter */
 800              		.loc 1 175 0
 801 0064 F4439FE5 		ldr	r4, .L72+12
 173:layer1/prim_tch.c **** 	tch_get_params(&rx_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, NULL);
 802              		.loc 1 173 0
 803 0068 0060A0E3 		mov	r6, #0
 804 006c 14208DE2 		add	r2, sp, #20
 805 0070 00308DE5 		str	r3, [sp, #0]
 806 0074 0510A0E1 		mov	r1, r5
 807 0078 1D308DE2 		add	r3, sp, #29
 808 007c 04608DE5 		str	r6, [sp, #4]
 809 0080 FEFFFFEB 		bl	tch_get_params.clone.0
 175:layer1/prim_tch.c **** 	meas_id = (meas_id + 1) % FACCH_MEAS_HIST; /* absolute value doesn't matter */
 810              		.loc 1 175 0
 811 0084 3080D4E5 		ldrb	r8, [r4, #48]	@ zero_extendqisi2
 178:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 812              		.loc 1 178 0
 813 0088 D4739FE5 		ldr	r7, .L72+16
 175:layer1/prim_tch.c **** 	meas_id = (meas_id + 1) % FACCH_MEAS_HIST; /* absolute value doesn't matter */
 814              		.loc 1 175 0
 815 008c 018088E2 		add	r8, r8, #1
 816 0090 078008E2 		and	r8, r8, #7
 817 0094 3080C4E5 		strb	r8, [r4, #48]
 178:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 818              		.loc 1 178 0
 819 0098 043097E5 		ldr	r3, [r7, #4]
 820 009c B011D3E1 		ldrh	r1, [r3, #16]
 180:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 821              		.loc 1 180 0
 822 00a0 B201D3E1 		ldrh	r0, [r3, #18]
 178:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].toa_qbit = dsp_api.db_r->a_serv_demod[D_TOA];
 823              		.loc 1 178 0
 824 00a4 888184E0 		add	r8, r4, r8, asl #3
 825 00a8 B613C8E1 		strh	r1, [r8, #54]	@ movhi
 180:layer1/prim_tch.c **** 		agc_inp_dbm8_by_pm(dsp_api.db_r->a_serv_demod[D_PM] >> 3);
 826              		.loc 1 180 0
 827 00ac A001A0E1 		mov	r0, r0, lsr #3
 828 00b0 FEFFFFEB 		bl	agc_inp_dbm8_by_pm
 182:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 829              		.loc 1 182 0
 830 00b4 041097E5 		ldr	r1, [r7, #4]
 181:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].freq_err =
 831              		.loc 1 181 0
 832 00b8 3030D4E5 		ldrb	r3, [r4, #48]	@ zero_extendqisi2
 179:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].pm_dbm8 =
 833              		.loc 1 179 0
 834 00bc B803C8E1 		strh	r0, [r8, #56]	@ movhi
 181:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].freq_err =
 835              		.loc 1 181 0
 836 00c0 834184E0 		add	r4, r4, r3, asl #3
 182:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 837              		.loc 1 182 0
 838 00c4 9C039FE5 		ldr	r0, .L72+20
 839 00c8 F431D1E1 		ldrsh	r3, [r1, #20]
 840 00cc 900303E0 		mul	r3, r0, r3
 841 00d0 FF0C83E2 		add	r0, r3, #65280
 842 00d4 060053E1 		cmp	r3, r6
 843 00d8 FF3080B2 		addlt	r3, r0, #255
 181:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].freq_err =
 844              		.loc 1 181 0
 845 00dc 382084E2 		add	r2, r4, #56
 182:layer1/prim_tch.c **** 		ANGLE_TO_FREQ(dsp_api.db_r->a_serv_demod[D_ANGLE]);
 846              		.loc 1 182 0
 847 00e0 4338A0E1 		mov	r3, r3, asr #16
 181:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].freq_err =
 848              		.loc 1 181 0
 849 00e4 B230C2E1 		strh	r3, [r2, #2]	@ movhi
 183:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 850              		.loc 1 183 0
 851 00e8 B631D1E1 		ldrh	r3, [r1, #22]
 186:layer1/prim_tch.c **** 	if (rx_tch.meas[meas_id].snr > AFC_SNR_THRESHOLD)
 852              		.loc 1 186 0
 853 00ec 0A0C53E3 		cmp	r3, #2560
 183:layer1/prim_tch.c **** 	rx_tch.meas[meas_id].snr = dsp_api.db_r->a_serv_demod[D_SNR];
 854              		.loc 1 183 0
 855 00f0 B433C4E1 		strh	r3, [r4, #52]	@ movhi
 192:layer1/prim_tch.c **** 	toa_input(rx_tch.meas[meas_id].toa_qbit << 2, rx_tch.meas[meas_id].snr);
 856              		.loc 1 192 0
 857 00f4 64439FE5 		ldr	r4, .L72+12
 858 00f8 F200D2E1 		ldrsh	r0, [r2, #2]
 859              	.LVL82:
 860 00fc BA11DDE1 		ldrh	r1, [sp, #26]
 861              	.LVL83:
 187:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 1);
 862              		.loc 1 187 0
 863 0100 0120A083 		movhi	r2, #1
 189:layer1/prim_tch.c **** 		afc_input(rx_tch.meas[meas_id].freq_err, arfcn, 0);
 864              		.loc 1 189 0
 865 0104 0620A091 		movls	r2, r6
 866 0108 FEFFFFEB 		bl	afc_input
 192:layer1/prim_tch.c **** 	toa_input(rx_tch.meas[meas_id].toa_qbit << 2, rx_tch.meas[meas_id].snr);
 867              		.loc 1 192 0
 868 010c 3030D4E5 		ldrb	r3, [r4, #48]	@ zero_extendqisi2
 869 0110 833184E0 		add	r3, r4, r3, asl #3
 870 0114 F603D3E1 		ldrsh	r0, [r3, #54]
 871 0118 B413D3E1 		ldrh	r1, [r3, #52]
 872 011c 0001A0E1 		mov	r0, r0, asl #2
 873 0120 FEFFFFEB 		bl	toa_input
 195:layer1/prim_tch.c **** 	rffe_compute_gain(rx_tch.meas[meas_id].pm_dbm8 / 8,
 874              		.loc 1 195 0
 875 0124 3030D4E5 		ldrb	r3, [r4, #48]	@ zero_extendqisi2
 876 0128 834184E0 		add	r4, r4, r3, asl #3
 877 012c F803D4E1 		ldrsh	r0, [r4, #56]
 878 0130 073080E2 		add	r3, r0, #7
 879 0134 000050E3 		cmp	r0, #0
 880 0138 0300A0B1 		movlt	r0, r3
 881 013c C001A0E1 		mov	r0, r0, asr #3
 882 0140 5010A0E3 		mov	r1, #80
 883 0144 FEFFFFEB 		bl	rffe_compute_gain
 884              	.LVL84:
 199:layer1/prim_tch.c **** 	if (tch_f_hn) {
 885              		.loc 1 199 0
 886 0148 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 887              	.LVL85:
 888 014c 000053E3 		cmp	r3, #0
 889              	.LVL86:
 890 0150 0500000A 		beq	.L51
 201:layer1/prim_tch.c **** 		facch_rx_now = ((rx_time.fn % 13) % 4) == 3;
 891              		.loc 1 201 0
 892 0154 08009DE5 		ldr	r0, [sp, #8]
 893 0158 0D10A0E3 		mov	r1, #13
 894 015c FEFFFFEB 		bl	__umodsi3
 895              	.LVL87:
 896 0160 030000E2 		and	r0, r0, #3
 210:layer1/prim_tch.c **** 	if (facch_rx_now && (dsp_api.ndb->a_fd[0] & (1<<B_BLUD))) {
 897              		.loc 1 210 0
 898 0164 030050E3 		cmp	r0, #3
 899 0168 070000EA 		b	.L71
 900              	.LVL88:
 901              	.L51:
 902              	.LBB28:
 204:layer1/prim_tch.c **** 		uint8_t t2_norm = rx_time.t2 - tch_sub;
 903              		.loc 1 204 0
 904 016c 0E20DDE5 		ldrb	r2, [sp, #14]	@ zero_extendqisi2
 905              	.LVL89:
 906 0170 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 907              	.LVL90:
 908 0174 023063E0 		rsb	r3, r3, r2
 909              	.LVL91:
 910 0178 FF3003E2 		and	r3, r3, #255
 911              	.LVL92:
 205:layer1/prim_tch.c **** 		facch_rx_now = (t2_norm == 15) ||
 912              		.loc 1 205 0
 913 017c 0F0053E3 		cmp	r3, #15
 914 0180 17005313 		cmpne	r3, #23
 915 0184 0100000A 		beq	.L52
 206:layer1/prim_tch.c **** 		               (t2_norm == 23) ||
 916              		.loc 1 206 0
 917 0188 060053E3 		cmp	r3, #6
 918              	.LVL93:
 919              	.L71:
 920 018c 6A00001A 		bne	.L53
 921              	.L52:
 922              	.LBE28:
 210:layer1/prim_tch.c **** 	if (facch_rx_now && (dsp_api.ndb->a_fd[0] & (1<<B_BLUD))) {
 923              		.loc 1 210 0 discriminator 1
 924 0190 CC329FE5 		ldr	r3, .L72+16
 925 0194 002093E5 		ldr	r2, [r3, #0]
 926 0198 CC329FE5 		ldr	r3, .L72+24
 927 019c F33092E1 		ldrsh	r3, [r2, r3]
 928 01a0 000053E3 		cmp	r3, #0
 929 01a4 640000AA 		bge	.L53
 930              	.LVL94:
 931              	.LBB29:
 221:layer1/prim_tch.c **** 		msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 932              		.loc 1 221 0
 933 01a8 0300A0E3 		mov	r0, #3
 934 01ac FEFFFFEB 		bl	l1ctl_msgb_alloc
 935              	.LVL95:
 222:layer1/prim_tch.c **** 		if(!msg) {
 936              		.loc 1 222 0
 937 01b0 004050E2 		subs	r4, r0, #0
 938 01b4 0200001A 		bne	.L54
 223:layer1/prim_tch.c **** 			printf("TCH FACCH: unable to allocate msgb\n");
 939              		.loc 1 223 0
 940 01b8 B0029FE5 		ldr	r0, .L72+28
 941              	.LVL96:
 942 01bc FEFFFFEB 		bl	puts
 224:layer1/prim_tch.c **** 			goto skip_rx_facch;
 943              		.loc 1 224 0
 944 01c0 490000EA 		b	.L55
 945              	.L54:
 227:layer1/prim_tch.c **** 		dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 946              		.loc 1 227 0
 947 01c4 0C10A0E3 		mov	r1, #12
 948 01c8 FEFFFFEB 		bl	msgb_put
 228:layer1/prim_tch.c **** 		di = (struct l1ctl_data_ind *) msgb_put(msg, sizeof(*di));
 949              		.loc 1 228 0
 950 01cc 1710A0E3 		mov	r1, #23
 227:layer1/prim_tch.c **** 		dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 951              		.loc 1 227 0
 952 01d0 0060A0E1 		mov	r6, r0
 953              	.LVL97:
 228:layer1/prim_tch.c **** 		di = (struct l1ctl_data_ind *) msgb_put(msg, sizeof(*di));
 954              		.loc 1 228 0
 955 01d4 0400A0E1 		mov	r0, r4
 956              	.LVL98:
 957 01d8 FEFFFFEB 		bl	msgb_put
 232:layer1/prim_tch.c **** 		dl->link_id = 0x00;	/* FACCH */
 958              		.loc 1 232 0
 959 01dc 0070A0E3 		mov	r7, #0
 231:layer1/prim_tch.c **** 		dl->chan_nr = chan_nr;
 960              		.loc 1 231 0
 961 01e0 0050C6E5 		strb	r5, [r6, #0]
 232:layer1/prim_tch.c **** 		dl->link_id = 0x00;	/* FACCH */
 962              		.loc 1 232 0
 963 01e4 0170C6E5 		strb	r7, [r6, #1]
 964              	.LVL99:
 233:layer1/prim_tch.c **** 		dl->band_arfcn = htons(arfcn);
 965              		.loc 1 233 0
 966 01e8 BA31DDE1 		ldrh	r3, [sp, #26]
 967              	.LBB30:
 968              	.LBB31:
  51:include/swab.h **** 	return ___constant_swab16(val);
 969              		.loc 2 51 0
 970 01ec 2324A0E1 		mov	r2, r3, lsr #8
 971 01f0 033482E1 		orr	r3, r2, r3, asl #8
 972              	.LBE31:
 973              	.LBE30:
 233:layer1/prim_tch.c **** 		dl->band_arfcn = htons(arfcn);
 974              		.loc 1 233 0
 975 01f4 0230C6E5 		strb	r3, [r6, #2]
 976 01f8 2334A0E1 		mov	r3, r3, lsr #8
 977 01fc 0330C6E5 		strb	r3, [r6, #3]
 228:layer1/prim_tch.c **** 		di = (struct l1ctl_data_ind *) msgb_put(msg, sizeof(*di));
 978              		.loc 1 228 0
 979 0200 0080A0E1 		mov	r8, r0
 980              	.LVL100:
 234:layer1/prim_tch.c **** 		dl->frame_nr = htonl(rx_time.fn);
 981              		.loc 1 234 0
 982 0204 08009DE5 		ldr	r0, [sp, #8]
 983              	.LVL101:
 984 0208 FEFFFFEB 		bl	__fswab32
 985 020c 2034A0E1 		mov	r3, r0, lsr #8
 986 0210 0400C6E5 		strb	r0, [r6, #4]
 987 0214 0530C6E5 		strb	r3, [r6, #5]
 988 0218 2038A0E1 		mov	r3, r0, lsr #16
 989 021c 200CA0E1 		mov	r0, r0, lsr #24
 990 0220 0630C6E5 		strb	r3, [r6, #6]
 991 0224 0700C6E5 		strb	r0, [r6, #7]
 992              	.LBB32:
 239:layer1/prim_tch.c **** 			int j = (meas_id + FACCH_MEAS_HIST - i) % FACCH_MEAS_HIST;
 993              		.loc 1 239 0
 994 0228 30129FE5 		ldr	r1, .L72+12
 995              	.LVL102:
 996              	.LBE32:
 237:layer1/prim_tch.c **** 		n = tch_f_hn ? 8 : 6;
 997              		.loc 1 237 0
 998 022c 1D50DDE5 		ldrb	r5, [sp, #29]	@ zero_extendqisi2
 999              	.LVL103:
 1000              	.LBB33:
 239:layer1/prim_tch.c **** 			int j = (meas_id + FACCH_MEAS_HIST - i) % FACCH_MEAS_HIST;
 1001              		.loc 1 239 0
 1002 0230 3020D1E5 		ldrb	r2, [r1, #48]	@ zero_extendqisi2
 1003              	.LBE33:
 237:layer1/prim_tch.c **** 		n = tch_f_hn ? 8 : 6;
 1004              		.loc 1 237 0
 1005 0234 070055E1 		cmp	r5, r7
 1006              	.LVL104:
 1007 0238 0650A003 		moveq	r5, #6
 1008              	.LVL105:
 1009 023c 0850A013 		movne	r5, #8
 1010              	.LVL106:
 1011              	.LBB34:
 239:layer1/prim_tch.c **** 			int j = (meas_id + FACCH_MEAS_HIST - i) % FACCH_MEAS_HIST;
 1012              		.loc 1 239 0
 1013 0240 082082E2 		add	r2, r2, #8
 238:layer1/prim_tch.c **** 		for (i=0; i<n; i++) {
 1014              		.loc 1 238 0
 1015 0244 0730A0E1 		mov	r3, r7
 215:layer1/prim_tch.c **** 		uint32_t avg_snr = 0;
 1016              		.loc 1 215 0
 1017 0248 0700A0E1 		mov	r0, r7
 1018              	.LVL107:
 1019              	.L57:
 239:layer1/prim_tch.c **** 			int j = (meas_id + FACCH_MEAS_HIST - i) % FACCH_MEAS_HIST;
 1020              		.loc 1 239 0 discriminator 2
 1021 024c 07C002E2 		and	ip, r2, #7
 1022              	.LVL108:
 240:layer1/prim_tch.c **** 			avg_snr += rx_tch.meas[j].snr;
 1023              		.loc 1 240 0 discriminator 2
 1024 0250 8CC181E0 		add	ip, r1, ip, asl #3
 1025              	.LVL109:
 1026 0254 B4E3DCE1 		ldrh	lr, [ip, #52]
 1027              	.LBE34:
 238:layer1/prim_tch.c **** 		for (i=0; i<n; i++) {
 1028              		.loc 1 238 0 discriminator 2
 1029 0258 013083E2 		add	r3, r3, #1
 1030              	.LBB35:
 241:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch.meas[j].pm_dbm8;
 1031              		.loc 1 241 0 discriminator 2
 1032 025c F8C3DCE1 		ldrsh	ip, [ip, #56]
 1033              	.LBE35:
 238:layer1/prim_tch.c **** 		for (i=0; i<n; i++) {
 1034              		.loc 1 238 0 discriminator 2
 1035 0260 050053E1 		cmp	r3, r5
 1036              	.LBB36:
 240:layer1/prim_tch.c **** 			avg_snr += rx_tch.meas[j].snr;
 1037              		.loc 1 240 0 discriminator 2
 1038 0264 0E0080E0 		add	r0, r0, lr
 1039              	.LVL110:
 241:layer1/prim_tch.c **** 			avg_dbm8 += rx_tch.meas[j].pm_dbm8;
 1040              		.loc 1 241 0 discriminator 2
 1041 0268 0C7087E0 		add	r7, r7, ip
 1042              	.LVL111:
 1043              	.LBE36:
 238:layer1/prim_tch.c **** 		for (i=0; i<n; i++) {
 1044              		.loc 1 238 0 discriminator 2
 1045 026c 012042E2 		sub	r2, r2, #1
 1046 0270 F5FFFFBA 		blt	.L57
 244:layer1/prim_tch.c **** 		dl->snr = avg_snr / n;
 1047              		.loc 1 244 0
 1048 0274 0510A0E1 		mov	r1, r5
 1049 0278 FEFFFFEB 		bl	__udivsi3
 1050              	.LVL112:
 245:layer1/prim_tch.c **** 		dl->rx_level = dbm2rxlev(avg_dbm8 / (8*n));
 1051              		.loc 1 245 0
 1052 027c 8511A0E1 		mov	r1, r5, asl #3
 244:layer1/prim_tch.c **** 		dl->snr = avg_snr / n;
 1053              		.loc 1 244 0
 1054 0280 0900C6E5 		strb	r0, [r6, #9]
 245:layer1/prim_tch.c **** 		dl->rx_level = dbm2rxlev(avg_dbm8 / (8*n));
 1055              		.loc 1 245 0
 1056 0284 0700A0E1 		mov	r0, r7
 1057 0288 FEFFFFEB 		bl	__divsi3
 1058 028c FEFFFFEB 		bl	dbm2rxlev
 248:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_fd[2] & 0xffff;
 1059              		.loc 1 248 0
 1060 0290 CC319FE5 		ldr	r3, .L72+16
 245:layer1/prim_tch.c **** 		dl->rx_level = dbm2rxlev(avg_dbm8 / (8*n));
 1061              		.loc 1 245 0
 1062 0294 0800C6E5 		strb	r0, [r6, #8]
 248:layer1/prim_tch.c **** 		num_biterr = dsp_api.ndb->a_fd[2] & 0xffff;
 1063              		.loc 1 248 0
 1064 0298 D4219FE5 		ldr	r2, .L72+32
 1065 029c 003093E5 		ldr	r3, [r3, #0]
 1066 02a0 B22093E1 		ldrh	r2, [r3, r2]
 1067              	.LVL113:
 249:layer1/prim_tch.c **** 		if (num_biterr > 0xff)
 1068              		.loc 1 249 0
 1069 02a4 FF0052E3 		cmp	r2, #255
 250:layer1/prim_tch.c **** 			dl->num_biterr = 0xff;
 1070              		.loc 1 250 0
 1071 02a8 0020E083 		mvnhi	r2, #0
 1072              	.LVL114:
 252:layer1/prim_tch.c **** 			dl->num_biterr = num_biterr;
 1073              		.loc 1 252 0
 1074 02ac 0A20C6E5 		strb	r2, [r6, #10]
 254:layer1/prim_tch.c **** 		dl->fire_crc = ((dsp_api.ndb->a_fd[0] & 0xffff) & ((1 << B_FIRE1) | (1 << B_FIRE0))) >> B_FIRE0;
 1075              		.loc 1 254 0
 1076 02b0 B4219FE5 		ldr	r2, .L72+24
 1077 02b4 B23093E1 		ldrh	r3, [r3, r2]
 1078 02b8 603003E2 		and	r3, r3, #96
 1079 02bc C332A0E1 		mov	r3, r3, asr #5
 1080 02c0 0B30C6E5 		strb	r3, [r6, #11]
 257:layer1/prim_tch.c **** 		pu_update_rx_level(dl->rx_level);
 1081              		.loc 1 257 0
 1082 02c4 FEFFFFEB 		bl	pu_update_rx_level
 260:layer1/prim_tch.c **** 		dsp_memcpy_from_api(di->data, &dsp_api.ndb->a_fd[3], 23, 0);
 1083              		.loc 1 260 0
 1084 02c8 94319FE5 		ldr	r3, .L72+16
 1085 02cc 001093E5 		ldr	r1, [r3, #0]
 1086 02d0 0800A0E1 		mov	r0, r8
 1087 02d4 221E81E2 		add	r1, r1, #544
 1088 02d8 1720A0E3 		mov	r2, #23
 1089 02dc 0030A0E3 		mov	r3, #0
 1090 02e0 FEFFFFEB 		bl	dsp_memcpy_from_api
 263:layer1/prim_tch.c **** 		l1_queue_for_l2(msg);
 1091              		.loc 1 263 0
 1092 02e4 0400A0E1 		mov	r0, r4
 1093 02e8 FEFFFFEB 		bl	l1_queue_for_l2
 1094              	.LVL115:
 1095              	.L55:
 268:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[0] = (1<<B_FIRE1);
 1096              		.loc 1 268 0
 1097 02ec 70319FE5 		ldr	r3, .L72+16
 1098 02f0 74219FE5 		ldr	r2, .L72+24
 1099 02f4 003093E5 		ldr	r3, [r3, #0]
 1100 02f8 4010A0E3 		mov	r1, #64	@ movhi
 1101 02fc B21083E1 		strh	r1, [r3, r2]	@ movhi
 269:layer1/prim_tch.c **** 		dsp_api.ndb->a_fd[2] = 0xffff;
 1102              		.loc 1 269 0
 1103 0300 042082E2 		add	r2, r2, #4
 1104 0304 0010E0E3 		mvn	r1, #0	@ movhi
 1105 0308 B21083E1 		strh	r1, [r3, r2]	@ movhi
 272:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[0] = 0;
 1106              		.loc 1 272 0
 1107 030c 1A2082E2 		add	r2, r2, #26
 1108 0310 0010A0E3 		mov	r1, #0	@ movhi
 1109 0314 B21083E1 		strh	r1, [r3, r2]	@ movhi
 273:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_0[2] = 0xffff;
 1110              		.loc 1 273 0
 1111 0318 042082E2 		add	r2, r2, #4
 1112 031c 0010E0E3 		mvn	r1, #0	@ movhi
 1113 0320 B21083E1 		strh	r1, [r3, r2]	@ movhi
 276:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[0] = 0;
 1114              		.loc 1 276 0
 1115 0324 4D2F42E2 		sub	r2, r2, #308
 1116 0328 0010A0E3 		mov	r1, #0	@ movhi
 1117 032c B21083E1 		strh	r1, [r3, r2]	@ movhi
 277:layer1/prim_tch.c **** 		dsp_api.ndb->a_dd_1[2] = 0xffff;
 1118              		.loc 1 277 0
 1119 0330 042082E2 		add	r2, r2, #4
 1120 0334 0010E0E3 		mvn	r1, #0	@ movhi
 1121 0338 B21083E1 		strh	r1, [r3, r2]	@ movhi
 1122              	.LVL116:
 1123              	.L53:
 1124              	.LBE29:
 281:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1125              		.loc 1 281 0
 1126 033c 1D30DDE5 		ldrb	r3, [sp, #29]	@ zero_extendqisi2
 1127              	.LVL117:
 1128 0340 000053E3 		cmp	r3, #0
 1129              	.LVL118:
 1130 0344 08009DE5 		ldr	r0, [sp, #8]
 1131 0348 0600000A 		beq	.L60
 283:layer1/prim_tch.c **** 		traffic_rx_now = ((rx_time.fn % 13) % 4) == 3;
 1132              		.loc 1 283 0
 1133 034c 0D10A0E3 		mov	r1, #13
 1134 0350 FEFFFFEB 		bl	__umodsi3
 1135              	.LVL119:
 1136 0354 030000E2 		and	r0, r0, #3
 1137 0358 030050E3 		cmp	r0, #3
 1138 035c 0000A013 		movne	r0, #0
 1139 0360 0100A003 		moveq	r0, #1
 1140              	.LVL120:
 1141 0364 080000EA 		b	.L61
 1142              	.LVL121:
 1143              	.L60:
 287:layer1/prim_tch.c **** 		traffic_rx_now = (((rx_time.fn - tch_sub + 13) % 13) % 4) == 2;
 1144              		.loc 1 287 0
 1145 0368 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 1146              	.LVL122:
 1147 036c 0D0080E2 		add	r0, r0, #13
 1148 0370 000063E0 		rsb	r0, r3, r0
 1149              	.LVL123:
 1150 0374 0D10A0E3 		mov	r1, #13
 1151 0378 FEFFFFEB 		bl	__umodsi3
 1152              	.LVL124:
 1153 037c 030000E2 		and	r0, r0, #3
 1154 0380 020050E3 		cmp	r0, #2
 1155 0384 0000A013 		movne	r0, #0
 1156 0388 0100A003 		moveq	r0, #1
 1157              	.LVL125:
 1158              	.L61:
 290:layer1/prim_tch.c **** 	if (traffic_rx_now) {
 1159              		.loc 1 290 0
 1160 038c 000050E3 		cmp	r0, #0
 1161 0390 2900000A 		beq	.L62
 1162              	.LVL126:
 1163              	.LBB37:
 293:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_dd_1 : dsp_api.ndb->a_dd_0;
 1164              		.loc 1 293 0
 1165 0394 1C30DDE5 		ldrb	r3, [sp, #28]	@ zero_extendqisi2
 1166              	.LVL127:
 1167 0398 000053E3 		cmp	r3, #0
 1168              	.LVL128:
 1169 039c C0309FE5 		ldr	r3, .L72+16
 1170              	.LVL129:
 1171 03a0 00409315 		ldrne	r4, [r3, #0]
 1172 03a4 00409305 		ldreq	r4, [r3, #0]
 1173 03a8 424F8412 		addne	r4, r4, #264
 1174 03ac 8E4F8402 		addeq	r4, r4, #568
 1175              	.LVL130:
 295:layer1/prim_tch.c **** 		if (traffic_buf[0] & (1<<B_BLUD)) {
 1176              		.loc 1 295 0
 1177 03b0 B030D4E1 		ldrh	r3, [r4, #0]
 1178 03b4 020913E3 		tst	r3, #32768
 1179 03b8 1F00000A 		beq	.L62
 297:layer1/prim_tch.c **** 			if ((l1s.audio_mode & AUDIO_RX_TRAFFIC_IND) &&
 1180              		.loc 1 297 0
 1181 03bc 90309FE5 		ldr	r3, .L72
 1182 03c0 4C3AD3E5 		ldrb	r3, [r3, #2636]	@ zero_extendqisi2
 1183 03c4 080013E3 		tst	r3, #8
 1184 03c8 1700000A 		beq	.L65
 298:layer1/prim_tch.c **** 			    !(dsp_api.ndb->a_dd_0[0] & (1<<B_BFI))) {
 1185              		.loc 1 298 0 discriminator 1
 1186 03cc 90309FE5 		ldr	r3, .L72+16
 1187 03d0 002093E5 		ldr	r2, [r3, #0]
 1188 03d4 8E3FA0E3 		mov	r3, #568
 1189 03d8 B33092E1 		ldrh	r3, [r2, r3]
 297:layer1/prim_tch.c **** 			if ((l1s.audio_mode & AUDIO_RX_TRAFFIC_IND) &&
 1190              		.loc 1 297 0 discriminator 1
 1191 03dc 040013E3 		tst	r3, #4
 1192 03e0 1100001A 		bne	.L65
 1193              	.LBB38:
 305:layer1/prim_tch.c **** 				msg = l1ctl_msgb_alloc(L1CTL_TRAFFIC_IND);
 1194              		.loc 1 305 0
 1195 03e4 1E00A0E3 		mov	r0, #30
 1196              	.LVL131:
 1197 03e8 FEFFFFEB 		bl	l1ctl_msgb_alloc
 1198              	.LVL132:
 306:layer1/prim_tch.c **** 				if(!msg) {
 1199              		.loc 1 306 0
 1200 03ec 005050E2 		subs	r5, r0, #0
 1201 03f0 0200001A 		bne	.L66
 307:layer1/prim_tch.c **** 					printf("TCH traffic: unable to allocate msgb\n");
 1202              		.loc 1 307 0
 1203 03f4 7C009FE5 		ldr	r0, .L72+36
 1204              	.LVL133:
 1205 03f8 FEFFFFEB 		bl	puts
 308:layer1/prim_tch.c **** 					goto skip_rx_traffic;
 1206              		.loc 1 308 0
 1207 03fc 0A0000EA 		b	.L65
 1208              	.L66:
 311:layer1/prim_tch.c **** 				dl = (struct l1ctl_info_dl *) msgb_put(msg, sizeof(*dl));
 1209              		.loc 1 311 0
 1210 0400 0C10A0E3 		mov	r1, #12
 1211 0404 FEFFFFEB 		bl	msgb_put
 312:layer1/prim_tch.c **** 				ti = (struct l1ctl_traffic_ind *) msgb_put(msg, sizeof(*ti));
 1212              		.loc 1 312 0
 1213 0408 2810A0E3 		mov	r1, #40
 1214 040c 0500A0E1 		mov	r0, r5
 1215 0410 FEFFFFEB 		bl	msgb_put
 315:layer1/prim_tch.c **** 				dsp_memcpy_from_api(ti->data, &traffic_buf[3], 33, 1);
 1216              		.loc 1 315 0
 1217 0414 061084E2 		add	r1, r4, #6
 1218 0418 2120A0E3 		mov	r2, #33
 1219 041c 0130A0E3 		mov	r3, #1
 1220 0420 FEFFFFEB 		bl	dsp_memcpy_from_api
 318:layer1/prim_tch.c **** 				l1_queue_for_l2(msg);
 1221              		.loc 1 318 0
 1222 0424 0500A0E1 		mov	r0, r5
 1223 0428 FEFFFFEB 		bl	l1_queue_for_l2
 1224              	.LVL134:
 1225              	.L65:
 1226              	.LBE38:
 323:layer1/prim_tch.c **** 			traffic_buf[0] = 0;
 1227              		.loc 1 323 0
 1228 042c 0020A0E3 		mov	r2, #0	@ movhi
 324:layer1/prim_tch.c **** 			traffic_buf[2] = 0xffff;
 1229              		.loc 1 324 0
 1230 0430 0030E0E3 		mvn	r3, #0	@ movhi
 323:layer1/prim_tch.c **** 			traffic_buf[0] = 0;
 1231              		.loc 1 323 0
 1232 0434 B020C4E1 		strh	r2, [r4, #0]	@ movhi
 324:layer1/prim_tch.c **** 			traffic_buf[2] = 0xffff;
 1233              		.loc 1 324 0
 1234 0438 B430C4E1 		strh	r3, [r4, #4]	@ movhi
 1235              	.LVL135:
 1236              	.L62:
 1237              	.LBE37:
 329:layer1/prim_tch.c **** 	dsp_api.r_page_used = 1;
 1238              		.loc 1 329 0
 1239 043c 20309FE5 		ldr	r3, .L72+16
 1240 0440 0120A0E3 		mov	r2, #1
 1241 0444 182083E5 		str	r2, [r3, #24]
 332:layer1/prim_tch.c **** }
 1242              		.loc 1 332 0
 1243 0448 0000A0E3 		mov	r0, #0
 1244 044c 20D08DE2 		add	sp, sp, #32
 1245 0450 F081BDE8 		ldmfd	sp!, {r4, r5, r6, r7, r8, pc}
 1246              	.L73:
 1247              		.align	2
 1248              	.L72:
 1249 0454 00000000 		.word	l1s
 1250 0458 FF6F2900 		.word	2715647
 1251 045c 00702900 		.word	2715648
 1252 0460 00000000 		.word	.LANCHOR0
 1253 0464 00000000 		.word	dsp_api
 1254 0468 C0500100 		.word	86208
 1255 046c 1A020000 		.word	538
 1256 0470 33000000 		.word	.LC1
 1257 0474 1E020000 		.word	542
 1258 0478 56000000 		.word	.LC2
 1259              		.cfi_endproc
 1260              	.LFE68:
 1262              		.section	.text.l1s_tch_a_cmd,"ax",%progbits
 1263              		.align	2
 1265              	l1s_tch_a_cmd:
 1266              	.LFB73:
 662:layer1/prim_tch.c **** 
 663:layer1/prim_tch.c **** static int l1s_tch_a_cmd(__unused uint8_t p1, __unused uint8_t p2, uint16_t p3)
 664:layer1/prim_tch.c **** {
 1267              		.loc 1 664 0
 1268              		.cfi_startproc
 1269              		@ args = 0, pretend = 0, frame = 12
 1270              		@ frame_needed = 0, uses_anonymous_args = 0
 1271              	.LVL136:
 1272 0000 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 1273              	.LCFI10:
 1274              		.cfi_def_cfa_offset 16
 1275 0004 0228A0E1 		mov	r2, r2, asl #16
 1276              	.LVL137:
 1277 0008 18D04DE2 		sub	sp, sp, #24
 1278              	.LCFI11:
 1279              		.cfi_def_cfa_offset 40
 665:layer1/prim_tch.c **** 	uint8_t mf_task_id = p3 & 0xff;
 666:layer1/prim_tch.c **** 	uint8_t chan_nr;
 667:layer1/prim_tch.c **** 	uint16_t arfcn;
 668:layer1/prim_tch.c **** 	uint8_t tsc, tn;
 669:layer1/prim_tch.c **** 	uint8_t tch_f_hn, tch_sub, tch_mode;
 670:layer1/prim_tch.c **** 	uint32_t fn_report;
 671:layer1/prim_tch.c **** 	uint8_t burst_id;
 672:layer1/prim_tch.c **** 
 673:layer1/prim_tch.c **** 	/* Get/compute various parameters */
 674:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 1280              		.loc 1 674 0
 1281 000c 16308DE2 		add	r3, sp, #22
 664:layer1/prim_tch.c **** {
 1282              		.loc 1 664 0
 1283 0010 2248A0E1 		mov	r4, r2, lsr #16
 1284              		.cfi_offset 14, -4
 1285              		.cfi_offset 6, -8
 1286              		.cfi_offset 5, -12
 1287              		.cfi_offset 4, -16
 1288              	.LVL138:
 1289              		.loc 1 674 0
 1290 0014 34029FE5 		ldr	r0, .L84
 1291              	.LVL139:
 1292 0018 17208DE2 		add	r2, sp, #23
 1293 001c 10108DE2 		add	r1, sp, #16
 1294              	.LVL140:
 1295 0020 FEFFFFEB 		bl	rfch_get_params
 1296              	.LVL141:
 675:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1297              		.loc 1 675 0
 1298 0024 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1299 0028 FF0004E2 		and	r0, r4, #255
 1300 002c FEFFFFEB 		bl	mframe_task2chan_nr
 676:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1301              		.loc 1 676 0
 1302 0030 14308DE2 		add	r3, sp, #20
 675:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1303              		.loc 1 675 0
 1304 0034 0050A0E1 		mov	r5, r0
 1305              	.LVL142:
 1306              		.loc 1 676 0
 1307 0038 00308DE5 		str	r3, [sp, #0]
 1308 003c 13308DE2 		add	r3, sp, #19
 1309 0040 04308DE5 		str	r3, [sp, #4]
 1310 0044 04029FE5 		ldr	r0, .L84
 1311              	.LVL143:
 1312 0048 0510A0E1 		mov	r1, r5
 1313 004c 0C208DE2 		add	r2, sp, #12
 1314 0050 15308DE2 		add	r3, sp, #21
 1315 0054 FEFFFFEB 		bl	tch_get_params.clone.0
 1316              	.LVL144:
 677:layer1/prim_tch.c **** 	burst_id = (fn_report - 12) / 26;
 1317              		.loc 1 677 0
 1318 0058 0C009DE5 		ldr	r0, [sp, #12]
 1319 005c 1A10A0E3 		mov	r1, #26
 1320 0060 0C0040E2 		sub	r0, r0, #12
 1321              	.LVL145:
 1322 0064 FEFFFFEB 		bl	__udivsi3
 1323              	.LVL146:
 678:layer1/prim_tch.c **** 
 679:layer1/prim_tch.c **** 	/* Load SACCH data if we start a new burst */
 680:layer1/prim_tch.c **** 	if (burst_id == 0) {
 1324              		.loc 1 680 0
 1325 0068 FF0010E3 		tst	r0, #255
 1326 006c 4800001A 		bne	.L75
 1327              	.LBB39:
 681:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_cu;
 1328              		.loc 1 681 0
 1329 0070 DC319FE5 		ldr	r3, .L84+4
 682:layer1/prim_tch.c **** 		struct msgb *msg;
 683:layer1/prim_tch.c **** 		const uint8_t *data;
 684:layer1/prim_tch.c **** 
 685:layer1/prim_tch.c **** 		/* If the TX queue is empty, send dummy measurement */
 686:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_SACCH]);
 1330              		.loc 1 686 0
 1331 0074 DC019FE5 		ldr	r0, .L84+8
 681:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_cu;
 1332              		.loc 1 681 0
 1333 0078 006093E5 		ldr	r6, [r3, #0]
 1334              	.LVL147:
 1335              		.loc 1 686 0
 1336 007c FEFFFFEB 		bl	msgb_dequeue
 1337              	.LVL148:
 687:layer1/prim_tch.c **** 		data = msg ? msg->l3h : pu_get_meas_frame();
 1338              		.loc 1 687 0
 1339 0080 004050E2 		subs	r4, r0, #0
 1340              	.LVL149:
 1341 0084 18109415 		ldrne	r1, [r4, #24]
 1342 0088 0100001A 		bne	.L77
 1343              		.loc 1 687 0 is_stmt 0 discriminator 2
 1344 008c FEFFFFEB 		bl	pu_get_meas_frame
 1345              	.LVL150:
 1346 0090 0010A0E1 		mov	r1, r0
 1347              	.L77:
 1348              	.LVL151:
 688:layer1/prim_tch.c **** 
 689:layer1/prim_tch.c **** 		/* Fill data block header */
 690:layer1/prim_tch.c **** 		info_ptr[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1349              		.loc 1 690 0 is_stmt 1 discriminator 3
 1350 0094 0229A0E3 		mov	r2, #32768
 1351 0098 993FA0E3 		mov	r3, #612
 1352 009c B32086E1 		strh	r2, [r6, r3]	@ movhi
 691:layer1/prim_tch.c **** 		info_ptr[1] = 0;		/* 2nd word: cleared. */
 1353              		.loc 1 691 0 discriminator 3
 1354 00a0 0020A0E3 		mov	r2, #0	@ movhi
 1355 00a4 023083E2 		add	r3, r3, #2
 1356 00a8 B32086E1 		strh	r2, [r6, r3]	@ movhi
 692:layer1/prim_tch.c **** 		info_ptr[2] = 0;		/* 3nd word: cleared. */
 1357              		.loc 1 692 0 discriminator 3
 1358 00ac 023083E2 		add	r3, r3, #2
 693:layer1/prim_tch.c **** 
 694:layer1/prim_tch.c **** 		/* Copy the actual data after the header */
 695:layer1/prim_tch.c **** 		dsp_memcpy_to_api(&info_ptr[3], data, 23, 0);
 1359              		.loc 1 695 0 discriminator 3
 1360 00b0 030086E0 		add	r0, r6, r3
 692:layer1/prim_tch.c **** 		info_ptr[2] = 0;		/* 3nd word: cleared. */
 1361              		.loc 1 692 0 discriminator 3
 1362 00b4 B32086E1 		strh	r2, [r6, r3]	@ movhi
 1363              		.loc 1 695 0 discriminator 3
 1364 00b8 020080E2 		add	r0, r0, #2
 1365 00bc 1720A0E3 		mov	r2, #23
 1366 00c0 9A3F43E2 		sub	r3, r3, #616
 1367 00c4 FEFFFFEB 		bl	dsp_memcpy_to_api
 1368              	.LVL152:
 696:layer1/prim_tch.c **** 
 697:layer1/prim_tch.c **** 		/* Indicate completion (FIXME: early but easier this way for now) */
 698:layer1/prim_tch.c **** 		if (msg) {
 1369              		.loc 1 698 0 discriminator 3
 1370 00c8 000054E3 		cmp	r4, #0
 1371 00cc 5A00000A 		beq	.L78
 699:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 1372              		.loc 1 699 0
 1373 00d0 84219FE5 		ldr	r2, .L84+12
 1374 00d4 84319FE5 		ldr	r3, .L84+16
 1375 00d8 BC20D2E1 		ldrh	r2, [r2, #12]
 1376 00dc B220C3E1 		strh	r2, [r3, #2]	@ movhi
 700:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_SACCH;
 1377              		.loc 1 700 0
 1378 00e0 B020D3E1 		ldrh	r2, [r3, #0]
 1379 00e4 012082E3 		orr	r2, r2, #1
 1380 00e8 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 701:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1381              		.loc 1 701 0
 1382 00ec 0300A0E3 		mov	r0, #3
 1383 00f0 FEFFFFEB 		bl	l1s_compl_sched
 702:layer1/prim_tch.c **** 		}
 703:layer1/prim_tch.c **** 
 704:layer1/prim_tch.c **** 		/* Free msg now that we're done with it */
 705:layer1/prim_tch.c **** 		if (msg)
 706:layer1/prim_tch.c **** 			msgb_free(msg);
 1384              		.loc 1 706 0
 1385 00f4 0400A0E1 		mov	r0, r4
 1386 00f8 FEFFFFEB 		bl	msgb_free
 1387 00fc 4E0000EA 		b	.L78
 1388              	.L81:
 1389              	.LBE39:
 707:layer1/prim_tch.c **** 	}
 708:layer1/prim_tch.c **** 
 709:layer1/prim_tch.c **** 	/* Allocate RX burst */
 710:layer1/prim_tch.c **** 	if (burst_id == 0) {
 711:layer1/prim_tch.c **** 		/* Clear 'dangling' msgb */
 712:layer1/prim_tch.c **** 		if (rx_tch_a.msg) {
 713:layer1/prim_tch.c **** 			/* Can happen if the task was shutdown in the middle of
 714:layer1/prim_tch.c **** 			 * 4 bursts ... */
 715:layer1/prim_tch.c **** 			msgb_free(rx_tch_a.msg);
 1390              		.loc 1 715 0
 1391 0100 FEFFFFEB 		bl	msgb_free
 1392              	.L82:
 716:layer1/prim_tch.c **** 		}
 717:layer1/prim_tch.c **** 
 718:layer1/prim_tch.c **** 		/* Allocate burst */
 719:layer1/prim_tch.c **** 			/* FIXME: we actually want all allocation out of L1S! */
 720:layer1/prim_tch.c **** 		rx_tch_a.msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 1393              		.loc 1 720 0
 1394 0104 0300A0E3 		mov	r0, #3
 1395 0108 FEFFFFEB 		bl	l1ctl_msgb_alloc
 1396 010c 4C319FE5 		ldr	r3, .L84+16
 721:layer1/prim_tch.c **** 		if (!rx_tch_a.msg)
 1397              		.loc 1 721 0
 1398 0110 000050E3 		cmp	r0, #0
 720:layer1/prim_tch.c **** 		rx_tch_a.msg = l1ctl_msgb_alloc(L1CTL_DATA_IND);
 1399              		.loc 1 720 0
 1400 0114 240083E5 		str	r0, [r3, #36]
 1401              		.loc 1 721 0
 722:layer1/prim_tch.c **** 			printf("tch_a_cmd(0): unable to allocate msgb\n");
 1402              		.loc 1 722 0
 1403 0118 44019F05 		ldreq	r0, .L84+20
 1404 011c FEFFFF0B 		bleq	puts
 1405              	.L79:
 723:layer1/prim_tch.c **** 
 724:layer1/prim_tch.c **** 		rx_tch_a.dl = (struct l1ctl_info_dl *) msgb_put(rx_tch_a.msg, sizeof(*rx_tch_a.dl));
 1406              		.loc 1 724 0
 1407 0120 38419FE5 		ldr	r4, .L84+16
 1408              	.LVL153:
 1409 0124 0C10A0E3 		mov	r1, #12
 1410 0128 240094E5 		ldr	r0, [r4, #36]
 1411 012c FEFFFFEB 		bl	msgb_put
 725:layer1/prim_tch.c **** 		rx_tch_a.di = (struct l1ctl_data_ind *) msgb_put(rx_tch_a.msg, sizeof(*rx_tch_a.di));
 1412              		.loc 1 725 0
 1413 0130 1710A0E3 		mov	r1, #23
 724:layer1/prim_tch.c **** 		rx_tch_a.dl = (struct l1ctl_info_dl *) msgb_put(rx_tch_a.msg, sizeof(*rx_tch_a.dl));
 1414              		.loc 1 724 0
 1415 0134 280084E5 		str	r0, [r4, #40]
 1416              		.loc 1 725 0
 1417 0138 240094E5 		ldr	r0, [r4, #36]
 1418 013c FEFFFFEB 		bl	msgb_put
 1419 0140 2C0084E5 		str	r0, [r4, #44]
 726:layer1/prim_tch.c **** 
 727:layer1/prim_tch.c **** 		/* Pre-fill DL header with some info about burst(0) */
 728:layer1/prim_tch.c **** 		rx_tch_a.dl->chan_nr = chan_nr;
 1420              		.loc 1 728 0
 1421 0144 284094E5 		ldr	r4, [r4, #40]
 729:layer1/prim_tch.c **** 		rx_tch_a.dl->link_id = 0x40;	/* SACCH */
 1422              		.loc 1 729 0
 1423 0148 4030A0E3 		mov	r3, #64
 728:layer1/prim_tch.c **** 		rx_tch_a.dl->chan_nr = chan_nr;
 1424              		.loc 1 728 0
 1425 014c 0050C4E5 		strb	r5, [r4, #0]
 1426              		.loc 1 729 0
 1427 0150 0130C4E5 		strb	r3, [r4, #1]
 1428              	.LVL154:
 730:layer1/prim_tch.c **** 		rx_tch_a.dl->band_arfcn = htons(arfcn);
 1429              		.loc 1 730 0
 1430 0154 B031DDE1 		ldrh	r3, [sp, #16]
 1431              	.LVL155:
 1432              	.LBB40:
 1433              	.LBB41:
  51:include/swab.h **** 	return ___constant_swab16(val);
 1434              		.loc 2 51 0
 1435 0158 2324A0E1 		mov	r2, r3, lsr #8
 1436 015c 033482E1 		orr	r3, r2, r3, asl #8
 1437              	.LVL156:
 1438              	.LBE41:
 1439              	.LBE40:
 1440              		.loc 1 730 0
 1441 0160 0230C4E5 		strb	r3, [r4, #2]
 1442 0164 2334A0E1 		mov	r3, r3, lsr #8
 1443 0168 0330C4E5 		strb	r3, [r4, #3]
 731:layer1/prim_tch.c **** 		rx_tch_a.dl->frame_nr = htonl(l1s.next_time.fn);
 1444              		.loc 1 731 0
 1445 016c E8309FE5 		ldr	r3, .L84+12
 1446 0170 0C0093E5 		ldr	r0, [r3, #12]
 1447 0174 FEFFFFEB 		bl	__fswab32
 1448 0178 2034A0E1 		mov	r3, r0, lsr #8
 1449 017c 0400C4E5 		strb	r0, [r4, #4]
 1450 0180 0530C4E5 		strb	r3, [r4, #5]
 1451 0184 2038A0E1 		mov	r3, r0, lsr #16
 1452 0188 200CA0E1 		mov	r0, r0, lsr #24
 1453 018c 0630C4E5 		strb	r3, [r4, #6]
 1454 0190 0700C4E5 		strb	r0, [r4, #7]
 1455              	.LVL157:
 1456              	.L75:
 732:layer1/prim_tch.c **** 	}
 733:layer1/prim_tch.c **** 
 734:layer1/prim_tch.c **** 	/* Configure DSP for TX/RX */
 735:layer1/prim_tch.c **** 	l1s_tx_apc_helper(arfcn);
 1457              		.loc 1 735 0
 1458 0194 B001DDE1 		ldrh	r0, [sp, #16]
 1459 0198 FEFFFFEB 		bl	l1s_tx_apc_helper
 1460              	.LVL158:
 736:layer1/prim_tch.c **** 
 737:layer1/prim_tch.c **** 	dsp_load_tch_param(
 1461              		.loc 1 737 0
 1462 019c 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 1463              	.LVL159:
 1464 01a0 0040A0E3 		mov	r4, #0
 1465 01a4 1600DDE5 		ldrb	r0, [sp, #22]	@ zero_extendqisi2
 1466              	.LVL160:
 1467 01a8 040052E1 		cmp	r2, r4
 1468              	.LVL161:
 1469 01ac 0220A003 		moveq	r2, #2
 1470              	.LVL162:
 1471 01b0 0120A013 		movne	r2, #1
 1472              	.LVL163:
 1473 01b4 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1474              	.LVL164:
 1475 01b8 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 1476 01bc 08008DE5 		str	r0, [sp, #8]
 1477              	.LVL165:
 1478 01c0 88009FE5 		ldr	r0, .L84
 1479              	.LVL166:
 1480 01c4 00408DE5 		str	r4, [sp, #0]
 1481 01c8 04408DE5 		str	r4, [sp, #4]
 1482 01cc FEFFFFEB 		bl	dsp_load_tch_param
 738:layer1/prim_tch.c **** 		&l1s.next_time,
 739:layer1/prim_tch.c **** 		tch_mode, tch_f_hn ? TCH_F : TCH_H, tch_sub,
 740:layer1/prim_tch.c **** 		0, 0, tn
 741:layer1/prim_tch.c **** 	);
 742:layer1/prim_tch.c **** 
 743:layer1/prim_tch.c **** 	dsp_load_rx_task(
 744:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHA_DSP_TASK, arfcn, 0),
 1483              		.loc 1 744 0
 1484 01d0 B011DDE1 		ldrh	r1, [sp, #16]
 1485 01d4 0420A0E1 		mov	r2, r4
 1486 01d8 0E00A0E3 		mov	r0, #14
 1487 01dc FEFFFFEB 		bl	dsp_task_iq_swap
 743:layer1/prim_tch.c **** 	dsp_load_rx_task(
 1488              		.loc 1 743 0
 1489 01e0 0410A0E1 		mov	r1, r4
 1490              	.LVL167:
 1491 01e4 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1492 01e8 FEFFFFEB 		bl	dsp_load_rx_task
 745:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCHA */
 746:layer1/prim_tch.c **** 	);
 747:layer1/prim_tch.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 1493              		.loc 1 747 0
 1494 01ec B001DDE1 		ldrh	r0, [sp, #16]
 1495 01f0 0420A0E1 		mov	r2, r4
 1496 01f4 0310A0E3 		mov	r1, #3
 1497 01f8 FEFFFFEB 		bl	l1s_rx_win_ctrl
 748:layer1/prim_tch.c **** 
 749:layer1/prim_tch.c **** 	dsp_load_tx_task(
 750:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHA_DSP_TASK, arfcn, 1),
 1498              		.loc 1 750 0
 1499 01fc B011DDE1 		ldrh	r1, [sp, #16]
 1500 0200 0120A0E3 		mov	r2, #1
 1501 0204 0E00A0E3 		mov	r0, #14
 1502 0208 FEFFFFEB 		bl	dsp_task_iq_swap
 749:layer1/prim_tch.c **** 	dsp_load_tx_task(
 1503              		.loc 1 749 0
 1504 020c 0410A0E1 		mov	r1, r4
 1505 0210 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1506 0214 FEFFFFEB 		bl	dsp_load_tx_task
 751:layer1/prim_tch.c **** 		0, tsc		/* burst_id unused for TCHA */
 752:layer1/prim_tch.c **** 	);
 753:layer1/prim_tch.c **** 	l1s_tx_win_ctrl(arfcn | ARFCN_UPLINK, L1_TXWIN_NB, 0, 3);
 1507              		.loc 1 753 0
 1508 0218 B001DDE1 		ldrh	r0, [sp, #16]
 1509              	.LVL168:
 1510 021c 0410A0E1 		mov	r1, r4
 1511 0220 010980E3 		orr	r0, r0, #16384
 1512              	.LVL169:
 1513 0224 0420A0E1 		mov	r2, r4
 1514 0228 0330A0E3 		mov	r3, #3
 1515 022c FEFFFFEB 		bl	l1s_tx_win_ctrl
 754:layer1/prim_tch.c **** 
 755:layer1/prim_tch.c **** 	return 0;
 756:layer1/prim_tch.c **** }
 1516              		.loc 1 756 0
 1517 0230 0400A0E1 		mov	r0, r4
 1518 0234 18D08DE2 		add	sp, sp, #24
 1519 0238 7080BDE8 		ldmfd	sp!, {r4, r5, r6, pc}
 1520              	.LVL170:
 1521              	.L78:
 712:layer1/prim_tch.c **** 		if (rx_tch_a.msg) {
 1522              		.loc 1 712 0
 1523 023c 1C309FE5 		ldr	r3, .L84+16
 1524 0240 240093E5 		ldr	r0, [r3, #36]
 1525 0244 000050E3 		cmp	r0, #0
 1526 0248 ACFFFF1A 		bne	.L81
 1527 024c ACFFFFEA 		b	.L82
 1528              	.L85:
 1529              		.align	2
 1530              	.L84:
 1531 0250 0C000000 		.word	l1s+12
 1532 0254 00000000 		.word	dsp_api
 1533 0258 580A0000 		.word	l1s+2648
 1534 025c 00000000 		.word	l1s
 1535 0260 00000000 		.word	.LANCHOR0
 1536 0264 7B000000 		.word	.LC3
 1537              		.cfi_endproc
 1538              	.LFE73:
 1540              		.section	.text.l1s_tch_cmd,"ax",%progbits
 1541              		.align	2
 1543              	l1s_tch_cmd:
 1544              	.LFB69:
 335:layer1/prim_tch.c **** {
 1545              		.loc 1 335 0
 1546              		.cfi_startproc
 1547              		@ args = 0, pretend = 0, frame = 12
 1548              		@ frame_needed = 0, uses_anonymous_args = 0
 1549              	.LVL171:
 1550 0000 F0402DE9 		stmfd	sp!, {r4, r5, r6, r7, lr}
 1551              	.LCFI12:
 1552              		.cfi_def_cfa_offset 20
 1553 0004 0228A0E1 		mov	r2, r2, asl #16
 1554              	.LVL172:
 1555 0008 18D04DE2 		sub	sp, sp, #24
 1556              	.LCFI13:
 1557              		.cfi_def_cfa_offset 44
 347:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 1558              		.loc 1 347 0
 1559 000c 16308DE2 		add	r3, sp, #22
 335:layer1/prim_tch.c **** {
 1560              		.loc 1 335 0
 1561 0010 2248A0E1 		mov	r4, r2, lsr #16
 1562              		.cfi_offset 14, -4
 1563              		.cfi_offset 7, -8
 1564              		.cfi_offset 6, -12
 1565              		.cfi_offset 5, -16
 1566              		.cfi_offset 4, -20
 1567              	.LVL173:
 347:layer1/prim_tch.c **** 	rfch_get_params(&l1s.next_time, &arfcn, &tsc, &tn);
 1568              		.loc 1 347 0
 1569 0014 14039FE5 		ldr	r0, .L105
 1570              	.LVL174:
 1571 0018 17208DE2 		add	r2, sp, #23
 1572 001c 10108DE2 		add	r1, sp, #16
 1573              	.LVL175:
 1574 0020 FEFFFFEB 		bl	rfch_get_params
 1575              	.LVL176:
 348:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1576              		.loc 1 348 0
 1577 0024 1610DDE5 		ldrb	r1, [sp, #22]	@ zero_extendqisi2
 1578 0028 FF0004E2 		and	r0, r4, #255
 1579 002c FEFFFFEB 		bl	mframe_task2chan_nr
 349:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1580              		.loc 1 349 0
 1581 0030 14308DE2 		add	r3, sp, #20
 1582 0034 00308DE5 		str	r3, [sp, #0]
 1583 0038 13308DE2 		add	r3, sp, #19
 348:layer1/prim_tch.c **** 	chan_nr = mframe_task2chan_nr(mf_task_id, tn);
 1584              		.loc 1 348 0
 1585 003c 0010A0E1 		mov	r1, r0
 1586              	.LVL177:
 349:layer1/prim_tch.c **** 	tch_get_params(&l1s.next_time, chan_nr, &fn_report, &tch_f_hn, &tch_sub, &tch_mode);
 1587              		.loc 1 349 0
 1588 0040 04308DE5 		str	r3, [sp, #4]
 1589 0044 E4029FE5 		ldr	r0, .L105
 1590              	.LVL178:
 1591 0048 15308DE2 		add	r3, sp, #21
 1592 004c 0C208DE2 		add	r2, sp, #12
 1593 0050 FEFFFFEB 		bl	tch_get_params.clone.0
 1594              	.LVL179:
 352:layer1/prim_tch.c **** 	if (l1s.tch_sync) {
 1595              		.loc 1 352 0
 1596 0054 D8129FE5 		ldr	r1, .L105+4
 1597 0058 4B5AD1E5 		ldrb	r5, [r1, #2635]	@ zero_extendqisi2
 1598 005c 000055E3 		cmp	r5, #0
 1599 0060 D0329FE5 		ldr	r3, .L105+8
 353:layer1/prim_tch.c **** 		l1s.tch_sync = 0;
 1600              		.loc 1 353 0
 1601 0064 0020A013 		movne	r2, #0
 1602 0068 4B2AC115 		strneb	r2, [r1, #2635]
 1603              	.LVL180:
 355:layer1/prim_tch.c **** 		icnt = 0;
 1604              		.loc 1 355 0
 1605 006c 74208315 		strne	r2, [r3, #116]
 354:layer1/prim_tch.c **** 		sync = 1;
 1606              		.loc 1 354 0
 1607 0070 0150A013 		movne	r5, #1
 1608 0074 0300001A 		bne	.L88
 1609              	.LVL181:
 1610              	.L87:
 356:layer1/prim_tch.c **** 	} else if (icnt <= 26)
 1611              		.loc 1 356 0
 1612 0078 742093E5 		ldr	r2, [r3, #116]
 1613 007c 1A0052E3 		cmp	r2, #26
 357:layer1/prim_tch.c **** 		icnt++;
 1614              		.loc 1 357 0
 1615 0080 012082D2 		addle	r2, r2, #1
 1616 0084 742083D5 		strle	r2, [r3, #116]
 1617              	.LVL182:
 1618              	.L88:
 362:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1619              		.loc 1 362 0
 1620 0088 1530DDE5 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 1621              	.LVL183:
 1622 008c 000053E3 		cmp	r3, #0
 1623              	.LVL184:
 1624 0090 9C329FE5 		ldr	r3, .L105+4
 1625              	.LVL185:
 1626 0094 0500000A 		beq	.L89
 364:layer1/prim_tch.c **** 		facch_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 1627              		.loc 1 364 0
 1628 0098 0C0093E5 		ldr	r0, [r3, #12]
 1629 009c 0D10A0E3 		mov	r1, #13
 1630 00a0 FEFFFFEB 		bl	__umodsi3
 1631 00a4 030000E2 		and	r0, r0, #3
 373:layer1/prim_tch.c **** 	if (facch_tx_now) {
 1632              		.loc 1 373 0
 1633 00a8 030050E3 		cmp	r0, #3
 1634 00ac 070000EA 		b	.L104
 1635              	.LVL186:
 1636              	.L89:
 1637              	.LBB42:
 367:layer1/prim_tch.c **** 		uint8_t t2_norm = l1s.next_time.t2 - tch_sub;
 1638              		.loc 1 367 0
 1639 00b0 1220D3E5 		ldrb	r2, [r3, #18]	@ zero_extendqisi2
 1640              	.LVL187:
 1641 00b4 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1642              	.LVL188:
 1643 00b8 023063E0 		rsb	r3, r3, r2
 1644              	.LVL189:
 1645 00bc FF3003E2 		and	r3, r3, #255
 1646              	.LVL190:
 368:layer1/prim_tch.c **** 		facch_tx_now = (t2_norm == 23) ||
 1647              		.loc 1 368 0
 1648 00c0 170053E3 		cmp	r3, #23
 1649 00c4 06005313 		cmpne	r3, #6
 1650 00c8 0100000A 		beq	.L90
 369:layer1/prim_tch.c **** 		               (t2_norm ==  6) ||
 1651              		.loc 1 369 0
 1652 00cc 0F0053E3 		cmp	r3, #15
 1653              	.LVL191:
 1654              	.L104:
 1655 00d0 2A00001A 		bne	.L91
 1656              	.L90:
 1657              	.LBE42:
 1658              	.LBB43:
 374:layer1/prim_tch.c **** 		uint16_t *info_ptr = dsp_api.ndb->a_fu;
 1659              		.loc 1 374 0
 1660 00d4 60329FE5 		ldr	r3, .L105+12
 1661 00d8 006093E5 		ldr	r6, [r3, #0]
 1662              	.LVL192:
 379:layer1/prim_tch.c **** 		if (icnt > 26)
 1663              		.loc 1 379 0
 1664 00dc 54329FE5 		ldr	r3, .L105+8
 1665              	.LVL193:
 1666 00e0 743093E5 		ldr	r3, [r3, #116]
 1667 00e4 1A0053E3 		cmp	r3, #26
 1668 00e8 040000DA 		ble	.L92
 380:layer1/prim_tch.c **** 			msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_MAIN]);
 1669              		.loc 1 380 0
 1670 00ec 4C029FE5 		ldr	r0, .L105+16
 1671 00f0 FEFFFFEB 		bl	msgb_dequeue
 1672              	.LVL194:
 385:layer1/prim_tch.c **** 		if (msg)
 1673              		.loc 1 385 0
 1674 00f4 004050E2 		subs	r4, r0, #0
 1675              	.LVL195:
 386:layer1/prim_tch.c **** 			data = msg->l3h;
 1676              		.loc 1 386 0
 1677 00f8 18109415 		ldrne	r1, [r4, #24]
 385:layer1/prim_tch.c **** 		if (msg)
 1678              		.loc 1 385 0
 1679 00fc 0400001A 		bne	.L93
 1680              	.LVL196:
 1681              	.L92:
 387:layer1/prim_tch.c **** 		else if (tch_mode == SIG_ONLY_MODE)
 1682              		.loc 1 387 0
 1683 0100 1340DDE5 		ldrb	r4, [sp, #19]	@ zero_extendqisi2
 1684              	.LVL197:
 1685 0104 000054E3 		cmp	r4, #0
 1686              	.LVL198:
 1687 0108 1C00001A 		bne	.L91
 388:layer1/prim_tch.c **** 			data = pu_get_idle_frame();
 1688              		.loc 1 388 0
 1689 010c FEFFFFEB 		bl	pu_get_idle_frame
 1690 0110 0010A0E1 		mov	r1, r0
 1691              	.LVL199:
 1692              	.L93:
 393:layer1/prim_tch.c **** 		if (data) {
 1693              		.loc 1 393 0
 1694 0114 000051E3 		cmp	r1, #0
 1695 0118 0B00000A 		beq	.L94
 395:layer1/prim_tch.c **** 			info_ptr[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1696              		.loc 1 395 0
 1697 011c 20329FE5 		ldr	r3, .L105+20
 1698 0120 0229A0E3 		mov	r2, #32768
 1699 0124 B32086E1 		strh	r2, [r6, r3]	@ movhi
 396:layer1/prim_tch.c **** 			info_ptr[1] = 0;		/* 2nd word: cleared. */
 1700              		.loc 1 396 0
 1701 0128 0020A0E3 		mov	r2, #0	@ movhi
 1702 012c 023083E2 		add	r3, r3, #2
 1703 0130 B32086E1 		strh	r2, [r6, r3]	@ movhi
 397:layer1/prim_tch.c **** 			info_ptr[2] = 0;		/* 3nd word: cleared. */
 1704              		.loc 1 397 0
 1705 0134 023083E2 		add	r3, r3, #2
 1706 0138 B32086E1 		strh	r2, [r6, r3]	@ movhi
 400:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&info_ptr[3], data, 23, 0);
 1707              		.loc 1 400 0
 1708 013c A20F86E2 		add	r0, r6, #648
 1709 0140 1720A0E3 		mov	r2, #23
 1710 0144 0030A0E3 		mov	r3, #0
 1711 0148 FEFFFFEB 		bl	dsp_memcpy_to_api
 1712              	.LVL200:
 1713              	.L94:
 404:layer1/prim_tch.c **** 		if (msg) {
 1714              		.loc 1 404 0
 1715 014c 000054E3 		cmp	r4, #0
 1716 0150 0A00000A 		beq	.L91
 405:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 1717              		.loc 1 405 0
 1718 0154 D8219FE5 		ldr	r2, .L105+4
 1719 0158 D8319FE5 		ldr	r3, .L105+8
 1720 015c BC20D2E1 		ldrh	r2, [r2, #12]
 1721 0160 B220C3E1 		strh	r2, [r3, #2]	@ movhi
 406:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_FACCH;
 1722              		.loc 1 406 0
 1723 0164 B020D3E1 		ldrh	r2, [r3, #0]
 1724 0168 022082E3 		orr	r2, r2, #2
 407:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1725              		.loc 1 407 0
 1726 016c 0300A0E3 		mov	r0, #3
 406:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_FACCH;
 1727              		.loc 1 406 0
 1728 0170 B020C3E1 		strh	r2, [r3, #0]	@ movhi
 407:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1729              		.loc 1 407 0
 1730 0174 FEFFFFEB 		bl	l1s_compl_sched
 412:layer1/prim_tch.c **** 			msgb_free(msg);
 1731              		.loc 1 412 0
 1732 0178 0400A0E1 		mov	r0, r4
 1733 017c FEFFFFEB 		bl	msgb_free
 1734              	.LVL201:
 1735              	.L91:
 1736              	.LBE43:
 416:layer1/prim_tch.c **** 	if (tch_f_hn) {
 1737              		.loc 1 416 0
 1738 0180 1530DDE5 		ldrb	r3, [sp, #21]	@ zero_extendqisi2
 1739              	.LVL202:
 1740 0184 000053E3 		cmp	r3, #0
 1741              	.LVL203:
 1742 0188 A4319FE5 		ldr	r3, .L105+4
 1743              	.LVL204:
 1744 018c 0700000A 		beq	.L95
 418:layer1/prim_tch.c **** 		traffic_tx_now = ((l1s.next_time.fn % 13) % 4) == 3;
 1745              		.loc 1 418 0
 1746 0190 0C0093E5 		ldr	r0, [r3, #12]
 1747 0194 0D10A0E3 		mov	r1, #13
 1748 0198 FEFFFFEB 		bl	__umodsi3
 1749 019c 030000E2 		and	r0, r0, #3
 1750 01a0 030050E3 		cmp	r0, #3
 1751 01a4 0000A013 		movne	r0, #0
 1752 01a8 0100A003 		moveq	r0, #1
 1753              	.LVL205:
 1754 01ac 090000EA 		b	.L96
 1755              	.LVL206:
 1756              	.L95:
 422:layer1/prim_tch.c **** 		traffic_tx_now = (((l1s.next_time.fn - tch_sub + 13) % 13) % 4) == 2;
 1757              		.loc 1 422 0
 1758 01b0 0C0093E5 		ldr	r0, [r3, #12]
 1759              	.LVL207:
 1760 01b4 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1761              	.LVL208:
 1762 01b8 0D0080E2 		add	r0, r0, #13
 1763 01bc 000063E0 		rsb	r0, r3, r0
 1764              	.LVL209:
 1765 01c0 0D10A0E3 		mov	r1, #13
 1766 01c4 FEFFFFEB 		bl	__umodsi3
 1767              	.LVL210:
 1768 01c8 030000E2 		and	r0, r0, #3
 1769 01cc 020050E3 		cmp	r0, #2
 1770 01d0 0000A013 		movne	r0, #0
 1771 01d4 0100A003 		moveq	r0, #1
 1772              	.LVL211:
 1773              	.L96:
 425:layer1/prim_tch.c **** 	if (traffic_tx_now) {
 1774              		.loc 1 425 0
 1775 01d8 000050E3 		cmp	r0, #0
 1776 01dc 2A00000A 		beq	.L97
 1777              	.LBB44:
 431:layer1/prim_tch.c **** 		dsp_api.ndb->d_tch_mode &= ~B_PLAY_UL;
 1778              		.loc 1 431 0
 1779 01e0 54319FE5 		ldr	r3, .L105+12
 1780 01e4 004093E5 		ldr	r4, [r3, #0]
 1781              	.LVL212:
 1782 01e8 B630D4E1 		ldrh	r3, [r4, #6]
 1783 01ec 0830C3E3 		bic	r3, r3, #8
 1784 01f0 B630C4E1 		strh	r3, [r4, #6]	@ movhi
 434:layer1/prim_tch.c **** 		if (!(l1s.audio_mode & AUDIO_TX_TRAFFIC_REQ))
 1785              		.loc 1 434 0
 1786 01f4 38319FE5 		ldr	r3, .L105+4
 1787 01f8 4C3AD3E5 		ldrb	r3, [r3, #2636]	@ zero_extendqisi2
 1788 01fc 020013E3 		tst	r3, #2
 1789 0200 2100000A 		beq	.L97
 1790              	.LVL213:
 438:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_du_0 : dsp_api.ndb->a_du_1;
 1791              		.loc 1 438 0
 1792 0204 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1793              	.LVL214:
 441:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 1794              		.loc 1 441 0
 1795 0208 38719FE5 		ldr	r7, .L105+24
 438:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_du_0 : dsp_api.ndb->a_du_1;
 1796              		.loc 1 438 0
 1797 020c 000053E3 		cmp	r3, #0
 1798              	.LVL215:
 441:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 1799              		.loc 1 441 0
 1800 0210 0700A0E1 		mov	r0, r7
 1801              	.LVL216:
 438:layer1/prim_tch.c **** 		traffic_buf = tch_sub ? dsp_api.ndb->a_du_0 : dsp_api.ndb->a_du_1;
 1802              		.loc 1 438 0
 1803 0214 2A4E8412 		addne	r4, r4, #672
 1804 0218 4D4F8402 		addeq	r4, r4, #308
 1805              	.LVL217:
 441:layer1/prim_tch.c **** 		msg = msgb_dequeue(&l1s.tx_queue[L1S_CHAN_TRAFFIC]);
 1806              		.loc 1 441 0
 1807 021c FEFFFFEB 		bl	msgb_dequeue
 1808              	.LVL218:
 444:layer1/prim_tch.c **** 		if (msg) {
 1809              		.loc 1 444 0
 1810 0220 006050E2 		subs	r6, r0, #0
 1811 0224 1800000A 		beq	.L97
 1812              	.LVL219:
 446:layer1/prim_tch.c **** 			dsp_memcpy_to_api(&traffic_buf[3], data, 33, 1);
 1813              		.loc 1 446 0
 1814 0228 060084E2 		add	r0, r4, #6
 1815              	.LVL220:
 1816 022c 141096E5 		ldr	r1, [r6, #20]
 1817 0230 2120A0E3 		mov	r2, #33
 1818 0234 0130A0E3 		mov	r3, #1
 1819 0238 FEFFFFEB 		bl	dsp_memcpy_to_api
 1820              	.LVL221:
 448:layer1/prim_tch.c **** 			traffic_buf[0] = (1 << B_BLUD);	/* 1st word: Set B_BLU bit. */
 1821              		.loc 1 448 0
 1822 023c 0239A0E3 		mov	r3, #32768
 1823 0240 B030C4E1 		strh	r3, [r4, #0]	@ movhi
 449:layer1/prim_tch.c **** 			traffic_buf[1] = 0;		/* 2nd word: cleared. */
 1824              		.loc 1 449 0
 1825 0244 0030A0E3 		mov	r3, #0	@ movhi
 1826 0248 B230C4E1 		strh	r3, [r4, #2]	@ movhi
 450:layer1/prim_tch.c **** 			traffic_buf[2] = 0;		/* 3nd word: cleared. */
 1827              		.loc 1 450 0
 1828 024c B430C4E1 		strh	r3, [r4, #4]	@ movhi
 454:layer1/prim_tch.c **** 			dsp_api.ndb->d_tch_mode |= B_PLAY_UL;
 1829              		.loc 1 454 0
 1830 0250 E4309FE5 		ldr	r3, .L105+12
 1831 0254 003093E5 		ldr	r3, [r3, #0]
 1832 0258 B620D3E1 		ldrh	r2, [r3, #6]
 1833 025c 082082E3 		orr	r2, r2, #8
 1834 0260 B620C3E1 		strh	r2, [r3, #6]	@ movhi
 458:layer1/prim_tch.c **** 			last_tx_tch_fn = l1s.next_time.fn;
 1835              		.loc 1 458 0
 1836 0264 CC309FE5 		ldr	r3, .L105+8
 1837 0268 542A17E5 		ldr	r2, [r7, #-2644]
 1838 026c B220C3E1 		strh	r2, [r3, #2]	@ movhi
 459:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_TRAFFIC;
 1839              		.loc 1 459 0
 1840 0270 B020D3E1 		ldrh	r2, [r3, #0]
 1841 0274 042082E3 		orr	r2, r2, #4
 460:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1842              		.loc 1 460 0
 1843 0278 0300A0E3 		mov	r0, #3
 459:layer1/prim_tch.c **** 			last_tx_tch_type |= TX_TYPE_TRAFFIC;
 1844              		.loc 1 459 0
 1845 027c B020C3E1 		strh	r2, [r3, #0]	@ movhi
 460:layer1/prim_tch.c **** 			l1s_compl_sched(L1_COMPL_TX_TCH);
 1846              		.loc 1 460 0
 1847 0280 FEFFFFEB 		bl	l1s_compl_sched
 465:layer1/prim_tch.c **** 			msgb_free(msg);
 1848              		.loc 1 465 0
 1849 0284 0600A0E1 		mov	r0, r6
 1850 0288 FEFFFFEB 		bl	msgb_free
 1851              	.LVL222:
 1852              	.L97:
 1853              	.LBE44:
 470:layer1/prim_tch.c **** 	l1s_tx_apc_helper(arfcn);
 1854              		.loc 1 470 0
 1855 028c B001DDE1 		ldrh	r0, [sp, #16]
 1856 0290 FEFFFFEB 		bl	l1s_tx_apc_helper
 1857              	.LVL223:
 472:layer1/prim_tch.c **** 	dsp_load_tch_param(
 1858              		.loc 1 472 0
 1859 0294 1520DDE5 		ldrb	r2, [sp, #21]	@ zero_extendqisi2
 1860              	.LVL224:
 1861 0298 0040A0E3 		mov	r4, #0
 1862              	.LVL225:
 1863 029c 1600DDE5 		ldrb	r0, [sp, #22]	@ zero_extendqisi2
 1864              	.LVL226:
 1865 02a0 040052E1 		cmp	r2, r4
 1866              	.LVL227:
 1867 02a4 0220A003 		moveq	r2, #2
 1868              	.LVL228:
 1869 02a8 0120A013 		movne	r2, #1
 1870              	.LVL229:
 1871 02ac 1430DDE5 		ldrb	r3, [sp, #20]	@ zero_extendqisi2
 1872              	.LVL230:
 1873 02b0 1310DDE5 		ldrb	r1, [sp, #19]	@ zero_extendqisi2
 1874 02b4 08008DE5 		str	r0, [sp, #8]
 1875              	.LVL231:
 1876 02b8 70009FE5 		ldr	r0, .L105
 1877              	.LVL232:
 1878 02bc 30008DE8 		stmia	sp, {r4, r5}	@ phole stm
 1879 02c0 FEFFFFEB 		bl	dsp_load_tch_param
 479:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 0),
 1880              		.loc 1 479 0
 1881 02c4 B011DDE1 		ldrh	r1, [sp, #16]
 1882 02c8 0420A0E1 		mov	r2, r4
 1883 02cc 0D00A0E3 		mov	r0, #13
 1884 02d0 FEFFFFEB 		bl	dsp_task_iq_swap
 478:layer1/prim_tch.c **** 	dsp_load_rx_task(
 1885              		.loc 1 478 0
 1886 02d4 0410A0E1 		mov	r1, r4
 1887              	.LVL233:
 1888 02d8 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1889 02dc FEFFFFEB 		bl	dsp_load_rx_task
 482:layer1/prim_tch.c **** 	l1s_rx_win_ctrl(arfcn, L1_RXWIN_NB, 0);
 1890              		.loc 1 482 0
 1891 02e0 B001DDE1 		ldrh	r0, [sp, #16]
 1892 02e4 0420A0E1 		mov	r2, r4
 1893 02e8 0310A0E3 		mov	r1, #3
 1894 02ec FEFFFFEB 		bl	l1s_rx_win_ctrl
 485:layer1/prim_tch.c **** 		dsp_task_iq_swap(TCHT_DSP_TASK, arfcn, 1),
 1895              		.loc 1 485 0
 1896 02f0 B011DDE1 		ldrh	r1, [sp, #16]
 1897 02f4 0120A0E3 		mov	r2, #1
 1898 02f8 0D00A0E3 		mov	r0, #13
 1899 02fc FEFFFFEB 		bl	dsp_task_iq_swap
 484:layer1/prim_tch.c **** 	dsp_load_tx_task(
 1900              		.loc 1 484 0
 1901 0300 0410A0E1 		mov	r1, r4
 1902 0304 1720DDE5 		ldrb	r2, [sp, #23]	@ zero_extendqisi2
 1903 0308 FEFFFFEB 		bl	dsp_load_tx_task
 488:layer1/prim_tch.c **** 	l1s_tx_win_ctrl(arfcn | ARFCN_UPLINK, L1_TXWIN_NB, 0, 3);
 1904              		.loc 1 488 0
 1905 030c B001DDE1 		ldrh	r0, [sp, #16]
 1906              	.LVL234:
 1907 0310 0410A0E1 		mov	r1, r4
 1908 0314 010980E3 		orr	r0, r0, #16384
 1909              	.LVL235:
 1910 0318 0420A0E1 		mov	r2, r4
 1911 031c 0330A0E3 		mov	r3, #3
 1912 0320 FEFFFFEB 		bl	l1s_tx_win_ctrl
 491:layer1/prim_tch.c **** }
 1913              		.loc 1 491 0
 1914 0324 0400A0E1 		mov	r0, r4
 1915 0328 18D08DE2 		add	sp, sp, #24
 1916 032c F080BDE8 		ldmfd	sp!, {r4, r5, r6, r7, pc}
 1917              	.L106:
 1918              		.align	2
 1919              	.L105:
 1920 0330 0C000000 		.word	l1s+12
 1921 0334 00000000 		.word	l1s
 1922 0338 00000000 		.word	.LANCHOR0
 1923 033c 00000000 		.word	dsp_api
 1924 0340 500A0000 		.word	l1s+2640
 1925 0344 82020000 		.word	642
 1926 0348 600A0000 		.word	l1s+2656
 1927              		.cfi_endproc
 1928              	.LFE69:
 1930              		.section	.text.prim_tch_init,"ax",%progbits
 1931              		.align	2
 1933              	prim_tch_init:
 1934              	.LFB67:
 132:layer1/prim_tch.c **** {
 1935              		.loc 1 132 0
 1936              		.cfi_startproc
 1937              		@ args = 0, pretend = 0, frame = 0
 1938              		@ frame_needed = 0, uses_anonymous_args = 0
 1939              		@ link register save eliminated.
 133:layer1/prim_tch.c **** 	l1s.completion[L1_COMPL_TX_TCH]  = &l1a_tx_tch_compl;
 1940              		.loc 1 133 0
 1941 0000 08209FE5 		ldr	r2, .L108
 1942 0004 08309FE5 		ldr	r3, .L108+4
 1943 0008 7C2A83E5 		str	r2, [r3, #2684]
 134:layer1/prim_tch.c **** }
 1944              		.loc 1 134 0
 1945 000c 1EFF2FE1 		bx	lr
 1946              	.L109:
 1947              		.align	2
 1948              	.L108:
 1949 0010 00000000 		.word	l1a_tx_tch_compl
 1950 0014 00000000 		.word	l1s
 1951              		.cfi_endproc
 1952              	.LFE67:
 1954              		.section	.ctors,"aw",%progbits
 1955              		.align	2
 1956 0000 00000000 		.word	prim_tch_init
 1957              		.global	tch_sched_set
 1958              		.global	tch_d_sched_set
 1959              		.global	tch_a_sched_set
 1960              		.section	.rodata
 1961              		.align	2
 1964              	tch_sched_set:
 1965 0000 00000000 		.word	l1s_tch_cmd
 1966 0004 00       		.byte	0
 1967 0005 00       		.byte	0
 1968 0006 0000     		.space	2
 1969 0008 0000     		.short	0
 1970 000a 0300     		.short	3
 1971 000c 00000000 		.word	0
 1972 0010 00       		.byte	0
 1973 0011 00       		.byte	0
 1974 0012 00000000 		.space	6
 1974      0000
 1975 0018 00000000 		.word	0
 1976 001c 00       		.byte	0
 1977 001d 00       		.byte	0
 1978 001e 00000000 		.space	6
 1978      0000
 1979 0024 00000000 		.word	l1s_tch_resp
 1980 0028 00       		.byte	0
 1981 0029 FC       		.byte	-4
 1982 002a 0000     		.space	2
 1983 002c 0000     		.short	0
 1984 002e 0000     		.short	0
 1985 0030 00000000 		.word	0
 1986 0034 00       		.byte	0
 1987 0035 00       		.byte	0
 1988 0036 00000000 		.space	6
 1988      0000
 1989 003c 00000000 		.word	tdma_end_set
 1990 0040 00       		.byte	0
 1991 0041 00       		.byte	0
 1992 0042 00000000 		.space	6
 1992      0000
 1995              	tch_d_sched_set:
 1996 0048 00000000 		.word	l1s_tch_d_cmd
 1997 004c 00       		.byte	0
 1998 004d 00       		.byte	0
 1999 004e 0000     		.space	2
 2000 0050 0000     		.short	0
 2001 0052 0300     		.short	3
 2002 0054 00000000 		.word	0
 2003 0058 00       		.byte	0
 2004 0059 00       		.byte	0
 2005 005a 00000000 		.space	6
 2005      0000
 2006 0060 00000000 		.word	0
 2007 0064 00       		.byte	0
 2008 0065 00       		.byte	0
 2009 0066 00000000 		.space	6
 2009      0000
 2010 006c 00000000 		.word	l1s_tch_d_resp
 2011 0070 00       		.byte	0
 2012 0071 FC       		.byte	-4
 2013 0072 0000     		.space	2
 2014 0074 0000     		.short	0
 2015 0076 0000     		.short	0
 2016 0078 00000000 		.word	0
 2017 007c 00       		.byte	0
 2018 007d 00       		.byte	0
 2019 007e 00000000 		.space	6
 2019      0000
 2020 0084 00000000 		.word	tdma_end_set
 2021 0088 00       		.byte	0
 2022 0089 00       		.byte	0
 2023 008a 00000000 		.space	6
 2023      0000
 2026              	tch_a_sched_set:
 2027 0090 00000000 		.word	l1s_tch_a_cmd
 2028 0094 00       		.byte	0
 2029 0095 00       		.byte	0
 2030 0096 0000     		.space	2
 2031 0098 0000     		.short	0
 2032 009a 0300     		.short	3
 2033 009c 00000000 		.word	0
 2034 00a0 00       		.byte	0
 2035 00a1 00       		.byte	0
 2036 00a2 00000000 		.space	6
 2036      0000
 2037 00a8 00000000 		.word	0
 2038 00ac 00       		.byte	0
 2039 00ad 00       		.byte	0
 2040 00ae 00000000 		.space	6
 2040      0000
 2041 00b4 00000000 		.word	l1s_tch_a_resp
 2042 00b8 00       		.byte	0
 2043 00b9 FC       		.byte	-4
 2044 00ba 0000     		.space	2
 2045 00bc 0000     		.short	0
 2046 00be 0000     		.short	0
 2047 00c0 00000000 		.word	0
 2048 00c4 00       		.byte	0
 2049 00c5 00       		.byte	0
 2050 00c6 00000000 		.space	6
 2050      0000
 2051 00cc 00000000 		.word	tdma_end_set
 2052 00d0 00       		.byte	0
 2053 00d1 00       		.byte	0
 2054 00d2 00000000 		.space	6
 2054      0000
 2055              		.section	.rodata.str1.1,"aMS",%progbits,1
 2056              	.LC0:
 2057 0000 6D736762 		.ascii	"msgb(%p): Not enough tailroom msgb_push (%u < %u)\012"
 2057      28257029 
 2057      3A204E6F 
 2057      7420656E 
 2057      6F756768 
 2058 0032 00       		.ascii	"\000"
 2059              	.LC1:
 2060 0033 54434820 		.ascii	"TCH FACCH: unable to allocate msgb\000"
 2060      46414343 
 2060      483A2075 
 2060      6E61626C 
 2060      6520746F 
 2061              	.LC2:
 2062 0056 54434820 		.ascii	"TCH traffic: unable to allocate msgb\000"
 2062      74726166 
 2062      6669633A 
 2062      20756E61 
 2062      626C6520 
 2063              	.LC3:
 2064 007b 7463685F 		.ascii	"tch_a_cmd(0): unable to allocate msgb\000"
 2064      615F636D 
 2064      64283029 
 2064      3A20756E 
 2064      61626C65 
 2065              		.bss
 2066              		.align	2
 2067              		.set	.LANCHOR0,. + 0
 2070              	last_tx_tch_type:
 2071 0000 0000     		.space	2
 2074              	last_tx_tch_fn:
 2075 0002 0000     		.space	2
 2078              	rx_tch_a:
 2079 0004 00000000 		.space	44
 2079      00000000 
 2079      00000000 
 2079      00000000 
 2079      00000000 
 2082              	meas_id.4108:
 2083 0030 00       		.space	1
 2084 0031 000000   		.space	3
 2087              	rx_tch:
 2088 0034 00000000 		.space	64
 2088      00000000 
 2088      00000000 
 2088      00000000 
 2088      00000000 
 2091              	icnt.4154:
 2092 0074 00000000 		.space	4
 2093              		.text
 2094              	.Letext0:
DEFINED SYMBOLS
                            *ABS*:0000000000000000 prim_tch.c
     /tmp/cc1doT2C.s:12     .text.l1s_tch_d_resp:0000000000000000 $a
     /tmp/cc1doT2C.s:14     .text.l1s_tch_d_resp:0000000000000000 l1s_tch_d_resp
     /tmp/cc1doT2C.s:35     .text.l1s_tch_d_resp:0000000000000014 $d
     /tmp/cc1doT2C.s:40     .text.__fswab32:0000000000000000 $a
     /tmp/cc1doT2C.s:42     .text.__fswab32:0000000000000000 __fswab32
     /tmp/cc1doT2C.s:75     .text.msgb_put:0000000000000000 $a
     /tmp/cc1doT2C.s:77     .text.msgb_put:0000000000000000 msgb_put
     /tmp/cc1doT2C.s:142    .text.msgb_put:0000000000000054 $d
     /tmp/cc1doT2C.s:147    .text.dsp_task_iq_swap:0000000000000000 $a
     /tmp/cc1doT2C.s:149    .text.dsp_task_iq_swap:0000000000000000 dsp_task_iq_swap
     /tmp/cc1doT2C.s:182    .text.l1a_tx_tch_compl:0000000000000000 $a
     /tmp/cc1doT2C.s:184    .text.l1a_tx_tch_compl:0000000000000000 l1a_tx_tch_compl
     /tmp/cc1doT2C.s:235    .text.l1a_tx_tch_compl:0000000000000064 $d
     /tmp/cc1doT2C.s:241    .text.tch_get_params.clone.0:0000000000000000 $a
     /tmp/cc1doT2C.s:243    .text.tch_get_params.clone.0:0000000000000000 tch_get_params.clone.0
     /tmp/cc1doT2C.s:354    .text.tch_get_params.clone.0:00000000000000d8 $d
     /tmp/cc1doT2C.s:360    .text.l1s_tch_a_resp:0000000000000000 $a
     /tmp/cc1doT2C.s:362    .text.l1s_tch_a_resp:0000000000000000 l1s_tch_a_resp
     /tmp/cc1doT2C.s:630    .text.l1s_tch_a_resp:0000000000000268 $d
     /tmp/cc1doT2C.s:640    .text.l1s_tch_d_cmd:0000000000000000 $a
     /tmp/cc1doT2C.s:642    .text.l1s_tch_d_cmd:0000000000000000 l1s_tch_d_cmd
     /tmp/cc1doT2C.s:732    .text.l1s_tch_d_cmd:00000000000000b4 $d
     /tmp/cc1doT2C.s:738    .text.l1s_tch_resp:0000000000000000 $a
     /tmp/cc1doT2C.s:740    .text.l1s_tch_resp:0000000000000000 l1s_tch_resp
     /tmp/cc1doT2C.s:1249   .text.l1s_tch_resp:0000000000000454 $d
     /tmp/cc1doT2C.s:1263   .text.l1s_tch_a_cmd:0000000000000000 $a
     /tmp/cc1doT2C.s:1265   .text.l1s_tch_a_cmd:0000000000000000 l1s_tch_a_cmd
     /tmp/cc1doT2C.s:1531   .text.l1s_tch_a_cmd:0000000000000250 $d
     /tmp/cc1doT2C.s:1541   .text.l1s_tch_cmd:0000000000000000 $a
     /tmp/cc1doT2C.s:1543   .text.l1s_tch_cmd:0000000000000000 l1s_tch_cmd
     /tmp/cc1doT2C.s:1920   .text.l1s_tch_cmd:0000000000000330 $d
     /tmp/cc1doT2C.s:1931   .text.prim_tch_init:0000000000000000 $a
     /tmp/cc1doT2C.s:1933   .text.prim_tch_init:0000000000000000 prim_tch_init
     /tmp/cc1doT2C.s:1949   .text.prim_tch_init:0000000000000010 $d
     /tmp/cc1doT2C.s:1955   .ctors:0000000000000000 $d
     /tmp/cc1doT2C.s:1964   .rodata:0000000000000000 tch_sched_set
     /tmp/cc1doT2C.s:1995   .rodata:0000000000000048 tch_d_sched_set
     /tmp/cc1doT2C.s:2026   .rodata:0000000000000090 tch_a_sched_set
     /tmp/cc1doT2C.s:1961   .rodata:0000000000000000 $d
     /tmp/cc1doT2C.s:2066   .bss:0000000000000000 $d
     /tmp/cc1doT2C.s:2070   .bss:0000000000000000 last_tx_tch_type
     /tmp/cc1doT2C.s:2074   .bss:0000000000000002 last_tx_tch_fn
     /tmp/cc1doT2C.s:2078   .bss:0000000000000004 rx_tch_a
     /tmp/cc1doT2C.s:2082   .bss:0000000000000030 meas_id.4108
     /tmp/cc1doT2C.s:2087   .bss:0000000000000034 rx_tch
     /tmp/cc1doT2C.s:2091   .bss:0000000000000074 icnt.4154
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
dsp_api
osmo_panic
rffe_iq_swapped
l1_create_l2_msg
l1_queue_for_l2
__umodsi3
l1s
__udivsi3
gsm_fn2gsmtime
rfch_get_params
mframe_task2chan_nr
agc_inp_dbm8_by_pm
afc_input
toa_input
rffe_compute_gain
dbm2rxlev
pu_update_rx_level
dsp_memcpy_from_api
dsp_load_tch_param
dsp_load_rx_task
dsp_load_tx_task
__divsi3
l1ctl_msgb_alloc
puts
msgb_dequeue
pu_get_meas_frame
dsp_memcpy_to_api
l1s_compl_sched
msgb_free
l1s_tx_apc_helper
l1s_rx_win_ctrl
l1s_tx_win_ctrl
pu_get_idle_frame
tdma_end_set
